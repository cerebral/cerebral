import { EventEmitter } from 'eventemitter3'

interface Payload {
  [key: string]: any
  [key: number]: any
}

export interface IPath {
  path: string
  payload: Payload
}

export class Path implements IPath {
  path: string
  payload: Payload
  constructor(path: string, payload: Payload)
  toJS(): IPath
}

export class Abort {
  constructor(payload: Payload)
}


export function createStaticTree(tree: Primitive | Array<Function | Primitive>): Array<Primitive>

type RunFunctionResolve = (funcDetails: Primitive, payload: Payload, prevPayload: Payload, next: any) => void
type BranchStartCallback = (funcDetails: Primitive, path: string, payload: Payload) => void
type BranchEndCallback = (payload: Payload) => void
type ParallelStartEndCallback = (payload: Payload, itemLength: number) => void
type ParallelProgressCallback = (payload: Payload, remainingLength: number) => void

export function executeTree(
  tree: Array<Primitive>,
  resolveFunctionResult: RunFunctionResolve,
  initialPayload: Payload,
  branchStart: BranchStartCallback,
  branchEnd: BranchEndCallback,
  parallelStart: ParallelStartEndCallback,
  parallelProgress: ParallelProgressCallback,
  parallelEnd: ParallelStartEndCallback,
  end: BranchEndCallback
): void

export class Primitive {
  name?: string
  "function": Function
  functionIndex: number
  items: Array<Primitive>
  type: "parallel" | "sequence"
  _functionTreePrimitive: boolean
  outputs?: { [name: string]: Primitive }
}

// deprectated, use Primitive instead
export type FunctionTreePrimitive = Primitive

export interface FunctionTreeExecutable {
}

export function sequence(items: Array<FunctionTreeExecutable>): Primitive
export function sequence(name: string, items: Array<FunctionTreeExecutable>): Primitive

export function parallel(items: Array<FunctionTreeExecutable>): Primitive
export function parallel(name: string, items: Array<FunctionTreeExecutable>): Primitive

export interface RunTreeFunction {
  (): void
  on(event: string | symbol, listener: Function): this
  once(event: string | symbol, listener: Function): this
  off(event: string | symbol, listener: Function): this
}


export interface DevtoolsOptions {
  host: string
}

export class Devtools {
  constructor(options: DevtoolsOptions)

  addListeners(): void
  init(): void
  safeStringify(object: any): string
  reInit(): void
  sendMessage(message: string): void
  watchExecution(tree: FunctionTree): void
  sendInitial(): void
  createExecutionMessage(debuggingData: any, context: any, functionDetails: Primitive, payload: Payload): string
  sendExecutionData(debuggingData: any, context: any, functionDetails: Primitive, payload: Payload): void
  Provider(): (context: any, functionDetails: Primitive, payload: Payload) => any
}


export class FunctionTreeError extends Error {
  constructor(error: any)
  toJSON(): any
}

export class FunctionTreeExecutionError extends FunctionTreeError {
  constructor(execution: any, funcDetails: any, payload: any, error: any)
  toJSON(): any
}

export type Provider = (context: any, funcDetails: Primitive, payload: Payload, next: Payload) => any

export function ReduxProvider(store: any): Provider
export function PropsProvider(): Provider
export function PathProvider(): Provider
export function ExecutionProvider(execution: any, abort: Abort): Provider
export function ContextProvider(extendedContext: any): Provider

export type contextProviders = {
  [key: string]: Provider
}

export class FunctionTree extends EventEmitter {
  constructor(contextProviders: contextProviders)
  cachedTrees: Array<Primitive>
  contextProviders: contextProviders
  runTree: RunTreeFunction

  createContext(funcDetails: Primitive, payload: Payload, prevPayload: Payload): Array<Provider>
  run(...args: any[]): Promise<any>
}

// ========= Contextual value

export interface BaseContext {
  [providerName: string]: any  
  // Keys set to 'any' type are not defined so that they
  // can be overriden in generic type.
  // execution: any
  // path: any
  // props: any
  resolve: Resolve
}

export type Context<T={}> = BaseContext & T

export abstract class ResolveValue<T=any, C={}> {
  abstract getValue(context: Context<C>): T
}

interface TagOptions {
  hasValue?: boolean
  isStateDependency?: boolean
}

export class Tag<T=any> extends ResolveValue<T> {
  constructor(
    tag: string,
    options: TagOptions,
    strings: string[],
    values: any[]
  )
  options: TagOptions
  strings: string[]
  type: string
  values: any[]
  getPath(getters: any): string
  getValue(getters: any): T
}

export interface Resolve {
  isTag(arg: any, ...types: string[]): arg is Tag
  isResolveValue(arg: any): arg is ResolveValue

  path(tag: Tag): string
  value<T>(value: Tag<T>, overrideContext?: any): T
  value<T>(value: Tag<T> | T, overrideContext?: any): T
  value<T>(value: ResolveValue<T>, overrideContext?: any): T
  value<T=any>(value: ResolveValue<T> | T, overrideContext?: any): T
}

// ========= Helpers
export function extractValueWithPath<T=any>(obj: any, path: string): T

type TagFactory<T> = (path: TemplateStringsArray | string[], ...values: any[]) => Tag<T>
export function createTemplateTag<T=any>(tagName: string, getValue: (path: string, context: BaseContext) => T): TagFactory<T>

export function resolveObject<T=any>(obj: any): ResolveValue<T>
