import { createTemplateTag, extractValueWithPath, resolveObject,
  Context, ContextProvider, ResolveValue, FunctionTree } from '../..'
import { props, string } from '../../tags'

const window = { app: {} }

const ft = new FunctionTree([
  ContextProvider({
    window,
    request: {
      get: () => { }
    }
  })
])

ft.run()

interface Extras {
  foo: { foo: string }
  props: { bong: number }
}

const myTag = createTemplateTag<number>(
  'myTag',
  (path, ctx) => extractValueWithPath(ctx.props, path)
)

class UpperCaser extends ResolveValue {
  constructor(private value: ResolveValue) {
    super ()
  }
  getValue({ resolve }: Context) {
    return resolve.value(this.value).toString().toUpperCase()
  }
}

// We have to type this function's return value for resolve.value to properly work.
function upperCase (value: ResolveValue): ResolveValue<{}, string> {
 return new UpperCaser(value)
}

function someAction({ resolve, props: theProps, foo } : Context<Extras>) {
  const test1: string = resolve.value<string>(props`bong`)
  const test2: string = resolve.value(string`pok`)
  const test3: number = resolve.value(myTag`one.two`)
  const test4: string = resolve.value(upperCase(string`foo`))
  const test6: ResolveValue<{}, number> = myTag`boo.boo`
  const test7: ResolveValue<{}, string> = string`boo.boo`
  const test8: string = resolve.value(resolveObject<{foo: string}>({ foo: string`foo` })).foo
  const test9: string = resolve.value(resolveObject({ foo: string`foo` })).foo
  const test10: string = foo.foo
  const test11: number = theProps.bong
}
