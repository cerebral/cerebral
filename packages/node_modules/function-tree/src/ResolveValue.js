export class ResolveValue {
  // "getValue" should receive a context to extract the value
  getValue() {
    throw new Error(
      'Extending ResolveValue requires you to add a "getValue" method'
    )
  }
}

let deprecationShown = false

export function convertObjectWithTemplates(obj, resolve, operatorName = '??') {
  if (resolve.isResolveValue(obj)) {
    return resolve.value(obj)
  }

  const resolvedKeys = []
  const convertedObject = Object.keys(obj).reduce((convertedObject, key) => {
    const value = obj[key]
    if (resolve.isResolveValue(value)) {
      resolvedKeys.push(key)
      convertedObject[key] = resolve.value(value)
    } else {
      convertedObject[key] = value
    }

    return convertedObject
  }, {})
  if (!deprecationShown && resolvedKeys.length) {
    deprecationShown = true
    console.warn(
      `[DEPRECATION] You are passing an object to '${operatorName}' with resolve values ('${resolvedKeys.join(
        "', '"
      )}'). Please wrap object with 'resolveObject' exported from 'function-tree' or 'cerebral/tags'.`
    )
  }
  return convertedObject
}

export function extractValueWithPath(obj, path) {
  return path.split('.').reduce((currentValue, key, index) => {
    if (index > 0 && currentValue === undefined) {
      throw new Error(
        `A tag is extracting with path "${path}", but it is not valid.`
      )
    }

    return currentValue[key]
  }, obj)
}

class ResolveObject extends ResolveValue {
  constructor(cvalue) {
    super()
    this.cvalue = cvalue
  }

  getValue({ resolve }) {
    const cvalue = this.cvalue
    if (resolve.isResolveValue(cvalue)) {
      return resolve.value(cvalue)
    }

    return Object.keys(cvalue).reduce((convertedObject, key) => {
      convertedObject[key] = resolve.value(cvalue[key])

      return convertedObject
    }, {})
  }
}

export const resolveObject = obj => new ResolveObject(obj)
