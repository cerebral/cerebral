import { parallel } from '../../';
import { debounce, wait } from '../../factories/';
export class SequenceBuilder {
    constructor(sequenceArray) {
        this.sequenceArray = sequenceArray;
    }
    action(...action) {
        const typeFirst = typeof action[0] === 'string';
        const actions = (typeFirst ? action.splice(1) : action);
        actions.forEach(element => {
            typeFirst && Object.defineProperty(element, 'name', { value: action[0] });
        });
        this.sequenceArray.push(...actions);
        return new SequenceBuilder(this.sequenceArray);
    }
    branch(action) {
        this.sequenceArray.push(action);
        return {
            paths: (paths) => {
                const outputSequence = generatePathSequence(paths);
                this.sequenceArray.push(outputSequence);
                return new SequenceBuilder(this.sequenceArray);
            },
        };
    }
    parallel(...args) {
        const cb = new SequenceBuilder([]);
        const callback = typeof args[0] === 'string' ? args[1] : args[0];
        const name = typeof args[0] === 'string' ? args[0] : '';
        const result = callback(cb);
        this.sequenceArray.push(parallel(name, result.sequenceArray));
        return new SequenceBuilder(this.sequenceArray);
    }
    sequence(seq) {
        this.sequenceArray.push(...seq);
        return new SequenceBuilder(this.sequenceArray);
    }
    when(callback) {
        function when(context) {
            return callback(context) ? context.path.true({}) : context.path.false({});
        }
        return this.branch(when);
    }
    debounce(ms) {
        return this.branch(debounce(ms));
    }
    equals(callback) {
        function equals(context) {
            const result = String(callback(context));
            return context.path[result]
                ? context.path[result]({})
                : context.path.othersise({});
        }
        return this.branch(equals);
    }
    wait(ms) {
        this.sequenceArray.push(wait(ms));
        return new ContinueSequenceBuilder(this.sequenceArray);
    }
}
export class ContinueSequenceBuilder extends SequenceBuilder {
    continue(arg) {
        const builder = new SequenceBuilder([]);
        this.sequenceArray.push({
            continue: builder.sequenceArray,
        });
        return builder;
    }
}
function generatePathSequence(paths) {
    const outputSequence = {};
    for (const key in paths) {
        const cb = new SequenceBuilder([]);
        const chain = paths[key];
        chain(cb);
        outputSequence[key] = cb.sequenceArray;
    }
    return outputSequence;
}
export function sequenceFactory(arg) {
    const builder = new SequenceBuilder([]);
    arg(builder);
    return builder.sequenceArray;
}
export function Sequence(arg) {
    return sequenceFactory(arg);
}
export function SequenceWithProps(arg) {
    return sequenceFactory(arg);
}
export function SequenceFactory() {
    function returned(arg) {
        return sequenceFactory(arg);
    }
    return returned;
}
export function SequenceWithPropsFactory() {
    function returned(arg) {
        return sequenceFactory(arg);
    }
    return returned;
}
