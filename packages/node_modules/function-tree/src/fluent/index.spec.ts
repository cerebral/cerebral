import * as assert from 'assert'
import {
  SequenceFactory,
  SequenceWithPropsFactory,
  IContext,
  IBranchContext,
} from './'

interface MyModel {
  stateData: string
}

interface ProviderContext {
  // http: HttpModule
  state: MyModel
}

type Context<TProps = {}> = IContext<TProps> & ProviderContext
type BranchContext<TPaths = {}, TProps = {}> = IBranchContext<TPaths, TProps> &
  ProviderContext

const Sequence = SequenceFactory<Context>()
const SequenceWithProps = SequenceWithPropsFactory<Context>()

interface Props {
  name: string
  age: number
}

describe('Fluent', () => {
  it('should return array', () => {
    function action1(context: Context<{}>) {}

    var seq = (Sequence((x) => x.action(action1)) as any) as Array<any>

    assert.deepEqual(seq, [action1])
  })

  it('should return paths correctly', () => {
    interface PathResult {
      newName: string
    }

    interface Paths {
      success: PathResult
      error: PathResult
    }

    function action1(context: Context<Props>) {}

    function action2(context: Context<Props>) {}

    function action3(context: BranchContext<Paths>): PathResult {
      context.state.stateData = 'Something'
      return context.path.success({ newName: 'John' })
    }

    var seq = (SequenceWithProps<Props>((x) =>
      x
        .action(action1)
        .branch(action3)
        .paths({
          success: (z) => z.action(action1, action2),
          error: (z) => z.action(action2),
        })
    ) as any) as Array<any>

    assert.deepEqual(seq, [
      action1,
      action3,
      {
        success: [action1, action2],
        error: [action2],
      },
    ])
  })
  describe('inference', () => {
    it('should infer props on next inline action', () => {
      function action1(context: Context) {
        return {
          foo: 'bar',
        }
      }

      Sequence((s) =>
        s.action(action1).action(function action2({ props }) {
          props.foo = 'bar2'
        })
      )
    })
    it('should infer props on next action with required props', () => {
      function action1(context: Context) {
        return {
          foo: 'bar',
        }
      }

      function action2(context: Context<{ foo: string }>) {
        context.props.foo = 'bar2'
      }

      Sequence((s) => s.action(action1).action(action2))
    })
    it('should infer promise props on actions', () => {
      function action1(context: Context) {
        return Promise.resolve({
          foo: 'bar',
        })
      }

      function action2(context: Context<{ foo: string }>) {
        context.props.foo = 'bar2'
      }

      Sequence((s) => s.action(action1).action(action2))
    })
    it('should infer props on paths', () => {
      function action1(
        context: BranchContext<{
          pathA: { foo: string }
          pathB: { bar: number }
        }>
      ) {
        if (Math.random()) {
          return context.path.pathA({ foo: 'bar' })
        }

        return context.path.pathB({ bar: 123 })
      }

      Sequence((s) =>
        s.branch(action1).paths({
          pathA: (s) =>
            s.action(function action2({ props }) {
              props.foo = 'bar'
            }),
          pathB: (s) =>
            s.action(function action3({ props }) {
              props.bar.toFixed()
            }),
        })
      )
    })
    it('should infer promise props on paths', () => {
      function action1(
        context: BranchContext<{
          pathA: { foo: string }
          pathB: { bar: number }
        }>
      ) {
        return Promise.resolve()
          .then(() => {
            return context.path.pathA({ foo: 'bar' })
          })
          .catch(() => {
            return context.path.pathB({ bar: 123 })
          })
      }

      Sequence((s) =>
        s.branch(action1).paths({
          pathA: (s) =>
            s.action(function action2({ props }) {
              props.foo = 'bar'
            }),
          pathB: (s) =>
            s.action(function action3({ props }) {
              props.bar.toFixed()
            }),
        })
      )
    })
    it('should infer sequence composition', () => {
      var seqA = SequenceWithProps<{ foo: string }, { bar: number }>((s) =>
        s.action(function action1({ props }) {
          props.foo = 'bar2'

          return {
            bar: 123,
          }
        })
      )

      Sequence((s) =>
        s
          .action(function action2() {
            return {
              foo: 'bar',
            }
          })
          .sequence(seqA)
          .action(function action3({ props }) {
            props.bar.toFixed()
          })
      )
    })
  })
})
