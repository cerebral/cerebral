import { parallel, Primitive } from '../../'
import { debounce, wait } from '../../factories/'

export interface IContext<TProps> {
  props: TProps
}

export interface IBranchContext<TPaths, TProps> extends IContext<TProps> {
  path: { [key in keyof TPaths]: (props: TPaths[key]) => TPaths[key] }
}

export class SequenceBuilder<TContext = {}, TProps = {}> {
  protected sequenceArray: any[]

  constructor(sequenceArray: any[]) {
    this.sequenceArray = sequenceArray
  }

  public action<TOutput>(
    ...action: Array<
      (input: TContext & IContext<TProps>) => TOutput | Promise<TOutput>
    >
  ): SequenceBuilder<TContext, TProps & TOutput>

  public action<TOutput>(
    name: string,
    ...action: Array<
      (input: TContext & IContext<TProps>) => TOutput | Promise<TOutput>
    >
  ): SequenceBuilder<TContext, TProps & TOutput>

  public action<TOutput>(
    ...action: any[]
  ): SequenceBuilder<TContext, TProps & TOutput> {
    const typeFirst = typeof action[0] === 'string'
    const actions = (typeFirst ? action.splice(1) : action) as any[]
    actions.forEach((element) => {
      typeFirst && Object.defineProperty(element, 'name', { value: action[0] })
    })
    this.sequenceArray.push(...actions)
    return new SequenceBuilder<TContext, TProps & TOutput>(this.sequenceArray)
  }

  public branch<TPaths, TOutput = {}>(
    action: (
      input: TContext & IBranchContext<TPaths, TProps>
    ) => TOutput | Promise<TOutput>
  ): {
    paths: (
      paths: {
        [key in keyof TPaths]: (
          input: SequenceBuilder<TContext, TProps & TPaths[key]>
        ) => SequenceBuilder<TContext, TProps & TPaths[key]>
      }
    ) => SequenceBuilder<TContext, TProps & TOutput>
  }

  public branch<TPaths, TOutput = {}>(
    action: any
  ): {
    paths: (
      paths: {
        [key in keyof TPaths]: (
          input: SequenceBuilder<TContext, TProps & TPaths[key]>
        ) => SequenceBuilder<TContext, TProps & TPaths[key]>
      }
    ) => SequenceBuilder<TContext, TProps & TOutput>
  } {
    this.sequenceArray.push(action)

    return {
      paths: (
        paths: {
          [key in keyof TPaths]: (
            input: SequenceBuilder<TContext, TProps & TPaths[key]>
          ) => SequenceBuilder<TContext, TProps & TPaths[key]>
        }
      ): SequenceBuilder<TContext, TProps & TOutput> => {
        const outputSequence = generatePathSequence<TPaths, TContext, TProps>(
          paths
        )
        this.sequenceArray.push(outputSequence)
        return new SequenceBuilder<TContext, TProps & TOutput>(
          this.sequenceArray
        )
      },
    }
  }

  public parallel<TOutput>(
    name: string,
    chain: (
      input: SequenceBuilder<TContext, TProps>
    ) => SequenceBuilder<TContext, TOutput>
  ): SequenceBuilder<TContext, TProps & TOutput>

  public parallel<TOutput>(
    chain: (
      input: SequenceBuilder<TContext, TProps>
    ) => SequenceBuilder<TContext, TOutput>
  ): SequenceBuilder<TContext, TProps & TOutput>

  public parallel<TOutput>(
    ...args: any[]
  ): SequenceBuilder<TContext, TProps & TOutput> {
    const result = typeof args[0] === 'string' ? args[1] : args[0]
    const name = typeof args[0] === 'string' ? args[0] : ''
    this.sequenceArray.push(parallel(name, result))
    return new SequenceBuilder<TContext, TProps & TOutput>(this.sequenceArray)
  }

  public sequence<TOutput = void>(
    seq: (input: TProps) => TOutput | (() => TOutput)
  ): SequenceBuilder<TContext, TProps & TOutput> {
    this.sequenceArray.push(...(seq as any))
    return new SequenceBuilder<TContext, TProps & TOutput>(this.sequenceArray)
  }

  public when<TPaths extends { true: {}; false: {} }>(
    callback: (input: TContext & IBranchContext<TPaths, TProps>) => boolean
  ): {
    paths: (
      paths: {
        [key in keyof TPaths]: (
          input: SequenceBuilder<TContext, TProps & TPaths[key]>
        ) => SequenceBuilder<TContext, TProps & TPaths[key]>
      }
    ) => SequenceBuilder<TContext, TProps>
  } {
    function when(context: TContext & IBranchContext<TPaths, TProps>) {
      return callback(context) ? context.path.true({}) : context.path.false({})
    }
    return this.branch(when)
  }

  public debounce<TPaths extends { continue: {}; discard: {} }>(
    ms: number
  ): {
    paths: (
      paths: {
        [key in keyof TPaths]: (
          input: SequenceBuilder<TContext, TProps & TPaths[key]>
        ) => SequenceBuilder<TContext, TProps & TPaths[key]>
      }
    ) => SequenceBuilder<TContext, TProps>
  } {
    return this.branch<{}, TPaths>(debounce(ms) as any)
  }

  public equals<TPaths extends { [key: string]: {}; otherwise: {} }, TValue>(
    callback: (input: TContext & IBranchContext<TPaths, TProps>) => TValue
  ) {
    function equals(context: TContext & IBranchContext<TPaths, TProps>) {
      const result = String(callback(context))
      return context.path[result]
        ? context.path[result]({} as any)
        : context.path.otherwise({})
    }
    return this.branch<TPaths>(equals)
  }

  public wait(ms: number) {
    this.sequenceArray.push(wait(ms))
    return new ContinueSequenceBuilder<TContext, TProps>(this.sequenceArray)
  }
}

export class ContinueSequenceBuilder<
  TContext = {},
  TProps = {}
> extends SequenceBuilder<TContext, TProps> {
  public continue() {
    const builder = new SequenceBuilder<TContext, TProps>([])
    this.sequenceArray.push({
      continue: (builder as any).sequenceArray,
    })
    return builder
  }
}

function generatePathSequence<TPaths, TContext = {}, TProps = {}>(
  paths: {
    [key in keyof TPaths]: (
      input: SequenceBuilder<TContext, TProps & TPaths[key]>
    ) => SequenceBuilder<TContext, TProps & TPaths[key]>
  }
) {
  const outputSequence: { [key in keyof TPaths]?: any[] } = {}
  for (const key in paths) {
    const cb = new SequenceBuilder<TContext, TProps>([])
    const chain = paths[key]
    chain(cb as any)
    outputSequence[key] = (cb as any).sequenceArray
  }
  return outputSequence
}

export function sequenceFactory<TContext, TProps>(
  arg: (
    input: SequenceBuilder<TContext, TProps>
  ) => SequenceBuilder<TContext, TProps>
): Primitive {
  const builder = new SequenceBuilder<TContext, TProps>([])
  arg(builder)
  return (builder as any).sequenceArray
}

export function Sequence<Context, Output = {}>(
  arg: (props: SequenceBuilder<Context, {}>) => SequenceBuilder<Context, Output>
): () => Output {
  return sequenceFactory<Context, {}>(arg as any) as any
}

export function SequenceWithProps<Context, Props, Output = Props>(
  arg: (
    props: SequenceBuilder<Context, Props>
  ) => SequenceBuilder<Context, Output>
): (props: Props) => Output {
  return sequenceFactory<Context, Props>(arg as any) as any
}

export function SequenceFactory<Context>() {
  function returned<Output = {}>(
    arg: (
      props: SequenceBuilder<Context, {}>
    ) => SequenceBuilder<Context, Output>
  ): () => Output {
    return sequenceFactory<Context, {}>(arg as any) as any
  }
  return returned
}

export function SequenceWithPropsFactory<Context>() {
  function returned<Props, Output = Props>(
    arg: (
      props: SequenceBuilder<Context, Props>
    ) => SequenceBuilder<Context, Output>
  ): (props: Props) => Output {
    return sequenceFactory<Context, Props>(arg as any) as any
  }
  return returned
}
