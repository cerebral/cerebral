/* eslint-env mocha */
// @ts-ignore: stupid module
import * as assert from 'assert';
import { SequenceFactory, SequenceWithPropsFactory, } from './';
const Sequence = SequenceFactory();
const SequenceWithProps = SequenceWithPropsFactory();
describe('Fluent', () => {
    it('should return array', () => {
        function action1(context) { }
        var seq = Sequence(x => x.action(action1));
        assert.deepEqual(seq, [action1]);
    });
    it('should return paths correctly', () => {
        function action1(context) { }
        function action2(context) { }
        function action3(context) {
            context.state.stateData = 'Something';
            return context.path.success({ newName: 'John' });
        }
        var seq = SequenceWithProps(x => x
            .action(action1)
            .branch(action3)
            .paths({
            success: z => z.action(action1, action2),
            error: z => z.action(action2),
        }));
        assert.deepEqual(seq, [
            action1,
            action3,
            {
                success: [action1, action2],
                error: [action2],
            },
        ]);
    });
    describe('inference', () => {
        it('should infer props on next inline action', () => {
            function action1(context) {
                return {
                    foo: 'bar',
                };
            }
            Sequence(s => s.action(action1).action(function action2({ props }) {
                props.foo = 'bar2';
            }));
        });
        it('should infer props on next action with required props', () => {
            function action1(context) {
                return {
                    foo: 'bar',
                };
            }
            function action2(context) {
                context.props.foo = 'bar2';
            }
            Sequence(s => s.action(action1).action(action2));
        });
        it('should infer promise props on actions', () => {
            function action1(context) {
                return Promise.resolve({
                    foo: 'bar',
                });
            }
            function action2(context) {
                context.props.foo = 'bar2';
            }
            Sequence(s => s.action(action1).action(action2));
        });
        it('should infer props on paths', () => {
            function action1(context) {
                if (Math.random()) {
                    return context.path.pathA({ foo: 'bar' });
                }
                return context.path.pathB({ bar: 123 });
            }
            Sequence(s => s.branch(action1).paths({
                pathA: s => s.action(function action2({ props }) {
                    props.foo = 'bar';
                }),
                pathB: s => s.action(function action3({ props }) {
                    props.bar.toFixed();
                }),
            }));
        });
        it('should infer promise props on paths', () => {
            function action1(context) {
                return Promise.resolve()
                    .then(() => {
                    return context.path.pathA({ foo: 'bar' });
                })
                    .catch(() => {
                    return context.path.pathB({ bar: 123 });
                });
            }
            Sequence(s => s.branch(action1).paths({
                pathA: s => s.action(function action2({ props }) {
                    props.foo = 'bar';
                }),
                pathB: s => s.action(function action3({ props }) {
                    props.bar.toFixed();
                }),
            }));
        });
        it('should infer sequence composition', () => {
            var seqA = SequenceWithProps(s => s.action(function action1({ props }) {
                props.foo = 'bar2';
                return {
                    bar: 123,
                };
            }));
            Sequence(s => s
                .action(function action2() {
                return {
                    foo: 'bar',
                };
            })
                .sequence(seqA)
                .action(function action3({ props }) {
                props.bar.toFixed();
            }));
        });
    });
});
