/* eslint-env mocha */
import Vue from 'vue/dist/vue'
import assert from 'assert'
import { state, sequences, props } from 'cerebral/tags'
import { Controller, Module } from 'cerebral'
import { Container, connect } from './'

describe('Vuejs', () => {
  describe('Container', () => {
    it('should be able to expose controller', () => {
      const controller = Controller(
        Module({
          state: {
            foo: 'bar',
          },
        })
      )
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          template: `<div>{{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.strictEqual(myComponent.$el.innerHTML, 'bar')
      assert.strictEqual(myComponent.foo, 'bar')
    })
    it('should throw when no controller provided', () => {
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          template: `<div>{{foo}}</div>`,
        }
      )
      assert.throws(
        () => {
          new Vue({
            template: `<container>
                  <my-component></my-component>
                </container>`,
            components: {
              container: Container(),
              'my-component': TestComponent,
            },
          }).$mount()
        },
        (err) => {
          if (err instanceof Error) {
            return (
              err.message ===
              'Cerebral - You are not passing controller to Container'
            )
          }
        }
      )
    })
  })
  describe('connect', () => {
    it('should be able to register component into dependencyStore before vm mounting', (done) => {
      const controller = Controller(
        Module({
          state: {
            foo: 'bar',
          },
        })
      )
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          name: 'Test',
          template: `<div>{{foo}}</div>`,
          beforeMount: function() {
            assert.strictEqual(this._isMounted, false)
          },
          mounted: function() {
            const components = controller.dependencyStore.getAllUniqueEntities()
            assert.strictEqual(components.length, 1)
            assert.strictEqual(components[0]._displayName, 'Test')
            assert.strictEqual(this._isMounted, true)
            done()
          },
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.strictEqual(myComponent.$el.innerHTML, 'bar')
    })
    it('should be able to extract sequences', () => {
      const controller = Controller(
        Module({
          state: {
            foo: 'bar',
          },
          sequences: {
            someSequence: [],
          },
        })
      )
      const TestComponent = connect(
        {
          foo: state`foo`,
          sequence: sequences`someSequence`,
        },
        {
          template: `<div>{{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.strictEqual(myComponent.$el.innerHTML, 'bar')
      assert.strictEqual(myComponent.foo, 'bar')
      assert.ok(typeof myComponent.sequence === 'function')
    })
    it('should rerender on state update', (done) => {
      const controller = Controller(
        Module({
          state: {
            foo: 'bar',
          },
          sequences: {
            methodCalled: [({ state }) => state.set('foo', 'bar2')],
          },
        })
      )
      const TestComponent = connect(
        {
          foo: state`foo`,
          methodCalled: sequences`methodCalled`,
        },
        {
          methods: {
            callSequence: function() {
              this.methodCalled()
            },
          },
          template: `<div>{{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.strictEqual(myComponent.$el.innerHTML, 'bar')
      assert.strictEqual(myComponent.foo, 'bar')
      myComponent.callSequence()
      Vue.nextTick(() => {
        assert.strictEqual(myComponent.$el.innerHTML, 'bar2')
        assert.strictEqual(myComponent.foo, 'bar2')
        done()
      })
    })
    it('should be able to work with vue props', () => {
      const controller = Controller(
        Module({
          state: {
            foo: 'bar',
          },
        })
      )
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          props: ['message'],
          template: `<div>{{message}} {{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component message='hello'></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.strictEqual(myComponent.$el.innerHTML, 'hello bar')
      assert.strictEqual(myComponent.foo, 'bar')
      assert.strictEqual(myComponent.$props.message, 'hello')
      assert.strictEqual(myComponent.message, 'hello')
    })
    it('should be able to work with props tag and computed', () => {
      const controller = Controller(
        Module({
          state: {
            foo: {
              baz: 'mip',
            },
            aComputed: (get) => get(props`foo`),
          },
        })
      )
      const TestComponent = connect(
        {
          a: state`aComputed`,
          b: props`bar.id`,
          c: state`foo.${props`propKey`}`,
        },
        {
          props: ['foo', 'bar', 'propKey'],
          template: `<div>{{a + b + c}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component foo="bar" :bar="{ id: '1' }" propKey="baz"></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.strictEqual(myComponent.$el.innerHTML, 'bar1mip')
      assert.strictEqual(myComponent.a, 'bar')
      assert.strictEqual(myComponent.$props.foo, 'bar')
      assert.strictEqual(myComponent.b, '1')
      assert.strictDeepEqual(myComponent.$props.bar, { id: '1' })
      assert.strictEqual(myComponent.c, 'mip')
      assert.strictEqual(myComponent.$props.propKey, 'baz')
    })
    it('should be able to watch vue props', (done) => {
      const controller = Controller(
        Module({
          state: {
            foo: 'bar',
          },
          sequences: {
            methodCalled: [({ state }) => state.set('foo', 'bar2')],
          },
        })
      )
      const TestComponentChild = connect(
        {
          foo: state`foo`,
        },
        {
          props: ['message'],
          template: `<div>{{message}}</div>`,
        }
      )
      const TestComponent = {
        data() {
          return { foo: 'bar' }
        },
        methods: {
          callSequence: function() {
            this.foo = 'bar2'
          },
        },
        template: `<child v-bind:message="foo"></child>`,
        components: {
          child: TestComponentChild,
        },
      }
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.strictEqual(myComponent.$el.innerHTML, 'bar')
      assert.strictEqual(myComponent.foo, 'bar')
      myComponent.callSequence()
      Vue.nextTick(() => {
        assert.strictEqual(myComponent.$el.innerHTML, 'bar2')
        assert.strictEqual(myComponent.foo, 'bar2')
        done()
      })
    })
    it('should be able to work with other provider', () => {
      const BarProvider = {
        provide: {
          bar: 'baz',
        },
        template: `<div><slot></slot></div>`,
      }
      const controller = Controller(
        Module({
          state: {
            foo: 'bar',
          },
          sequences: {
            someSequence: [],
          },
        })
      )
      const TestComponent = connect(
        {
          foo: state`foo`,
          sequence: sequences`someSequence`,
        },
        {
          inject: ['bar'],
          template: `<div>{{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<bar-provider>
                    <container>
                      <my-component></my-component>
                    </container>
                  </bar-provider>`,
        components: {
          container: Container(controller),
          'bar-provider': BarProvider,
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0].$children[0]
      assert.strictEqual(myComponent.$el.innerHTML, 'bar')
      assert.strictEqual(myComponent.foo, 'bar')
      assert.strictEqual(myComponent.bar, 'baz')
      assert.ok(typeof myComponent.sequence === 'function')
    })
    it('should be able to unregister component from dependencyStore before destroying vm', (done) => {
      const controller = Controller(
        Module({
          state: {
            foo: 'bar',
          },
        })
      )
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          template: `<div>{{foo}}</div>`,
          beforeDestroy: function() {
            assert.strictEqual(this._isBeingDestroyed, false)
            assert.strictEqual(this._isDestroyed, false)
          },
          destroyed: function() {
            assert.strictDeepEqual(
              controller.dependencyStore.getAllUniqueEntities(),
              []
            )
            assert.strictEqual(this._isBeingDestroyed, true)
            assert.strictEqual(this._isDestroyed, true)
            done()
          },
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()

      vm.$destroy()
    })
  })
})
