import {
  computed as mobxComputed,
  IComputedValue,
  observable,
  untracked,
  transaction,
  extras,
  ObservableMap as MobxObservableMap,
  useStrict,
} from 'mobx'
import { CreateModuleProvider } from './providers'
import {
  BaseControllerClass,
  ModuleClass,
  InstantiatedModuleObjectDefinition,
  ControllerOptions,
} from 'cerebral'
import { extractModuleProp, getModule, throwError } from 'cerebral/internal'
import { updateIn } from './utils'
import Model from './Model'
import Hoc from './Hoc'
import { SequenceBuilder } from 'function-tree/fluent'

export { ConnectFactory } from './connect'
export { pathFor } from './paths'

export {
  SequenceFactory,
  SequenceWithPropsFactory,
  IContext,
  IBranchContext,
} from 'function-tree/fluent'

export { ComputedValue, Computed } from './Computed'

export { default as Container } from './Container'

export type Dictionary<Type> = MobxObservableMap<Type>
export function Dictionary<Type>(values: {
  [key: string]: Type
}): MobxObservableMap<Type> {
  return new MobxObservableMap(values)
}

// mobx uses extra fields in modules and therefore needs to declare it's own `Module` constructor.
export { Module, Provider, CerebralError } from 'cerebral'

export type TLegacyState = {
  set(path: string, value: any): void
  get(path: string): any
  toggle(path: string): void
  push(path: string, value: any): void
  merge(path: string, value: {}): void
  pop(path: string): void
  shift(path: string): void
  unshift(path: string, value: any): void
  splice(path: string, index: number, length: number): void
  concat(path: string, value: any[]): void
  increment(path: string, delta: number): void
  unset(path: string): void
}

export class FluentController<
  State = {},
  Signals = {}
> extends BaseControllerClass {
  state: State
  signals: Signals
  devtools: any
  contextProviders: any
  constructor(
    rootModule: ModuleClass,
    options: ControllerOptions & {
      useStrict?: boolean
      useLegacyStateApi?: boolean
    }
  ) {
    super(rootModule, options, {
      executeBranchWrapper: (cb: () => void) => {
        extras.allowStateChanges(true, () => untracked(() => transaction(cb)))
      },
    })
    useStrict(
      typeof options.useStrict === 'undefined' ? true : options.useStrict
    )
    this.state = this.model.state
    this.signals = extractModuleProp(
      this.module,
      'signals',
      (signals: any, module: any) => {
        return Object.keys(signals).reduce(
          (runableSignals: any, key: string) => {
            if ('run' in signals[key]) {
              runableSignals[key] = signals[key].run
            } else {
              runableSignals[key] = signals[key]
            }

            return runableSignals
          },
          {}
        )
      }
    )
    this.contextProviders.module = CreateModuleProvider(
      this.model.state,
      this.devtools,
      this.model,
      options.useLegacyStateApi || false
    )
  }
  addModule(path: string, module: ModuleClass) {
    const pathArray = path.split('.')
    const moduleKey = pathArray.pop()
    if (!moduleKey) {
      return throwError('Can not find module path to add module')
    }
    const parentModule = getModule(pathArray, this.module)
    const newModule = module.create(this, pathArray.concat(moduleKey))

    if (!parentModule.modules || !parentModule.modules[moduleKey]) {
      return throwError('Can not find module path to add module')
    }

    parentModule.modules[moduleKey] = newModule

    if (newModule.providers) {
      Object.assign(this.contextProviders, newModule.providers)
    }

    updateIn(
      this.state,
      pathArray.concat(moduleKey),
      (parentState: { [key: string]: any }, key: string) => {
        parentState[key] = observable(newModule.state)
      }
    )
    updateIn(
      this.signals,
      pathArray.concat(moduleKey),
      (parentState: { [key: string]: any }, key: string) => {
        parentState[key] = Object.keys(newModule.signals).reduce(
          (signals: any, key: string) => {
            signals[key] = newModule.signals[key]

            return signals
          },
          {}
        )
      }
    )

    this.emit('moduleAdded', path.split('.'), newModule)
  }
  removeModule(path: string) {
    if (!path) {
      console.warn('Controller.removeModule requires a Module Path')
      return null
    }

    const pathArray = path.split('.')
    const moduleKey = pathArray.pop()
    const parentModule = getModule(pathArray, this.module)

    if (!moduleKey || !parentModule || !parentModule.modules) {
      return throwError('Module you are trying to remove does not exist')
    }

    const module = parentModule.modules[moduleKey]

    if (module.providers) {
      Object.keys(module.providers).forEach(provider => {
        delete this.contextProviders[provider]
      })
    }

    delete parentModule.modules[moduleKey]
    updateIn(
      this.state,
      pathArray.concat(moduleKey),
      (parentState: { [key: string]: any }) => {
        delete parentState[moduleKey]
      }
    )
    updateIn(
      this.signals,
      pathArray.concat(moduleKey),
      (parentSignals: any) => {
        delete parentSignals[moduleKey]
      }
    )

    this.emit('moduleRemoved', path, module)
  }
}

export function Controller<State = {}, Signals = {}>(
  rootModule: ModuleClass,
  options: ControllerOptions & {
    useStrict?: boolean
    useLegacyStateApi?: boolean
  } = {}
) {
  options.Model = Model
  options.Model.useLegacyStateApi = options.useLegacyStateApi

  return new FluentController<State, Signals>(rootModule, options)
}
