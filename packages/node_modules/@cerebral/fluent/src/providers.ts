import { Provider } from 'cerebral'
import { Provider as FunctionTreeProvider } from 'function-tree'
import { isObservable, isObservableMap } from 'mobx'
import { ComputedClass } from './Computed'

const mutationMethods: PropertyKey[] = [
  'concat',
  'pop',
  'push',
  'shift',
  'splice',
  'unshift',
]

function cleanPath(
  state: any,
  key: PropertyKey | null,
  path: PropertyKey[]
): PropertyKey[] {
  const pathCopy = key ? path.concat(key) : path.slice()
  let isValid = false
  while (!isValid) {
    const value = pathCopy.reduce((currentState, pathKey) => {
      if (currentState === undefined) {
        return
      }
      if (isObservableMap(currentState)) {
        return currentState.get(pathKey.toString())
      }

      if (typeof currentState === 'object' && pathKey in currentState) {
        return currentState[pathKey]
      }
    }, state)

    if (value === undefined) {
      pathCopy.splice(pathCopy.length - 2, 1)
    } else {
      isValid = true
    }
  }

  return pathCopy
}

function createValidator(
  state: any,
  execution: any,
  functionDetails: any,
  props: any,
  devtools: any,
  basePath: PropertyKey[] = []
) {
  let path: PropertyKey[] = basePath

  const validator = {
    get(target: any, key: PropertyKey): any {
      if (key === '$mobx') {
        return target[key]
      }

      if (isObservableMap(target)) {
        switch (key) {
          case 'size':
            path = cleanPath(state, null, path)
            return target[key]
          case 'forEach':
            return (cb: any) => {
              return target.keys().forEach((forEachKey, ...args: any[]) => {
                path = cleanPath(state, forEachKey, path)
                cb(new Proxy(target.get(forEachKey), validator), ...args)
              })
            }
          case 'entries': {
            const originalFunc = target[key]

            return (...args: any[]) => {
              const value = originalFunc.apply(target, args)
              path = cleanPath(state, null, path)
              return value
            }
          }
          case 'get': {
            const originalFunc = target[key]
            return (mapKey: string) => {
              path = cleanPath(state, mapKey, path)
              const value = originalFunc.call(target, mapKey)

              return value !== null && typeof value === 'object'
                ? new Proxy(value, validator)
                : value
            }
          }
          case 'delete': {
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData(
                {
                  type: 'mutation',
                  method: basePath.length ? 'module.unset' : 'unset',
                  args: [basePath.concat(path).concat(args[0])],
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, args[0], path)
              return originalFunction.apply(target, args)
            }
          }
          case 'clear': {
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData(
                {
                  type: 'mutation',
                  method: basePath.length ? 'module.set' : 'set',
                  args: [basePath.concat(path), {}],
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, null, path)
              return originalFunction.apply(target, args)
            }
          }
          case 'merge': {
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData(
                {
                  type: 'mutation',
                  method: basePath.length ? 'module.merge' : 'merge',
                  args: [basePath.concat(path), args[0]],
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, null, path)
              return originalFunction.apply(target, args)
            }
          }
          case 'replace':
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData(
                {
                  type: 'mutation',
                  method: basePath.length ? 'module.set' : 'set',
                  args: [basePath.concat(path), args[0]],
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, null, path)
              return originalFunction.apply(target, args)
            }
          case 'set': {
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData(
                {
                  type: 'mutation',
                  method: basePath.length ? 'module.set' : 'set',
                  args: [basePath.concat(path).concat(args[0]), args[1]],
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, null, path)
              return originalFunction.apply(target, args)
            }
          }
          default:
            return (target as any)[key]
        }
      } else if (target[key] instanceof ComputedClass) {
        return target[key]
      } else if (typeof target[key] === 'object' && target[key] !== null) {
        path = cleanPath(state, key, path)
        return new Proxy(target[key], validator)
      } else {
        if (
          typeof target[key] === 'function' &&
          mutationMethods.indexOf(key) >= 0
        ) {
          const originalFunction = target[key]
          return (...args: any[]) => {
            devtools.sendExecutionData(
              {
                type: 'mutation',
                method: basePath.length ? 'module.' + String(key) : key,
                args: [basePath.concat(path), ...args],
              },
              execution,
              functionDetails,
              props
            )
            path = cleanPath(state, key, path)
            return originalFunction.apply(target, args)
          }
        }
        return target[key]
      }
    },
    set(target: any, key: PropertyKey, value: any) {
      path = cleanPath(state, key, path)
      devtools.sendExecutionData(
        {
          type: 'mutation',
          method: basePath.length ? 'module.set' : 'set',
          args: [
            basePath.concat(path),
            isObservable(value) ? value.value : value,
          ],
        },
        execution,
        functionDetails,
        props
      )

      Reflect.set(target, key, value)

      return true
    },
  }

  return validator
}

const legacyApi = [
  'get',
  'set',
  'toggle',
  'push',
  'merge',
  'pop',
  'shift',
  'unshift',
  'splice',
  'concat',
  'increment',
  'unset',
]

export function CreateStateProvider(
  state: any,
  devtools: any,
  model: any,
  useLegacyStateApi: boolean
): FunctionTreeProvider {
  if (!devtools && useLegacyStateApi) {
    legacyApi.forEach((method) => {
      Object.defineProperty(state, method, {
        value(path: string, ...args: any[]) {
          return model[method](path.split('.'), ...args)
        },
      })
    })
  }

  return Provider(state, {
    wrap: devtools
      ? (context: any) => {
          if (useLegacyStateApi) {
            legacyApi.forEach((method) => {
              Object.defineProperty(state, method, {
                writable: true,
                value(path: string, ...args: any[]) {
                  if (method !== 'get') {
                    devtools.sendExecutionData(
                      {
                        type: 'mutation',
                        method,
                        args: [path.split('.')].concat(
                          args.map(
                            (value) =>
                              isObservable(value) ? value.value : value
                          )
                        ),
                      },
                      context.execution,
                      context.functionDetails,
                      context.props
                    )
                  }
                  return model[method](path.split('.'), ...args)
                },
              })
            })
          }
          return new Proxy(
            state,
            createValidator(
              state,
              context.execution,
              context.functionDetails,
              context.props,
              devtools
            )
          )
        }
      : false,
    ignoreDefinition: true,
  })
}

export function CreateModuleProvider(
  state: any,
  devtools: any,
  model: any,
  useLegacyStateApi: boolean
): FunctionTreeProvider {
  return Provider((context: any) => {
    const signalPath = context.execution.name.split('.')
    const modulePath = signalPath.splice(0, signalPath.length - 1)
    const module = modulePath.reduce((currentModule: any, key: string) => {
      return currentModule[key]
    }, context.state)

    if (devtools && useLegacyStateApi) {
      legacyApi.forEach((method) => {
        Object.defineProperty(module, method, {
          writable: true,
          value(path: string, ...args: any[]) {
            if (method !== 'get') {
              devtools.sendExecutionData(
                {
                  type: 'mutation',
                  method: 'module.' + method,
                  args: [modulePath.concat(path.split('.'))].concat(
                    args.map(
                      (value) => (isObservable(value) ? value.value : value)
                    )
                  ),
                },
                context.execution,
                context.functionDetails,
                context.props
              )
            }
            return model[method](path.split('.'), ...args)
          },
        })
      })
    }

    if (devtools) {
      return new Proxy(
        module,
        createValidator(
          module,
          context.execution,
          context.functionDetails,
          context.props,
          devtools,
          modulePath
        )
      )
    }

    if (!devtools && useLegacyStateApi) {
      legacyApi.forEach((method) => {
        Object.defineProperty(module, method, {
          writable: true,
          value(this: any, path: string, ...args: any[]) {
            const signalPath = this.context.execution.name.split('.')
            const modulePath = signalPath.splice(0, signalPath.length - 1)

            return model[method](modulePath.concat(path.split('.')), ...args)
          },
        })
      })
    }

    return module
  })
}
