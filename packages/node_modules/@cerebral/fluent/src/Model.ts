import { extractModuleProp, isObject, throwError, BaseModel } from 'cerebral/internal';
import { BaseControllerClass } from 'cerebral';
import {
    observable,
    isObservable,
    isObservableMap,
    isComputed,
    extendObservable,
    ObservableMap,
    useStrict,
    computed
} from 'mobx';
import { ComputedClass } from './Computed';
import { updateIn, traverse } from './utils';
import { CreateStateProvider } from './providers'

class Model extends BaseModel {
    static useLegacyStateApi: boolean = false;
    constructor(controller: BaseControllerClass) {
        super(controller);
        this.state = extractModuleProp(controller.module, 'state', (state: any, module: any) => {
            return this.observeState(state);
        });
        this.StateProvider = (devtools: any) =>
            CreateStateProvider(this.state, devtools, this, Model.useLegacyStateApi);
    }
    // Used by initial state changed
    set(path: string[], value: any) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            if (isObservableMap(parentState)) {
                parentState.set(key, value);
            } else {
                parentState[key] = value;
            }
        });
    }
    toggle(path: string[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key] = !parentState[key];
        });
    }
    push(path: string[], value: any) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].push(value);
        });
    }
    merge(path: string[], mergeValue: {}, ...values: {}[]) {
        const value: {} = Object.assign(mergeValue, ...values);
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            if (isObservableMap(parentState[key])) {
                parentState[key].merge(value);
            } else {
                Object.assign(parentState[key], value);
            }
        });
    }
    pop(path: string[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].pop();
        });
    }
    shift(path: string[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].shift();
        });
    }
    unshift(path: string[], value: any) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].unshift(value);
        });
    }
    splice(path: string[], ...args: any[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].splice(...args);
        });
    }
    unset(path: string[]) {
        const deleteKey = path.pop();
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].delete(deleteKey);
        });
    }
    concat(path: string[], value: any[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key] = parentState[key].concat(value);
        });
    }
    increment(path: string[], delta = 1) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key] += delta;
        });
    }
    get(path: string[]) {
        if (!path) {
            return this.state;
        }

        return path.reduce((currentState, key) => {
            if (currentState === undefined) {
                return currentState;
            }

            if (currentState instanceof ObservableMap) {
                return currentState.get(key);
            }

            return currentState[key];
        }, this.state);
    }
    observeState(state: {}) {
        const root: { [key: string]: any } = observable({});
        const extension: {
            [key: string]: any;
        } = traverse(state, (parent: { [key: string]: any }, key: string, path: string[]) => {
            if (isObservable(parent[key])) {
                return parent[key];
            } else if (isObject(parent[key])) {
                return observable(parent[key]);
            }

            return parent[key];
        });

        const extended = extendObservable(
            root,
            Object.keys(extension).reduce((root: { [key: string]: any }, key: string) => {
                const propertyDescriptor = Object.getOwnPropertyDescriptor(extension, key);
                if (propertyDescriptor && 'get' in propertyDescriptor) {
                    Object.defineProperty(root, key, propertyDescriptor);
                } else if (extension[key] instanceof ComputedClass) {
                    extension[key].getState = () => ({ state: extended, root: this.state });

                    root[key] = extension[key];
                } else if (isObservable(extension[key])) {
                    root[key] = observable.ref(extension[key]);
                } else {
                    root[key] = extension[key];
                }

                return root;
            }, {})
        );

        return extended;
    }
}

export default Model;
