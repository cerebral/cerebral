import Hoc, { Component } from './Hoc'
import { CerebralError } from 'cerebral';

export default function connect<Props, State, Signals, EP>(
  dependencies: (
    connect: { props: Props; state: State; signals: Signals }
  ) => EP,
  passedComponent: Component<Props & EP>
): Component<Props> {
  return Hoc<Props & EP>(dependencies, passedComponent)
}

export type ModuleConnector<TState, TSignals> = {
  module: {
    state: TState,
    signals: TSignals
  }
}

export type Connector<TProps, TState, TSignals> = {
  state: TState,
  props: TProps,
  signals: TSignals
}

export function ConnectFactory<TState, TSignals>() {
  function returned<TProps>() {
    return {
      with: function <EP>(connector: (connect: Connector<TProps, TState, TSignals>) => EP) {
        return {
          to: function (passedComponent: Component<TProps & EP>): Component<TProps> {
            var con = getConnector<TProps, EP, TState, TSignals>(connector);
            return connect<TProps, TState, TSignals, EP>(con as any, passedComponent);
          },
          toClass: function (passedComponent: (props: TProps & EP) => Component<TProps & EP>): Component<TProps> {
            var fakeProps = getFakeProps();
            var con = getConnector<TProps, EP, TState, TSignals>(connector);
            return connect<TProps, TState, TSignals, EP>(con as any, passedComponent(fakeProps as any));
          }
        }
      }
    }
  }
  return returned;
}

export function ModuleConnectFactory<TState, TSignals>() {
  function To<TModuleState, TModuleSignals>(stateLookup: (state: TState) => TModuleState, signalsLookup: (state: TSignals) => TModuleSignals) {
    return function returned<TProps>() {
      return {
        with: function <EP>(connector: (connect: Connector<TProps, TState, TSignals> & ModuleConnector<TModuleState, TModuleSignals>) => EP) {
          return {
            to: function (passedComponent: Component<TProps & EP>): Component<TProps> {
              var con = getConnector<TProps, EP, TState, TSignals, TModuleState, TModuleSignals>(connector, { stateLookup, signalsLookup });
              return connect<TProps, TModuleState, TModuleSignals, EP>(con as any, passedComponent);
            },
            toClass: function (passedComponent: (props: TProps & EP) => Component<TProps & EP>): Component<TProps> {
              var fakeProps = getFakeProps();
              var con = getConnector<TProps, EP, TState, TSignals, TModuleState, TModuleSignals>(connector, { stateLookup, signalsLookup });
              return connect<TProps, TModuleState, TModuleSignals, EP>(con as any, passedComponent(fakeProps as any));
            }
          }
        }
      }
    }
  }
  return { To };
}

function getFakeProps() {
  var handler = {
    get: function (target: any, name: any) {
      throw new CerebralError("The props lambda parameter should only be used to conveniently get the type of the components generic props parameter. Use `this.props` in the component instead.");
    }
  };
  var fakeProps = Proxy ? new Proxy({}, handler) : {};
  return fakeProps;
}

function getConnector<TProps, EP, TState, TSignals, TModuleState = {}, TModuleSignals = {}>(connector: (connect: Connector<TProps, TState, TSignals> & ModuleConnector<TModuleState, TModuleSignals>) => EP, lookups?: { stateLookup: (state: TState) => TModuleState; signalsLookup: (state: TSignals) => TModuleSignals }) {
  var con;
  if (lookups) {
    con = (x: Connector<TProps, TState, TSignals>): EP => {
      return connector({
        state: x.state,
        signals: x.signals,
        module: {
          state: lookups.stateLookup(x.state),
          signals: lookups.signalsLookup(x.signals)
        },
        props: x.props
      });
    };
  }
  else {
    con = connector;
  }
  return con;
}
