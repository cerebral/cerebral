/* eslint-env mocha */
import {
    TLegacyState,
    Controller,
    Module,
    Dictionary,
    SequenceFactory,
    SequenceWithPropsFactory,
    ComputedValue,
    Computed
} from './';
import View from './View';
import { autorun } from 'mobx';
import * as assert from 'assert';

describe('Fluent', () => {
    it('should instantiate with initial state', () => {
        type State = {
            foo: string;
        };
        const rootModule = Module<State>({
            state: {
                foo: 'bar'
            }
        });
        const controller = Controller(rootModule);

        assert.deepEqual(controller.state, { foo: 'bar' });
    });
    it('should expose traditional model API', () => {
        type State = {
            foo: string;
            bool: boolean;
            list: string[];
            object: Dictionary<string>;
            count: number;
        };
        type Signals = {
            test: () => void;
        };
        const rootModule = Module<State>({
            state: {
                foo: 'bar',
                bool: true,
                list: [ 'foo', 'bar', 'baz' ],
                object: Dictionary({
                    foo: 'bar'
                }),
                count: 1
            },
            signals: {
                test: [
                    function test({ state }: any) {
                        state.set('foo', state.get('foo') + '2');
                        state.toggle('bool');
                        state.push('list', 'foo2');
                        state.merge('object', { bar: 'baz' });
                        state.pop('list');
                        state.shift('list');
                        state.unshift('list', 'foo3');
                        state.splice('list', 1, 1);
                        state.unset('object.foo');
                        state.concat('list', [ 'apple' ]);
                        state.increment('count', 1);
                    }
                ]
            }
        });
        const controller = Controller<State, Signals>(rootModule, {
            useLegacyStateApi: true
        });

        controller.signals.test();
        assert.equal(controller.state.foo, 'bar2');
        assert.equal(controller.state.bool, false);
        assert.deepEqual(controller.state.list.map((val) => val), [ 'foo3', 'baz', 'apple' ]);
        assert.deepEqual(controller.state.object.toJSON(), { bar: 'baz' });
        assert.equal(controller.state.count, 2);
    });
    it('should instantiate with observable maps', () => {
        type State = {
            map: Dictionary<string>;
        };
        const rootModule = Module<State>({
            state: {
                map: Dictionary({
                    foo: 'bar'
                })
            }
        });
        const controller = Controller<State>(rootModule);

        assert.deepEqual(controller.state.map.get('foo'), 'bar');
    });
    it('should not throw when trying to mutate state outside actions', () => {
        type State = {
            foo: string;
        };
        const rootModule = Module<State>({
            state: {
                foo: 'bar'
            }
        });
        const controller = Controller<State>(rootModule, {
            useStrict: false
        });

        autorun(() => {
            return controller.state.foo;
        });

        assert.doesNotThrow(() => {
            controller.state.foo = 'bar2';
        });
    });

    it('should allow state changes in actions', () => {
        type State = {
            foo: string;
        };
        type Signals = {
            test: (props: { foo: string }) => void;
        };
        type Context = {
            state: State;
        };
        const SequenceWithProps = SequenceWithPropsFactory<Context>();
        const sequence = SequenceWithProps<{
            foo: string;
        }>((s) =>
            s.action(function test({ state, props }) {
                state.foo = 'bar2';
            })
        );

        const rootModule = Module<State, Signals>({
            state: {
                foo: 'bar'
            },
            signals: {
                test: sequence
            }
        });
        const controller = Controller<State, Signals>(rootModule);

        controller.signals.test({
            foo: 'bar'
        });

        assert.equal(controller.state.foo, 'bar2');
    });

    it('should allow computed', () => {
        const Sequence = SequenceFactory<Context>();
        const signal = Sequence((s) =>
            s.action(function test({ state }) {
                state.foo = 'bar2';
            })
        );
        type State = {
            foo: string;
            test: ComputedValue<string>;
        };
        type Signals = {
            test: typeof signal;
        };
        type Context = {
            state: State;
        };
        let hasUpdated = 0;
        const computed = function getter(state: State, root: State) {
            return state.foo.toUpperCase() + root.foo;
        };
        const rootModule = Module<State, Signals>({
            state: {
                foo: 'bar',
                test: Computed(computed)
            },
            signals: {
                test: signal
            }
        });
        const controller = Controller<State, Signals>(rootModule);

        autorun(() => {
            controller.state.test.get();
            hasUpdated++;
        });

        assert.equal(controller.state.test.get(), 'BARbar');
        controller.signals.test();
        assert.equal(hasUpdated, 2);
    });
    it('should allow getters', () => {
        const Sequence = SequenceFactory<Context>();
        const signal = Sequence((s) =>
            s.action(function test({ state }) {
                state.foo = 'bar2';
            })
        );
        type State = {
            foo: string;
            test: string;
        };
        type Signals = {
            test: typeof signal;
        };
        type Context = {
            state: State;
        };
        let hasUpdated = 0;
        const rootModule = Module<State, Signals>({
            state: {
                foo: 'bar',
                get test() {
                    return this.foo.toUpperCase();
                }
            },
            signals: {
                test: signal
            }
        });
        const controller = Controller<State, Signals>(rootModule);

        autorun(() => {
            controller.state.test;
            hasUpdated++;
        });

        assert.equal(controller.state.test, 'BAR');
        controller.signals.test();
        assert.equal(hasUpdated, 2);
    });
    it('should work with fluent api', () => {
        type State = {
            foo: string;
        };
        type Signals = {
            test: (props?: void) => void;
        };
        type Context = {
            state: State;
        };

        const Sequence = SequenceFactory<Context>();
        const sequence = Sequence((s) =>
            s.action(function testAction({ state }) {
                state.foo = 'bar2';
            })
        );
        const rootModule = Module<State, Signals>({
            state: {
                foo: 'bar'
            },
            signals: {
                test: sequence
            }
        });
        const controller = Controller<State, Signals>(rootModule);
        controller.signals.test();
        assert.equal(controller.state.foo, 'bar2');
    });
    it('should send debugging data on mutation methods', () => {
        type State = {
            _set: string;
            _push: string[];
            _pop: string[];
            _shift: string[];
            _splice: string[];
            _unshift: string[];
            _observableMapSet: Dictionary<string>;
        };

        type Context = {
            state: State;
        };
        let actionCount = 0;

        const Sequence = SequenceFactory<Context>();
        const sequence = Sequence((s) =>
            s
                .action(function test({ state }) {
                    state._set = 'bar2';
                })
                .action(function test({ state }) {
                    state._push.push('bar2');
                })
                .action(function test({ state }) {
                    state._pop.pop();
                })
                .action(function test({ state }) {
                    state._shift.shift();
                })
                .action(function test({ state }) {
                    state._splice.splice(1, 0, 'baz');
                })
                .action(function test({ state }) {
                    state._unshift.unshift('bar');
                })
                .action(function test({ state }) {
                    state._observableMapSet.set('foo', 'bar');
                })
        );

        type Signals = {
            test: typeof sequence;
        };
        const rootModule = Module<State, Signals>({
            state: {
                _set: 'foo',
                _push: [],
                _pop: [ 'foo' ],
                _shift: [ 'foo' ],
                _splice: [ 'foo', 'bar' ],
                _unshift: [ 'foo' ],
                _observableMapSet: Dictionary({})
            },
            signals: {
                test: sequence
            }
        });
        const controller = Controller<State, Signals>(rootModule, {
            devtools: {
                init() {},
                send() {},
                updateComponentsMap() {},
                sendExecutionData(data: any) {
                    switch (actionCount) {
                        case 0:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'set',
                                args: [ [ '_set' ], 'bar2' ]
                            });
                            break;
                        case 1:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'push',
                                args: [ [ '_push' ], 'bar2' ]
                            });
                            break;
                        case 2:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'pop',
                                args: [ [ '_pop' ] ]
                            });
                            break;
                        case 3:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'shift',
                                args: [ [ '_shift' ] ]
                            });
                            break;
                        case 4:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'splice',
                                args: [ [ '_splice' ], 1, 0, 'baz' ]
                            });
                            break;
                        case 5:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'unshift',
                                args: [ [ '_unshift' ], 'bar' ]
                            });
                            break;
                        case 6:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'set',
                                args: [ [ '_observableMapSet', 'foo' ], 'bar' ]
                            });
                            break;
                    }
                    actionCount++;
                }
            }
        });

        controller.signals.test();
        assert.equal(controller.state._set, 'bar2');
        assert.equal(controller.state._push[0], 'bar2');
        assert.equal(controller.state._pop.length, 0);
        assert.equal(controller.state._shift.length, 0);
        assert.equal(controller.state._splice.join('.'), 'foo.baz.bar');
        assert.equal(controller.state._unshift[0], 'bar');
        assert.equal(controller.state._observableMapSet.get('foo'), 'bar');
        assert.equal(actionCount, 7);
    });
    it('should update view on state changes', () => {
        type State = {
            foo: string;
        };
        type Signals = {
            test: (props: { foo: string }) => void;
        };
        type Context = {
            state: State;
        };

        let hasUpdated = false;
        const SequenceWithProps = SequenceWithPropsFactory<Context>();
        const sequence = SequenceWithProps<{
            foo: string;
        }>((s) =>
            s.action(function test({ state, props }) {
                state.foo = 'bar2';
            })
        );

        const rootModule = Module<State, Signals>({
            state: {
                foo: 'bar'
            },
            signals: {
                test: sequence
            }
        });
        const controller = Controller<State, Signals>(rootModule);
        const view = new View({
            controller,
            onUpdate() {
                hasUpdated = true;
            },
            props: {},
            dependencies() {
                return {
                    foo: controller.state.foo
                };
            },
            displayName: 'woo'
        });
        view.mount();

        controller.signals.test({
            foo: 'bar'
        });

        assert.equal(controller.state.foo, 'bar2');
        assert.equal(hasUpdated, true);
    });
    it('should handle nested map property', () => {
        type State = {
            observableMapSet: Dictionary<{
                foo: string;
            }>;
        };

        type Context = {
            state: State;
        };
        let actionCount = 0;

        const Sequence = SequenceFactory<Context>();
        const sequence = Sequence((s) =>
            s.action(function test({ state }) {
                const item = state.observableMapSet.get('item');
                if (item) {
                    item.foo = 'string2';
                }
            })
        );
        type Signals = {
            test: typeof sequence;
        };
        const rootModule = Module<State, Signals>({
            state: {
                observableMapSet: Dictionary({
                    item: {
                        foo: 'string'
                    }
                })
            },
            signals: {
                test: sequence
            }
        });
        const controller = Controller<State, Signals>(rootModule, {
            devtools: {
                init() {},
                send() {},
                updateComponentsMap() {},
                sendExecutionData(data: any) {
                    assert.deepEqual(data, {
                        type: 'mutation',
                        method: 'set',
                        args: [ [ 'observableMapSet', 'item', 'foo' ], 'string2' ]
                    });
                    actionCount++;
                }
            }
        });

        controller.signals.test();

        const item = controller.state.observableMapSet.get('item');
        if (item) {
            assert.equal(item.foo, 'string2');
        }
    });
    it('should handle removing map property', () => {
        type State = {
            observableMapSet: Dictionary<{
                foo: string;
            }>;
        };

        type Context = {
            state: State;
        };
        let actionCount = 0;
        const Sequence = SequenceFactory<Context>();
        const sequence = Sequence((s) =>
            s.action(function test({ state }) {
                const item = state.observableMapSet.delete('item');
            })
        );
        type Signals = {
            test: typeof sequence;
        };
        const rootModule = Module<State, Signals>({
            state: {
                observableMapSet: Dictionary({
                    item: {
                        foo: 'string'
                    }
                })
            },
            signals: {
                test: sequence
            }
        });
        const controller = Controller<State, Signals>(rootModule, {
            devtools: {
                init() {},
                send() {},
                updateComponentsMap() {},
                sendExecutionData(data: any) {
                    assert.deepEqual(data, {
                        type: 'mutation',
                        method: 'unset',
                        args: [ [ 'observableMapSet', 'item' ] ]
                    });
                    actionCount++;
                }
            }
        });

        controller.signals.test();

        assert.equal(controller.state.observableMapSet.size, 0);
    });
    it('should handle reusing same proxy', () => {
        type State = {
            foo: {
                bar: {
                    baz: string;
                };
                bar2: {
                    baz2: string;
                };
            };
        };

        type Context = {
            state: State;
        };
        let actionCount = 0;
        const Sequence = SequenceFactory<Context>();
        const sequence = Sequence((s) =>
            s.action(function test({ state }) {
                const foo = state.foo;
                foo.bar.baz = 'mip2';
                foo.bar2.baz2 = 'mip3';
            })
        );
        type Signals = {
            test: typeof sequence;
        };
        const rootModule = Module<State, Signals>({
            state: {
                foo: {
                    bar: {
                        baz: 'mip'
                    },
                    bar2: {
                        baz2: 'mip2'
                    }
                }
            },
            signals: {
                test: sequence
            }
        });
        const controller = Controller<State, Signals>(rootModule, {
            devtools: {
                init() {},
                send() {},
                updateComponentsMap() {},
                sendExecutionData(data: any) {
                    if (actionCount === 0) {
                        assert.deepEqual(data, {
                            type: 'mutation',
                            method: 'set',
                            args: [ [ 'foo', 'bar', 'baz' ], 'mip2' ]
                        });
                    } else {
                        assert.deepEqual(data, {
                            type: 'mutation',
                            method: 'set',
                            args: [ [ 'foo', 'bar2', 'baz2' ], 'mip3' ]
                        });
                    }
                    actionCount++;
                }
            }
        });

        controller.signals.test();

        assert.equal(controller.state.foo.bar.baz, 'mip2');
    });
    it('should handle other map methods', () => {
        type State = {
            observableMapSet: Dictionary<{
                foo: string;
                bar: string;
            }>;
        };

        type Context = {
            state: State;
        };
        let actionCount = 0;
        const Sequence = SequenceFactory<Context>();
        const sequence = Sequence((s) =>
            s.action(function test({ state }) {
                const hasKey = state.observableMapSet.has('item');
                const keys = state.observableMapSet.keys();
                const values = state.observableMapSet.values();
                const entries = state.observableMapSet.entries();
                state.observableMapSet.forEach((item) => {
                    item.foo = 'miiip';
                    item.bar = 'mopmop';
                });

                state.observableMapSet.size;

                state.observableMapSet.set('item', { foo: 'foo2', bar: 'bar2' });
                state.observableMapSet.clear();
                state.observableMapSet.merge({ bar: 'baz' });
                state.observableMapSet.replace({ baz: 'bop' });
            })
        );
        type Signals = {
            test: typeof sequence;
        };
        const rootModule = Module<State, Signals>({
            state: {
                observableMapSet: Dictionary({
                    item: {
                        foo: 'string',
                        bar: 'string2'
                    }
                })
            },
            signals: {
                test: sequence
            }
        });
        const controller = Controller<State, Signals>(rootModule, {
            devtools: {
                init() {},
                send() {},
                updateComponentsMap() {},
                sendExecutionData(data: any) {
                    switch (actionCount) {
                        case 0:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'set',
                                args: [ [ 'observableMapSet', 'item', 'foo' ], 'miiip' ]
                            });
                            break;
                        case 1:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'set',
                                args: [ [ 'observableMapSet', 'item', 'bar' ], 'mopmop' ]
                            });
                            break;
                        case 2:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'set',
                                args: [ [ 'observableMapSet', 'item' ], { foo: 'foo2', bar: 'bar2' } ]
                            });
                            break;
                        case 3:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'set',
                                args: [ [ 'observableMapSet' ], {} ]
                            });
                            break;
                        case 4:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'merge',
                                args: [ [ 'observableMapSet' ], { bar: 'baz' } ]
                            });
                            break;
                        case 5:
                            assert.deepEqual(data, {
                                type: 'mutation',
                                method: 'set',
                                args: [ [ 'observableMapSet' ], { baz: 'bop' } ]
                            });
                            break;
                    }
                    actionCount++;
                }
            }
        });

        controller.signals.test();

        const item = controller.state.observableMapSet.get('item');

        if (item) {
            assert.deepEqual(controller.state.observableMapSet.toJS(), {
                baz: 'bop'
            });
        }
    });
});
