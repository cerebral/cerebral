/* eslint-env mocha */
import {
  Controller,
  Module,
  Dictionary,
  SequenceFactory,
  SequenceWithPropsFactory,
  ComputedValue,
  Computed,
} from './'
import View from './View'
import { autorun } from 'mobx'
import * as assert from 'assert'

describe('Fluent', () => {
  it('should instantiate with initial state', () => {
    type State = {
      foo: string
    }
    const rootModule = Module<State>({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)

    assert.deepEqual(controller.state, { foo: 'bar' })
  })
  it('should expose traditional model API', () => {
    type State = {
      foo: string
      bool: boolean
      list: string[]
      object: Dictionary<string>
      count: number
    }
    type Signals = {
      test: () => void
    }
    const rootModule = Module<State>({
      state: {
        foo: 'bar',
        bool: true,
        list: ['foo', 'bar', 'baz'],
        object: Dictionary({
          foo: 'bar',
        }),
        count: 1,
      },
      sequences: {
        test: [
          function test({ state }: any) {
            state.set('foo', state.get('foo') + '2')
            state.toggle('bool')
            state.push('list', 'foo2')
            state.merge('object', { bar: 'baz' })
            state.pop('list')
            state.shift('list')
            state.unshift('list', 'foo3')
            state.splice('list', 1, 1)
            state.unset('object.foo')
            state.concat('list', ['apple'])
            state.increment('count', 1)
          },
        ],
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      useLegacyStateApi: true,
    })

    controller.sequences.test()
    assert.equal(controller.state.foo, 'bar2')
    assert.equal(controller.state.bool, false)
    assert.deepEqual(controller.state.list.map((val) => val), [
      'foo3',
      'baz',
      'apple',
    ])
    assert.deepEqual(controller.state.object.toJSON(), { bar: 'baz' })
    assert.equal(controller.state.count, 2)
  })
  it('should instantiate with observable maps', () => {
    type State = {
      map: Dictionary<string>
    }
    const rootModule = Module<State>({
      state: {
        map: Dictionary({
          foo: 'bar',
        }),
      },
    })
    const controller = Controller<State>(rootModule)

    assert.deepEqual(controller.state.map.get('foo'), 'bar')
  })
  it('should not throw when trying to mutate state outside actions', () => {
    type State = {
      foo: string
    }
    const rootModule = Module<State>({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller<State>(rootModule, {
      useStrict: false,
    })

    autorun(() => {
      return controller.state.foo
    })

    assert.doesNotThrow(() => {
      controller.state.foo = 'bar2'
    })
  })

  it('should allow state changes in actions', () => {
    type State = {
      foo: string
    }
    type Signals = {
      test: (props: { foo: string }) => void
    }
    type Context = {
      state: State
    }
    const SequenceWithProps = SequenceWithPropsFactory<Context>()
    const sequence = SequenceWithProps<{
      foo: string
    }>((s) =>
      s.action(function test({ state, props }) {
        state.foo = 'bar2'
      })
    )

    const rootModule = Module<State, Signals>({
      state: {
        foo: 'bar',
      },
      sequences: {
        test: sequence,
      },
    })
    const controller = Controller<State, Signals>(rootModule)

    controller.sequences.test({
      foo: 'bar',
    })

    assert.equal(controller.state.foo, 'bar2')
  })

  it('should allow computed', () => {
    const Sequence = SequenceFactory<Context>()
    const signal = Sequence((s) =>
      s.action(function test({ state }) {
        state.foo = 'bar2'
      })
    )
    type State = {
      foo: string
      test: ComputedValue<string>
    }
    type Signals = {
      test: typeof signal
    }
    type Context = {
      state: State
    }
    let hasUpdated = 0
    const computed = function getter(state: State, root: State) {
      return state.foo.toUpperCase() + root.foo
    }
    const rootModule = Module<State, Signals>({
      state: {
        foo: 'bar',
        test: Computed(computed),
      },
      sequences: {
        test: signal,
      },
    })
    const controller = Controller<State, Signals>(rootModule)

    autorun(() => {
      controller.state.test.get()
      hasUpdated++
    })

    assert.equal(controller.state.test.get(), 'BARbar')
    controller.sequences.test()
    assert.equal(hasUpdated, 2)
  })
  it('should allow getters', () => {
    const Sequence = SequenceFactory<Context>()
    const signal = Sequence((s) =>
      s.action(function test({ state }) {
        state.foo = 'bar2'
      })
    )
    type State = {
      foo: string
      test: string
    }
    type Signals = {
      test: typeof signal
    }
    type Context = {
      state: State
    }
    let hasUpdated = 0
    const rootModule = Module<State, Signals>({
      state: {
        foo: 'bar',
        get test() {
          return this.foo.toUpperCase()
        },
      },
      sequences: {
        test: signal,
      },
    })
    const controller = Controller<State, Signals>(rootModule)

    autorun(() => {
      controller.state.test
      hasUpdated++
    })

    assert.equal(controller.state.test, 'BAR')
    controller.sequences.test()
    assert.equal(hasUpdated, 2)
  })
  it('should work with fluent api', () => {
    type State = {
      foo: string
    }
    type Signals = {
      test: (props?: void) => void
    }
    type Context = {
      state: State
    }

    const Sequence = SequenceFactory<Context>()
    const sequence = Sequence((s) =>
      s.action(function testAction({ state }) {
        state.foo = 'bar2'
      })
    )
    const rootModule = Module<State, Signals>({
      state: {
        foo: 'bar',
      },
      sequences: {
        test: sequence,
      },
    })
    const controller = Controller<State, Signals>(rootModule)
    controller.sequences.test()
    assert.equal(controller.state.foo, 'bar2')
  })
  it('should send debugging data on mutation methods', () => {
    type State = {
      _set: string
      _push: string[]
      _pop: string[]
      _shift: string[]
      _splice: string[]
      _unshift: string[]
      _observableMapSet: Dictionary<string>
    }

    type Context = {
      state: State
    }
    let actionCount = 0

    const Sequence = SequenceFactory<Context>()
    const sequence = Sequence((s) =>
      s
        .action(function test({ state }) {
          state._set = 'bar2'
        })
        .action(function test({ state }) {
          state._push.push('bar2')
        })
        .action(function test({ state }) {
          state._pop.pop()
        })
        .action(function test({ state }) {
          state._shift.shift()
        })
        .action(function test({ state }) {
          state._splice.splice(1, 0, 'baz')
        })
        .action(function test({ state }) {
          state._unshift.unshift('bar')
        })
        .action(function test({ state }) {
          state._observableMapSet.set('foo', 'bar')
        })
    )

    type Signals = {
      test: typeof sequence
    }
    const rootModule = Module<State, Signals>({
      state: {
        _set: 'foo',
        _push: [],
        _pop: ['foo'],
        _shift: ['foo'],
        _splice: ['foo', 'bar'],
        _unshift: ['foo'],
        _observableMapSet: Dictionary({}),
      },
      sequences: {
        test: sequence,
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateComponentsMap() {},
        sendExecutionData(data: any) {
          switch (actionCount) {
            case 0:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'set',
                args: [['_set'], 'bar2'],
              })
              break
            case 1:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'push',
                args: [['_push'], 'bar2'],
              })
              break
            case 2:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'pop',
                args: [['_pop']],
              })
              break
            case 3:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'shift',
                args: [['_shift']],
              })
              break
            case 4:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'splice',
                args: [['_splice'], 1, 0, 'baz'],
              })
              break
            case 5:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'unshift',
                args: [['_unshift'], 'bar'],
              })
              break
            case 6:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'set',
                args: [['_observableMapSet', 'foo'], 'bar'],
              })
              break
          }
          actionCount++
        },
      },
    })

    controller.sequences.test()
    assert.equal(controller.state._set, 'bar2')
    assert.equal(controller.state._push[0], 'bar2')
    assert.equal(controller.state._pop.length, 0)
    assert.equal(controller.state._shift.length, 0)
    assert.equal(controller.state._splice.join('.'), 'foo.baz.bar')
    assert.equal(controller.state._unshift[0], 'bar')
    assert.equal(controller.state._observableMapSet.get('foo'), 'bar')
    assert.equal(actionCount, 7)
  })
  it('should update view on state changes', () => {
    type State = {
      foo: string
    }
    type Signals = {
      test: (props: { foo: string }) => void
    }
    type Context = {
      state: State
    }

    let hasUpdated = false
    const SequenceWithProps = SequenceWithPropsFactory<Context>()
    const sequence = SequenceWithProps<{
      foo: string
    }>((s) =>
      s.action(function test({ state, props }) {
        state.foo = 'bar2'
      })
    )

    const rootModule = Module<State, Signals>({
      state: {
        foo: 'bar',
      },
      sequences: {
        test: sequence,
      },
    })
    const controller = Controller<State, Signals>(rootModule)
    const view = new View({
      controller,
      onUpdate() {
        hasUpdated = true
      },
      props: {},
      dependencies() {
        return {
          foo: controller.state.foo,
        }
      },
      displayName: 'woo',
    })
    view.mount()

    controller.sequences.test({
      foo: 'bar',
    })

    assert.equal(controller.state.foo, 'bar2')
    assert.equal(hasUpdated, true)
  })
  it('should handle nested map property', () => {
    type State = {
      observableMapSet: Dictionary<{
        foo: string
      }>
    }

    type Context = {
      state: State
    }

    const Sequence = SequenceFactory<Context>()
    const sequence = Sequence((s) =>
      s.action(function test({ state }) {
        const item = state.observableMapSet.get('item')
        if (item) {
          item.foo = 'string2'
        }
      })
    )
    type Signals = {
      test: typeof sequence
    }
    const rootModule = Module<State, Signals>({
      state: {
        observableMapSet: Dictionary({
          item: {
            foo: 'string',
          },
        }),
      },
      sequences: {
        test: sequence,
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateComponentsMap() {},
        sendExecutionData(data: any) {
          assert.deepEqual(data, {
            type: 'mutation',
            method: 'set',
            args: [['observableMapSet', 'item', 'foo'], 'string2'],
          })
        },
      },
    })

    controller.sequences.test()

    const item = controller.state.observableMapSet.get('item')
    if (item) {
      assert.equal(item.foo, 'string2')
    }
  })
  it('should handle removing map property', () => {
    type State = {
      observableMapSet: Dictionary<{
        foo: string
      }>
    }

    type Context = {
      state: State
    }
    const Sequence = SequenceFactory<Context>()
    const sequence = Sequence((s) =>
      s.action(function test({ state }) {
        state.observableMapSet.delete('item')
      })
    )
    type Signals = {
      test: typeof sequence
    }
    const rootModule = Module<State, Signals>({
      state: {
        observableMapSet: Dictionary({
          item: {
            foo: 'string',
          },
        }),
      },
      sequences: {
        test: sequence,
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateComponentsMap() {},
        sendExecutionData(data: any) {
          assert.deepEqual(data, {
            type: 'mutation',
            method: 'unset',
            args: [['observableMapSet', 'item']],
          })
        },
      },
    })

    controller.sequences.test()

    assert.equal(controller.state.observableMapSet.size, 0)
  })
  it('should handle reusing same proxy', () => {
    type State = {
      foo: {
        bar: {
          baz: string
        }
        bar2: {
          baz2: string
        }
      }
    }

    type Context = {
      state: State
    }
    let actionCount = 0
    const Sequence = SequenceFactory<Context>()
    const sequence = Sequence((s) =>
      s.action(function test({ state }) {
        const foo = state.foo
        foo.bar.baz = 'mip2'
        foo.bar2.baz2 = 'mip3'
      })
    )
    type Signals = {
      test: typeof sequence
    }
    const rootModule = Module<State, Signals>({
      state: {
        foo: {
          bar: {
            baz: 'mip',
          },
          bar2: {
            baz2: 'mip2',
          },
        },
      },
      sequences: {
        test: sequence,
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateComponentsMap() {},
        sendExecutionData(data: any) {
          if (actionCount === 0) {
            assert.deepEqual(data, {
              type: 'mutation',
              method: 'set',
              args: [['foo', 'bar', 'baz'], 'mip2'],
            })
          } else {
            assert.deepEqual(data, {
              type: 'mutation',
              method: 'set',
              args: [['foo', 'bar2', 'baz2'], 'mip3'],
            })
          }
          actionCount++
        },
      },
    })

    controller.sequences.test()

    assert.equal(controller.state.foo.bar.baz, 'mip2')
  })
  it('should handle other map methods', () => {
    type State = {
      observableMapSet: Dictionary<{
        foo: string
        bar: string
      }>
    }

    type Context = {
      state: State
    }
    let actionCount = 0
    const Sequence = SequenceFactory<Context>()
    const sequence = Sequence((s) =>
      s.action(function test({ state }) {
        state.observableMapSet.has('item')
        state.observableMapSet.keys()
        state.observableMapSet.values()
        state.observableMapSet.entries()
        state.observableMapSet.forEach((item) => {
          item.foo = 'miiip'
          item.bar = 'mopmop'
        })

        state.observableMapSet.size

        state.observableMapSet.set('item', { foo: 'foo2', bar: 'bar2' })
        state.observableMapSet.clear()
        state.observableMapSet.merge({ bar: 'baz' })
        state.observableMapSet.replace({ baz: 'bop' })
      })
    )
    type Signals = {
      test: typeof sequence
    }
    const rootModule = Module<State, Signals>({
      state: {
        observableMapSet: Dictionary({
          item: {
            foo: 'string',
            bar: 'string2',
          },
        }),
      },
      sequences: {
        test: sequence,
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateComponentsMap() {},
        sendExecutionData(data: any) {
          switch (actionCount) {
            case 0:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'set',
                args: [['observableMapSet', 'item', 'foo'], 'miiip'],
              })
              break
            case 1:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'set',
                args: [['observableMapSet', 'item', 'bar'], 'mopmop'],
              })
              break
            case 2:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'set',
                args: [
                  ['observableMapSet', 'item'],
                  { foo: 'foo2', bar: 'bar2' },
                ],
              })
              break
            case 3:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'set',
                args: [['observableMapSet'], {}],
              })
              break
            case 4:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'merge',
                args: [['observableMapSet'], { bar: 'baz' }],
              })
              break
            case 5:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'set',
                args: [['observableMapSet'], { baz: 'bop' }],
              })
              break
          }
          actionCount++
        },
      },
    })

    controller.sequences.test()

    const item = controller.state.observableMapSet.get('item')

    if (item) {
      assert.deepEqual(controller.state.observableMapSet.toJS(), {
        baz: 'bop',
      })
    }
  })
  it('should manage module state', () => {
    type ModuleState = {
      _set: string
      _push: string[]
      _pop: string[]
      _shift: string[]
      _splice: string[]
      _unshift: string[]
      _observableMapSet: Dictionary<string>
    }

    type State = {
      foo: ModuleState
    }

    type Context = {
      state: State
      module: ModuleState
    }
    let actionCount = 0

    const Sequence = SequenceFactory<Context>()
    const sequence = Sequence((s) =>
      s
        .action(function test({ module }) {
          module._set = 'bar2'
        })
        .action(function test({ module }) {
          module._push.push('bar2')
        })
        .action(function test({ module }) {
          module._pop.pop()
        })
        .action(function test({ module }) {
          module._shift.shift()
        })
        .action(function test({ module }) {
          module._splice.splice(1, 0, 'baz')
        })
        .action(function test({ module }) {
          module._unshift.unshift('bar')
        })
        .action(function test({ module }) {
          module._observableMapSet.set('foo', 'bar')
        })
    )

    type ModuleSignals = {
      test: typeof sequence
    }
    type Signals = {
      foo: ModuleSignals
    }
    const fooModule = Module<ModuleState, ModuleSignals>({
      state: {
        _set: 'foo',
        _push: [],
        _pop: ['foo'],
        _shift: ['foo'],
        _splice: ['foo', 'bar'],
        _unshift: ['foo'],
        _observableMapSet: Dictionary({}),
      },
      sequences: {
        test: sequence,
      },
    })
    const rootModule = Module<State, Signals>({
      modules: {
        foo: fooModule,
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateComponentsMap() {},
        sendExecutionData(data: any) {
          switch (actionCount) {
            case 0:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'module.set',
                args: [['foo', '_set'], 'bar2'],
              })
              break
            case 1:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'module.push',
                args: [['foo', '_push'], 'bar2'],
              })
              break
            case 2:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'module.pop',
                args: [['foo', '_pop']],
              })
              break
            case 3:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'module.shift',
                args: [['foo', '_shift']],
              })
              break
            case 4:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'module.splice',
                args: [['foo', '_splice'], 1, 0, 'baz'],
              })
              break
            case 5:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'module.unshift',
                args: [['foo', '_unshift'], 'bar'],
              })
              break
            case 6:
              assert.deepEqual(data, {
                type: 'mutation',
                method: 'module.set',
                args: [['foo', '_observableMapSet', 'foo'], 'bar'],
              })
              break
          }
          actionCount++
        },
      },
    })

    controller.sequences.foo.test()
    assert.equal(controller.state.foo._set, 'bar2')
    assert.equal(controller.state.foo._push[0], 'bar2')
    assert.equal(controller.state.foo._pop.length, 0)
    assert.equal(controller.state.foo._shift.length, 0)
    assert.equal(controller.state.foo._splice.join('.'), 'foo.baz.bar')
    assert.equal(controller.state.foo._unshift[0], 'bar')
    assert.equal(controller.state.foo._observableMapSet.get('foo'), 'bar')
    assert.equal(actionCount, 7)
  })
  it('should manage module state without devtools', () => {
    type ModuleState = {
      _set: string
      _push: string[]
      _pop: string[]
      _shift: string[]
      _splice: string[]
      _unshift: string[]
      _observableMapSet: Dictionary<string>
    }

    type State = {
      foo: ModuleState
    }

    type Context = {
      state: State
      module: ModuleState
    }

    const Sequence = SequenceFactory<Context>()
    const sequence = Sequence((s) =>
      s
        .action(function test({ module }) {
          module._set = 'bar2'
        })
        .action(function test({ module }) {
          module._push.push('bar2')
        })
        .action(function test({ module }) {
          module._pop.pop()
        })
        .action(function test({ module }) {
          module._shift.shift()
        })
        .action(function test({ module }) {
          module._splice.splice(1, 0, 'baz')
        })
        .action(function test({ module }) {
          module._unshift.unshift('bar')
        })
        .action(function test({ module }) {
          module._observableMapSet.set('foo', 'bar')
        })
    )

    type ModuleSignals = {
      test: typeof sequence
    }
    type Signals = {
      foo: ModuleSignals
    }
    const fooModule = Module<ModuleState, ModuleSignals>({
      state: {
        _set: 'foo',
        _push: [],
        _pop: ['foo'],
        _shift: ['foo'],
        _splice: ['foo', 'bar'],
        _unshift: ['foo'],
        _observableMapSet: Dictionary({}),
      },
      sequences: {
        test: sequence,
      },
    })
    const rootModule = Module<State, Signals>({
      modules: {
        foo: fooModule,
      },
    })
    const controller = Controller<State, Signals>(rootModule)

    controller.sequences.foo.test()
    assert.equal(controller.state.foo._set, 'bar2')
    assert.equal(controller.state.foo._push[0], 'bar2')
    assert.equal(controller.state.foo._pop.length, 0)
    assert.equal(controller.state.foo._shift.length, 0)
    assert.equal(controller.state.foo._splice.join('.'), 'foo.baz.bar')
    assert.equal(controller.state.foo._unshift[0], 'bar')
    assert.equal(controller.state.foo._observableMapSet.get('foo'), 'bar')
  })
})
