import request from './request'
import { urlEncode, mergeWith, createResponse } from './utils'
import FileUpload from './fileUpload'
import DEFAULT_OPTIONS from './DEFAULT_OPTIONS'

export default class HttpService {
  constructor(controller, passedOptions) {
    this.controller = controller
    this.requests = {}
    this.moduleOptions = mergeWith({}, DEFAULT_OPTIONS)
    if (typeof passedOptions === 'function') {
      this.moduleOptions = passedOptions(this.moduleOptions)
    } else if (passedOptions) {
      this.moduleOptions = mergeWith(passedOptions, DEFAULT_OPTIONS)
    }
  }

  createAbortablePromise(url, cb) {
    return new Promise((resolve, reject) => {
      this.requests[url] = {
        resolve: resolve,
        reject: reject,
        // eslint-disable-next-line standard/no-callback-literal
        xhr: cb(
          payload => {
            delete this.requests[url]
            resolve(payload)
          },
          error => {
            delete this.requests[url]
            reject(error)
          }
        ),
      }
    })
  }

  request(options) {
    options = mergeWith(options, this.moduleOptions)

    if (typeof options.onProgress === 'string') {
      options.onProgress = this.controller.getSignal(options.onProgress)
    }

    options.method = options.method.toUpperCase()

    return this.createAbortablePromise(options.url, (resolve, reject) => {
      return request(options, createResponse(options, resolve, reject))
    })
  }

  get(url, passedQuery, options = {}) {
    const query = passedQuery || options.query

    options.url = query && Object.keys(query).length
      ? url + '?' + urlEncode(query)
      : url
    options.method = 'GET'

    return this.request(options)
  }

  post(url, body, options = {}) {
    options.url = options.query && Object.keys(options.query).length
      ? url + '?' + urlEncode(options.query)
      : url
    options.method = 'POST'
    options.body = body

    return this.request(options)
  }

  put(url, body, options = {}) {
    options.url = options.query && Object.keys(options.query).length
      ? url + '?' + urlEncode(options.query)
      : url
    options.method = 'PUT'
    options.body = body

    return this.request(options)
  }

  patch(url, body, options = {}) {
    options.url = options.query && Object.keys(options.query).length
      ? url + '?' + urlEncode(options.query)
      : url
    options.method = 'PATCH'
    options.body = body

    return this.request(options)
  }

  delete(url, query, options = {}) {
    options.url = options.query && Object.keys(options.query).length
      ? url + '?' + urlEncode(options.query)
      : url
    options.method = 'DELETE'

    return this.request(options)
  }

  updateOptions(newOptions) {
    this.moduleOptions = mergeWith(newOptions, this.moduleOptions)
  }

  abort(regexp) {
    const matchingUrls = Object.keys(this.requests).filter(url => {
      return Boolean(url.match(new RegExp(regexp)))
    })
    matchingUrls.forEach(url => {
      this.requests[url].xhr.abort()
    })
  }

  uploadFile(url, files, options = {}) {
    options.url = this.moduleOptions.baseUrl + url
    options.onProgress = typeof options.onProgress === 'string'
      ? this.controller.getSignal(options.onProgress)
      : options.onProgress

    return new FileUpload(options).send(files)
  }
}
