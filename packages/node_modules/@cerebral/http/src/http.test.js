/* eslint-env mocha */
import { Controller } from 'cerebral'
import { string, props } from 'cerebral/tags'
import HttpProvider from './'
import {
  httpGet,
  httpPost,
  httpPut,
  httpPatch,
  httpDelete,
  httpAbort,
} from './operators'
import assert from 'assert'
import mock from 'xhr-mock'

mock.setup()

let urlIndex = 0
function createUrl(additional = '') {
  return '/items' + urlIndex++ + additional
}

describe('Http Provider', () => {
  it('should create requests', done => {
    const url = createUrl()
    mock.get(url, (req, res) => {
      return res
        .status(200)
        .header('Content-Type', 'application/json')
        .body(JSON.stringify({ foo: 'bar' }))
    })
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          ({ http, path }) => {
            return http.request({ method: 'GET', url }).then(path.success)
          },
          {
            success: [
              ({ props }) => {
                assert.deepEqual(props, {
                  result: { foo: 'bar' },
                  isAborted: false,
                  status: 200,
                  headers: { 'content-type': 'application/json' },
                })
                done()
              },
            ],
          },
        ],
      },
    })
    controller.getSignal('test')()
  })
  it('should create GET requests with queries', done => {
    const url = createUrl('?foo=bar')
    const query = '?foo=bar'
    mock.get(url + query, (req, res) => {
      assert.equal(req.url(), url + query)
      return res.status(200).header('Content-Type', 'application/json')
    })
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          ({ http, path }) => {
            return http.get(url, { foo: 'bar' }).then(path.success)
          },
          {
            success: [() => done()],
          },
        ],
      },
    })
    controller.getSignal('test')()
  })
  it('should create POST requests with body', done => {
    const url = createUrl()
    mock.post(url, (req, res) => {
      assert.equal(req.body(), JSON.stringify({ foo: 'bar' }))
      return res.status(200).header('Content-Type', 'application/json')
    })
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          ({ http, path }) => {
            return http.post(url, { foo: 'bar' }).then(path.success)
          },
          {
            success: [() => done()],
          },
        ],
      },
    })
    controller.getSignal('test')()
  })
  it('should create PUT requests with body', done => {
    const url = createUrl()
    mock.put(url, (req, res) => {
      assert.equal(req.body(), JSON.stringify({ foo: 'bar' }))
      return res.status(200).header('Content-Type', 'application/json')
    })
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          ({ http, path }) => {
            return http.put(url, { foo: 'bar' }).then(path.success)
          },
          {
            success: [() => done()],
          },
        ],
      },
    })
    controller.getSignal('test')()
  })
  it('should create PATCH requests with body', done => {
    const url = createUrl()
    mock.patch(url, (req, res) => {
      assert.equal(req.body(), JSON.stringify({ foo: 'bar' }))
      return res.status(200).header('Content-Type', 'application/json')
    })
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          ({ http, path }) => {
            return http.patch(url, { foo: 'bar' }).then(path.success)
          },
          {
            success: [() => done()],
          },
        ],
      },
    })
    controller.getSignal('test')()
  })
  it('should create DELETE requests', done => {
    const url = createUrl()
    mock.delete(url, (req, res) => {
      assert.ok(true)
      return res.status(200).header('Content-Type', 'application/json')
    })
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          ({ http, path }) => {
            return http.delete(url).then(path.success)
          },
          {
            success: [() => done()],
          },
        ],
      },
    })
    controller.getSignal('test')()
  })
  it('should handle error requests', done => {
    const url = createUrl()
    mock.get(url, (req, res) => {
      return res.status(500).header('Content-Type', 'application/json')
    })
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          ({ http, path }) => {
            return http
              .get(url)
              .then(path.success)
              .catch(error => path.error({ error }))
          },
          {
            success: [],
            error: [
              ({ props }) => {
                assert.equal(props.error.response.status, 500)
                done()
              },
            ],
          },
        ],
      },
    })
    controller.getSignal('test')()
  })
  it('should abort request', done => {
    const url = createUrl()
    mock.get(url, (req, res) => {
      return res.timeout(500)
    })
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          ({ http, path }) => {
            return http.get(url).catch(error => {
              assert.ok(error.response.isAborted)
              return path.aborted()
            })
          },
          {
            aborted: [() => done()],
          },
        ],
        test2: [
          ({ http }) => {
            http.abort('/items')
          },
        ],
      },
    })
    controller.getSignal('test')()
    controller.getSignal('test2')()
  })
  it('should expose factories to do requests', done => {
    const baseUrl = createUrl()
    mock.get(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })
    mock.post(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })
    mock.put(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })
    mock.patch(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })
    mock.delete(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })

    let responseCount = 0
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          httpGet(string`${baseUrl}/${props`itemId`}`),
          {
            success: [
              () => {
                responseCount++
              },
            ],
          },
          httpPost(string`${baseUrl}/${props`itemId`}`),
          {
            success: [
              () => {
                responseCount++
              },
            ],
          },
          httpPut(string`${baseUrl}/${props`itemId`}`),
          {
            success: [
              () => {
                responseCount++
              },
            ],
          },
          httpPatch(string`${baseUrl}/${props`itemId`}`),
          {
            success: [
              () => {
                responseCount++
              },
            ],
          },
          httpDelete(string`${baseUrl}/${props`itemId`}`),
          {
            success: [
              () => {
                responseCount++
              },
            ],
          },
          () => {
            assert.equal(responseCount, 5)
            done()
          },
        ],
      },
    })
    controller.getSignal('test')({
      itemId: 1,
    })
  })
  it('should allow factories to accept tags in props data', done => {
    const mockResponse = (req, res) => {
      assert.equal(req.body(), JSON.stringify({ data: 1 }))
      return res.status(200).header('Content-Type', 'application/json')
    }

    const urlA = createUrl()
    const urlB = createUrl()
    const urlC = createUrl()
    mock.post(urlA, mockResponse)
    mock.put(urlB, mockResponse)
    mock.patch(urlC, mockResponse)

    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          httpPost(urlA, { data: props`data` }),
          {
            success: [],
          },
          httpPut(urlB, { data: props`data` }),
          {
            success: [],
          },
          httpPatch(urlC, { data: props`data` }),
          {
            success: [],
          },
          () => {
            done()
          },
        ],
      },
    })
    controller.getSignal('test')({
      data: 1,
    })
  })
  it('should call status code paths', done => {
    const url = createUrl()
    mock.get(url, (req, res) => {
      return res.status(201).header('Content-Type', 'application/json')
    })

    let responseCount = 0
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          httpGet(url),
          {
            '201': [
              () => {
                responseCount++
              },
            ],
          },
          () => {
            assert.equal(responseCount, 1)
            done()
          },
        ],
      },
    })
    controller.getSignal('test')()
  })
  it('should abort request with operator', done => {
    mock.get('/items', (req, res) => {
      return res.timeout(500)
    })
    const controller = Controller({
      providers: [HttpProvider()],
      signals: {
        test: [
          ({ http, path }) => {
            return http.get('/items').catch(error => {
              assert.ok(error.response.isAborted)
              return path.aborted()
            })
          },
          {
            aborted: [() => done()],
          },
        ],
        test2: [httpAbort('/items')],
      },
    })
    controller.getSignal('test')()
    controller.getSignal('test2')()
  })
})
