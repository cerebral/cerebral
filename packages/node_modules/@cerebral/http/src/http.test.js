/* eslint-env mocha */
import { Controller, Module } from 'cerebral'
import { string, props, resolveObject } from 'cerebral/tags'
import HttpProvider from './'
import {
  httpGet,
  httpPost,
  httpPut,
  httpPatch,
  httpDelete,
  httpAbort,
} from './factories'
import assert from 'assert'
import mock from 'xhr-mock'

mock.setup()

let urlIndex = 0
function createUrl(additional = '') {
  return '/items' + urlIndex++ + additional
}

describe('Http Provider', () => {
  it('should create requests', (done) => {
    const url = createUrl()
    mock.get(url, (req, res) => {
      return res
        .status(200)
        .header('Content-Type', 'application/json')
        .body(JSON.stringify({ foo: 'bar' }))
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http.request({ method: 'GET', url }).then(path.success)
            },
            {
              success: [
                ({ props }) => {
                  assert.deepEqual(props, {
                    result: { foo: 'bar' },
                    status: 200,
                    headers: { 'content-type': 'application/json' },
                  })
                  done()
                },
              ],
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
  })
  it('should create GET requests with queries', (done) => {
    const url = createUrl()
    const query = '?foo=bar'
    mock.get(url + query, (req, res) => {
      assert.equal(req.url(), url + query)
      return res.header('Content-Type', 'application/json').status(200)
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http.get(url, { foo: 'bar' }).then(path.success)
            },
            {
              success: [() => done()],
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
  })
  it('should create POST requests with body', (done) => {
    const url = createUrl()
    mock.post(url, (req, res) => {
      assert.equal(req.body(), JSON.stringify({ foo: 'bar' }))
      return res.status(200).header('Content-Type', 'application/json')
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http.post(url, { foo: 'bar' }).then(path.success)
            },
            {
              success: [() => done()],
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
  })
  it('should create PUT requests with body', (done) => {
    const url = createUrl()
    mock.put(url, (req, res) => {
      assert.equal(req.body(), JSON.stringify({ foo: 'bar' }))
      return res.status(200).header('Content-Type', 'application/json')
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http.put(url, { foo: 'bar' }).then(path.success)
            },
            {
              success: [() => done()],
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
  })
  it('should create PATCH requests with body', (done) => {
    const url = createUrl()
    mock.patch(url, (req, res) => {
      assert.equal(req.body(), JSON.stringify({ foo: 'bar' }))
      return res.status(200).header('Content-Type', 'application/json')
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http.patch(url, { foo: 'bar' }).then(path.success)
            },
            {
              success: [() => done()],
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
  })
  it('should create DELETE requests', (done) => {
    const url = createUrl()
    mock.delete(url, (req, res) => {
      assert.ok(true)
      return res.status(200).header('Content-Type', 'application/json')
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http.delete(url).then(path.success)
            },
            {
              success: [() => done()],
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
  })
  it('should handle error requests', (done) => {
    const url = createUrl()
    mock.get(url, (req, res) => {
      return res.status(500).header('Content-Type', 'application/json')
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http
                .get(url)
                .then(path.success)
                .catch((error) => path.error({ error }))
            },
            {
              success: [],
              error: [
                ({ props }) => {
                  assert.equal(props.error.response.status, 500)
                  done()
                },
              ],
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
  })
  it('should handle timeout as an option', (done) => {
    const url = createUrl()
    mock.get(url, (req, res) => {
      return new Promise(() => {})
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http
                .get(url, null, { timeout: 10 })
                .then(path.success)
                .catch((error) => path.error({ error }))
            },
            {
              success: [],
              error: [
                ({ props }) => {
                  assert.equal(props.error.message, 'request timeout')
                  done()
                },
              ],
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
  })
  it('should abort request', (done) => {
    const url = createUrl()
    mock.get(url, (req, res) => {
      return res.timeout(500)
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http.get(url).catch((error) => {
                assert.ok(error.type === 'abort')
                return path.aborted()
              })
            },
            {
              aborted: [() => done()],
            },
          ],
          test2: [
            ({ http }) => {
              http.abort('/items')
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
    controller.getSignal('test2')()
  })
  it('should expose factories to do requests', (done) => {
    const baseUrl = createUrl()
    mock.get(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })
    mock.post(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })
    mock.put(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })
    mock.patch(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })
    mock.delete(`${baseUrl}/1`, (req, res) => {
      return res.status(200).header('Content-Type', 'application/json')
    })

    let responseCount = 0
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            httpGet(string`${baseUrl}/${props`itemId`}`),
            {
              success: [
                () => {
                  responseCount++
                },
              ],
            },
            httpPost(string`${baseUrl}/${props`itemId`}`),
            {
              success: [
                () => {
                  responseCount++
                },
              ],
            },
            httpPut(string`${baseUrl}/${props`itemId`}`),
            {
              success: [
                () => {
                  responseCount++
                },
              ],
            },
            httpPatch(string`${baseUrl}/${props`itemId`}`),
            {
              success: [
                () => {
                  responseCount++
                },
              ],
            },
            httpDelete(string`${baseUrl}/${props`itemId`}`),
            {
              success: [
                () => {
                  responseCount++
                },
              ],
            },
            () => {
              assert.equal(responseCount, 5)
              done()
            },
          ],
        },
      })
    )
    controller.getSignal('test')({
      itemId: 1,
    })
  })
  it('should allow factories to accept tags in props data', (done) => {
    const mockResponse = (req, res) => {
      assert.equal(req.body(), JSON.stringify({ data: 1 }))
      return res.status(200).header('Content-Type', 'application/json')
    }

    const urlA = createUrl()
    const urlB = createUrl()
    const urlC = createUrl()
    mock.post(urlA, mockResponse)
    mock.put(urlB, mockResponse)
    mock.patch(urlC, mockResponse)

    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            httpPost(urlA, resolveObject({ data: props`data` })),
            {
              success: [],
            },
            httpPut(urlB, resolveObject({ data: props`data` })),
            {
              success: [],
            },
            httpPatch(urlC, resolveObject({ data: props`data` })),
            {
              success: [],
            },
            () => {
              done()
            },
          ],
        },
      })
    )
    controller.getSignal('test')({
      data: 1,
    })
  })
  it('should call status code paths', (done) => {
    const url = createUrl()
    mock.get(url, (req, res) => {
      return res.status(201).header('Content-Type', 'application/json')
    })

    let responseCount = 0
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            httpGet(url),
            {
              '201': [
                () => {
                  responseCount++
                },
              ],
            },
            () => {
              assert.equal(responseCount, 1)
              done()
            },
          ],
        },
      })
    )
    controller.getSignal('test')()
  })
  it('should abort request with operator', (done) => {
    mock.get('/items', (req, res) => {
      return res.timeout(500)
    })
    const controller = Controller(
      Module({
        providers: { http: HttpProvider() },
        signals: {
          test: [
            ({ http, path }) => {
              return http.get('/items').catch((error) => {
                assert.ok(error.type === 'abort')
                return path.aborted()
              })
            },
            {
              aborted: [() => done()],
            },
          ],
          test2: [httpAbort('/items')],
        },
      })
    )
    controller.getSignal('test')()
    controller.getSignal('test2')()
  })
})
