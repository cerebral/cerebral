import { InfernoChildren, VNode, Component } from 'inferno'
/* eslint-disable-next-line no-unused-vars */
import { BaseControllerClass, Sequence } from 'cerebral'

// TODO: Replace these type with Inferno JSX support
type ComponentState = {}
type Validator<T> = (
  object: T,
  key: string,
  componentName: string,
  ...rest: any[]
) => Error | null
type ValidationMap<T> = { [K in keyof T]?: Validator<T> }

interface ComponentClass<P = {}> {
  new (props?: P, context?: any): Component<P, ComponentState>
  propTypes?: ValidationMap<P>
  contextTypes?: ValidationMap<any>
  childContextTypes?: ValidationMap<any>
  defaultProps?: Partial<P>
  displayName?: string
}

interface InfernoJSXElement<P> extends VNode {}
interface StatelessComponent<P = {}> {
  (props: P & { children?: InfernoChildren }, context?: any): InfernoJSXElement<
    any
  > | null
  propTypes?: ValidationMap<P>
  contextTypes?: ValidationMap<any>
  defaultProps?: Partial<P>
  displayName?: string
}

type ComponentType<P = {}> = ComponentClass<P> | StatelessComponent<P>

declare global {
  namespace JSX {
    interface Element extends InfernoJSXElement<any> {}

    interface IntrinsicElements {
      [elemName: string]: any
    }
  }
}

// TODO: expose SignalsMap from cerebral
interface SignalsMap {
  [signalName: string]: Sequence
}

export const StateContainer: ComponentClass<{ state: any; signals: SignalsMap }>
export const Container: ComponentClass<{ controller: BaseControllerClass }>

/* eslint-disable-next-line no-unused-vars */
type PropsMap<T> = {
  [P in keyof T]: any // TODO: use correct type than Tag<any>
}

// Props are signal/state props, EProps are external props
export function connect<Props, EProps = {}>(
  props: Props,
  comp: ComponentType<PropsMap<Props> & EProps>
): ComponentClass<EProps>
