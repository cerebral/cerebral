import { dependencyMatch } from 'cerebral/internal'

function compatConfig(config, prev = '') {
  return [].concat(
    ...Object.keys(config).map((key) => {
      const conf = config[key]
      if (typeof conf === 'string') {
        return [{ path: prev + key, sequence: conf }]
      }
      return compatConfig(conf, prev + key)
    })
  )
}

export function flattenConfig(config, prev = '') {
  if (!Array.isArray(config)) {
    config = compatConfig(config)
  }
  return config.reduce((flattened, { path, routes, sequence }) => {
    if (routes) {
      Object.assign(flattened, flattenConfig(routes, prev + path))
    }

    const currentPath = prev + path
    const conf = { sequence }

    flattened[currentPath] = conf

    return flattened
  }, {})
}

export function getRoutesBySignal(config, context) {
  return Object.keys(config).reduce((routableSignals, route) => {
    const { sequence } = config[route]
    const sequencePath =
      typeof sequence === 'string' ? sequence : sequence.getPath(context)

    if (!sequencePath) {
      return routableSignals
    }

    if (routableSignals[sequencePath]) {
      throw new Error(
        `Cerebral router - The signal ${sequencePath} has already been bound to route ${route}. Create a new signal and reuse actions instead if needed.`
      )
    }
    routableSignals[sequencePath] = route

    return routableSignals
  }, {})
}

export function hasChangedPath(changes, path) {
  for (let change in changes) {
    if (changes[change].path.join('.') === path) {
      return true
    }
  }
}

export function computeShouldChange(tracker, changed) {
  return dependencyMatch(changed, tracker.stateTrackMap).length > 0
}

function ensureBaseUrl(url) {
  if (!url) {
    return ''
  }

  return url[0] === '/' ? url : '/' + url
}

export function verifyOptions(options) {
  return Object.assign(options, {
    baseUrl: ensureBaseUrl(options.baseUrl),
  })
}
