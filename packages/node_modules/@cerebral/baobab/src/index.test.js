/* eslint-env mocha */
import BaobabModel from './'
import assert from 'assert'
import { Controller, Module } from 'cerebral'

describe('Model', () => {
  it('should instantiate with initial state', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule, {
      Model: new BaobabModel(),
    })
    assert.equal(controller.model.get(['foo']), 'bar')
  })
  it('should grab nested state', () => {
    const rootModule = Module({
      state: {
        foo: {
          bar: 'value',
        },
      },
    })
    const controller = Controller(rootModule, {
      Model: new BaobabModel(),
    })
    assert.equal(controller.getState('foo.bar'), 'value')
  })
  it('should be able to flush changed paths', () => {
    const rootModule = Module({
      state: {
        foo: {
          bar: 'value',
        },
      },
    })
    const controller = Controller(rootModule, {
      Model: new BaobabModel(),
    })
    controller.model.set(['foo', 'bar'], 'value2')
    assert.deepEqual(controller.model.flush(), [
      {
        path: ['foo', 'bar'],
        forceChildPathUpdates: true,
      },
    ])
  })
  it('should flush same path changes correctly', () => {
    const rootModule = Module({
      state: {
        foo: {
          bar: 'value',
        },
      },
    })
    const controller = Controller(rootModule, {
      Model: new BaobabModel(),
    })
    controller.model.set(['foo', 'bar'], 'value2')
    controller.model.set(['foo', 'bar'], 'value3')
    assert.deepEqual(controller.model.flush(), [
      {
        path: ['foo', 'bar'],
        forceChildPathUpdates: true,
      },
      {
        path: ['foo', 'bar'],
        forceChildPathUpdates: true,
      },
    ])
  })
  describe('SET', () => {
    it('should be able to set state', () => {
      const rootModule = Module({
        state: {},
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.set(['foo'], 'bar')
      assert.deepEqual(controller.getState(), { foo: 'bar' })
    })
  })
  describe('TOGGLE', () => {
    it('should be able to toggle value', () => {
      const rootModule = Module({
        state: {
          foo: true,
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.toggle(['foo'])
      assert.deepEqual(controller.getState(), { foo: false })
    })
  })
  describe('PUSH', () => {
    it('should be able to push to array', () => {
      const rootModule = Module({
        state: {
          list: [],
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.push(['list'], 'bar')
      assert.deepEqual(controller.getState(), { list: ['bar'] })
    })
  })
  describe('MERGE', () => {
    it('should be able to merge objects', () => {
      const rootModule = Module({
        state: {
          foo: {
            valA: 'foo',
          },
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.merge(['foo'], { valB: 'bar' })
      assert.deepEqual(controller.getState(), {
        foo: { valA: 'foo', valB: 'bar' },
      })
    })
    it('should flush changes to merged keys when object exists', () => {
      const rootModule = Module({
        state: {
          foo: {
            valA: 'foo',
          },
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.merge(['foo'], { valB: 'bar' })
      assert.deepEqual(controller.model.flush(), [
        {
          path: ['foo', 'valB'],
          forceChildPathUpdates: true,
        },
      ])
    })
  })
  describe('POP', () => {
    it('should be able to pop arrays', () => {
      const rootModule = Module({
        state: {
          list: ['foo', 'bar'],
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.pop(['list'])
      assert.deepEqual(controller.getState(), { list: ['foo'] })
    })
  })
  describe('SHIFT', () => {
    it('should be able to shift arrays', () => {
      const rootModule = Module({
        state: {
          list: ['foo', 'bar'],
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.shift(['list'])
      assert.deepEqual(controller.getState(), { list: ['bar'] })
    })
  })
  describe('UNSHIFT', () => {
    it('should be able to unshift arrays', () => {
      const rootModule = Module({
        state: {
          list: ['foo'],
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.unshift(['list'], 'bar')
      assert.deepEqual(controller.getState(), { list: ['bar', 'foo'] })
    })
  })
  describe('SPLICE', () => {
    it('should be able to splice arrays', () => {
      const rootModule = Module({
        state: {
          list: ['foo', 'bar'],
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.splice(['list'], 1, 1, 'bar2')
      assert.deepEqual(controller.getState(), { list: ['foo', 'bar2'] })
    })
  })
  describe('UNSET', () => {
    it('should be able to unset keys', () => {
      const rootModule = Module({
        state: {
          foo: 'bar',
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.unset(['foo'])
      assert.deepEqual(controller.getState(), {})
    })
    it('should flush unset paths', () => {
      const rootModule = Module({
        state: {
          foo: {
            bar: 'value',
          },
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.unset(['foo', 'bar'])
      assert.deepEqual(controller.model.flush(), [
        {
          path: ['foo', 'bar'],
          forceChildPathUpdates: true,
        },
      ])
    })
  })
  describe('CONCAT', () => {
    it('should be able to concat array', () => {
      const rootModule = Module({
        state: {
          foo: ['foo'],
        },
      })
      const controller = Controller(rootModule, {
        Model: new BaobabModel(),
      })
      controller.model.concat(['foo'], ['bar'])
      assert.deepEqual(controller.getState(), { foo: ['foo', 'bar'] })
    })
  })
})
