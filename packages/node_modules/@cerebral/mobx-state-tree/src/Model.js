import {
  forceSerializable,
  isSerializable,
  throwError,
  BaseModel,
} from 'cerebral/internal'
import { types } from 'mobx-state-tree'
import { ObservableMap } from 'mobx'

function reduceModels(module, model) {
  return Object.keys(module.modules || {}).reduce((currentModel, key) => {
    return types.compose(
      currentModel,
      types.model({
        [key]: reduceModels(module.modules[key], module.modules[key].model),
      })
    )
  }, model || types.model({}))
}

class Model extends BaseModel {
  constructor(controller) {
    super(controller)
    const mobxModel = reduceModels(controller.module, controller.module.model)

    this.state = mobxModel
      .actions(() => ({
        runInBatch(fn) {
          fn()
        },
      }))
      .create(this.initialState)
  }
  updateIn(path, cb, forceChildPathUpdates = false) {
    if (!path.length) {
      cb(this.state, this, 'state')

      return
    }

    this.state.runInBatch(() => {
      path.reduce((currentState, key, index) => {
        if (index === path.length - 1) {
          const currentValue =
            currentState instanceof ObservableMap
              ? currentState.get(key)
              : currentState[key]

          cb(currentValue, currentState, key)
        } else if (
          !(currentState instanceof ObservableMap
            ? currentState.get(key)
            : currentState[key])
        ) {
          throwError(
            `The path "${path.join(
              '.'
            )}" is invalid, can not update state. Does the path "${path
              .splice(0, path.length - 1)
              .join('.')}" exist?`
          )
        }

        return currentState instanceof ObservableMap
          ? currentState.get(key)
          : currentState[key]
      }, this.state)
    })
  }
  /*
    Checks if value is serializable, if turned on
  */
  verifyValue(value, path) {
    if (this.devtools && !isSerializable(value, this.devtools.allowedTypes)) {
      throwError(
        `You are passing a non serializable value into the state tree on path "${path.join(
          '.'
        )}"`
      )
    }
    if (this.devtools) {
      forceSerializable(value)
    }
  }
  verifyValues(values, path) {
    if (this.devtools) {
      values.forEach((value) => {
        this.verifyValue(value, path)
      })
    }
  }
  get(path = []) {
    return path.reduce((currentState, key) => {
      return currentState instanceof ObservableMap
        ? currentState.get(key)
        : currentState ? currentState[key] : undefined
    }, this.state)
  }
  set(path, value) {
    this.verifyValue(value, path)
    this.updateIn(
      path,
      (_, parent, key) => {
        if (parent instanceof ObservableMap) {
          parent.set(key, value)
        } else {
          parent[key] = value
        }
      },
      true
    )
  }
  toggle(path) {
    this.updateIn(path, (value, parent, key) => {
      parent[key] = !value
    })
  }
  increment(path, incrementBy = 1) {
    this.updateIn(path, (value, parent, key) => {
      parent[key] = parent[key] + incrementBy
    })
  }
  push(path, value) {
    this.verifyValue(value, path)
    this.updateIn(path, (array) => {
      array.push(value)
    })
  }
  merge(path, ...values) {
    const value = Object.assign(...values)

    // If we already have an object we make it behave
    // like multiple sets, indicating a change to very key.
    // If no value it should indicate that we are setting
    // a new object
    if (this.get(path)) {
      for (let prop in value) {
        this.set(path.concat(prop), value[prop])
      }
    } else {
      this.set(path, value)
    }
  }
  pop(path) {
    this.updateIn(path, (array) => {
      array.pop()
    })
  }
  shift(path) {
    this.updateIn(path, (array) => {
      array.shift()
    })
  }
  unshift(path, value) {
    this.verifyValue(value, path)
    this.updateIn(path, (array) => {
      array.unshift(value)
    })
  }
  splice(path, ...args) {
    this.verifyValues(args, path)
    this.updateIn(path, (array) => {
      array.splice(...args)
    })
  }
  unset(path) {
    this.updateIn(
      path,
      (_, parent, key) => {
        if (parent instanceof ObservableMap) {
          parent.delete(key)
        } else {
          delete parent[key]
        }
      },
      true
    )
  }
  concat(path, value) {
    this.verifyValue(value, path)
    this.updateIn(path, (array, parent, key) => {
      parent[key] = array.concat(value)
    })
  }
}

export default Model
