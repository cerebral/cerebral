import { ensurePath, cleanPath, throwError } from 'cerebral/lib/utils'

function StateProviderFactory(devtools) {
  const methods = [
    'get',
    'set',
    'toggle',
    'push',
    'merge',
    'pop',
    'shift',
    'unshift',
    'splice',
    'unset',
    'concat',
  ]
  let provider = null

  function createProvider(context) {
    const model = context.controller.model

    return methods.reduce((currentStateContext, methodKey) => {
      currentStateContext[methodKey] = (...args) => {
        const path = ensurePath(cleanPath(args.shift()))

        if (methodKey === 'get') {
          return model.get(path)
        }

        return model[methodKey].apply(model, [path].concat(args))
      }

      return currentStateContext
    }, {})
  }

  function StateProvider(context, functionDetails) {
    context.state = provider = provider || createProvider(context)

    if (context.debugger) {
      context.state = methods.reduce((currentState, methodKey) => {
        if (methodKey === 'get' || methodKey === 'compute') {
          currentState[methodKey] = provider[methodKey]
        } else {
          const originFunc = provider[methodKey]

          currentState[methodKey] = (...args) => {
            const argsCopy = args.slice()
            const path = ensurePath(argsCopy.shift())

            context.debugger.send({
              datetime: Date.now(),
              type: 'mutation',
              color: '#333',
              method: methodKey,
              args: [path, ...argsCopy],
            })

            try {
              originFunc.apply(context.controller.model, args)
            } catch (e) {
              const signalName = context.execution.name
              throwError(
                `The Signal "${signalName}" with action "${functionDetails.name}" has an error: ${e.message}`
              )
            }
          }
        }

        return currentState
      }, {})
    }

    return context
  }

  return StateProvider
}

export default StateProviderFactory
