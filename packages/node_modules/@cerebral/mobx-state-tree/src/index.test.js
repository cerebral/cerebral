/* eslint-env mocha */
import { Controller, Module } from './'
import { set } from 'cerebral/operators'
import { state } from 'cerebral/tags'
import { types } from 'mobx-state-tree'
import assert from 'assert'

describe('MobxController', () => {
  it('should instantiate with initial state', () => {
    const rootModule = Module({
      model: {
        foo: types.string,
      },
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)

    assert.deepEqual(controller.provide().store.toJSON(), { foo: 'bar' })
  })
  it('should throw when changing state directly', () => {
    const rootModule = Module({
      model: {
        foo: types.string,
      },
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)

    assert.throws(() => {
      controller.provide().store.foo = 'bar2'
    })
  })
  it('should allow changing state through signals', () => {
    const rootModule = Module({
      model: {
        foo: types.string,
      },
      state: {
        foo: 'bar',
      },
      signals: {
        test: set(state`foo`, 'bar2'),
      },
    })
    const controller = Controller(rootModule)

    controller.provide().signals.test()
    assert.equal(controller.provide().store.foo, 'bar2')
  })
  it('should provide store and signals', () => {
    const rootModule = Module({
      model: {
        foo: types.string,
      },
      state: {
        foo: 'bar',
      },
      signals: {
        test: set(state`foo`, 'bar2'),
      },
    })
    const controller = Controller(rootModule)

    assert.ok(typeof controller.provide().signals.test === 'function')
    assert.equal(controller.provide().store.foo, 'bar')
  })
  it('should allow getters', () => {
    const rootModule = Module({
      model: {
        foo: types.string,
      },
      state: {
        foo: 'bar',
      },
      getters: {
        upper() {
          return this.foo.toUpperCase()
        },
      },
    })
    const controller = Controller(rootModule)

    assert.equal(controller.provide().store.upper, 'BAR')
  })
  it('should allow computed', () => {
    const rootModule = Module({
      model: {
        foo: types.string,
      },
      state: {
        foo: 'bar',
      },
      computed: {
        add(something) {
          return this.foo + something
        },
      },
    })
    const controller = Controller(rootModule)

    assert.equal(controller.provide().store.add('baz'), 'barbaz')
  })
})
