/* eslint-env mocha */
import { Controller, Module } from './'
import { set } from 'cerebral/operators'
import { state } from 'cerebral/tags'
import { types } from 'mobx-state-tree'
import assert from 'assert'

describe('MobxController', () => {
  it('should instantiate with initial state', () => {
    const rootModule = Module({
      model: types.model({
        foo: types.string,
      }),
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)

    assert.deepEqual(controller.provide().store.toJSON(), { foo: 'bar' })
  })
  it('should handle nested modules', () => {
    const rootModule = Module({
      model: types.model({
        foo: types.string,
      }),
      state: {
        foo: 'bar',
      },
      modules: {
        bar: Module({
          model: types.model({
            baz: types.string,
          }),
          state: {
            baz: 'baz',
          },
        }),
      },
    })
    const controller = Controller(rootModule)

    assert.deepEqual(controller.provide().store.toJSON(), {
      foo: 'bar',
      bar: { baz: 'baz' },
    })
  })
  it('should throw when changing state directly', () => {
    const rootModule = Module({
      model: types.model({
        foo: types.string,
      }),
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)

    assert.throws(() => {
      controller.provide().store.foo = 'bar2'
    })
  })
  it('should allow changing state through signals', () => {
    const rootModule = Module({
      model: types.model({
        foo: types.string,
      }),
      state: {
        foo: 'bar',
      },
      signals: {
        test: set(state`foo`, 'bar2'),
      },
    })
    const controller = Controller(rootModule)

    controller.provide().signals.test()
    assert.equal(controller.provide().store.foo, 'bar2')
  })
  it('should provide store and signals', () => {
    const rootModule = Module({
      model: types.model({
        foo: types.string,
      }),
      state: {
        foo: 'bar',
      },
      signals: {
        test: set(state`foo`, 'bar2'),
      },
    })
    const controller = Controller(rootModule)

    assert.ok(typeof controller.provide().signals.test === 'function')
    assert.equal(controller.provide().store.foo, 'bar')
  })
  it('should allow views', () => {
    const rootModule = Module({
      model: types
        .model({
          foo: types.string,
        })
        .views((self) => ({
          get upper() {
            return self.foo.toUpperCase()
          },
        })),
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)

    assert.equal(controller.provide().store.upper, 'BAR')
  })
})
