/* eslint-env mocha */
/* eslint-disable no-global-assign */
/* eslint-disable no-new */
import View from './View'
import { Controller, Module, Compute } from './'
import { state, props, module, signal, signals, computed } from './tags'
import { set } from './operators'
import assert from 'assert'

describe.only('View', () => {
  it('should throw an error if no dependencies provided', () => {
    assert.throws(
      () => {
        new View({
          dependencies: undefined,
        })
      },
      (err) => {
        if (err instanceof Error) {
          return (
            err.message ===
            'Cerebral - There is no reason to connect a component that has no dependencies'
          )
        }
      }
    )
  })
  it('should throw an error if dependency is a function', () => {
    assert.throws(
      () => {
        new View({
          dependencies: () => {},
        })
      },
      (err) => {
        if (err instanceof Error) {
          return (
            err.message ===
            'Cerebral - You can not use a function to define dependencies. Use tags or a function on the specific property you want to dynamically create'
          )
        }
      }
    )
  })
  it('should throw an error if dependency item is not tag', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)
    assert.throws(
      () => {
        new View({
          dependencies: {
            foo: () => {},
          },
          controller,
        })
      },
      (err) => {
        if (err instanceof Error) {
          return err.message === "Cerebral - Prop 'foo' should be a tag"
        }
      }
    )
  })
  it('should return undefined when signal is not defined', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
        fooCalled: signal`fooCalled`,
      },
      controller,
      displayName: 'Test',
    })
    const componentProps = view.getProps()
    assert.equal(componentProps.fooCalled, undefined)
  })
  it('should warn if component has more dependencies than devtools configuration', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.equal(
        args[0],
        'Component named Test has a lot of dependencies, consider refactoring or adjust this option in devtools'
      )
      originWarn.apply(this, args)
    }

    const rootModule = Module({
      state: {
        foo: 'foo',
        bar: 'bar',
      },
      signals: {
        fooCalled: [],
      },
    })
    const controller = Controller(rootModule, {
      devtools: {
        bigComponentsWarning: 2,
        init() {},
        send() {},
        updateComponentsMap() {},
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
        fooCalled: signal`fooCalled`,
      },
      controller,
      displayName: 'Test',
    })
    view.getProps()
    assert.equal(view._hasWarnedBigComponent, true)
    assert.equal(warnCount, 1)
    console.warn = originWarn
  })
  it('should be able to extract state', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
    })
    assert.deepEqual(view.controller.getState(), { foo: 'bar' })
    const componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar')
  })
  it('should be able to extract signals', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      signals: {
        someSignal: [],
      },
      modules: {
        someModule: Module({
          signals: {
            moduleSignal: [],
          },
        }),
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
        signal: signal`someSignal`,
        moduleSignals: signals`someModule`,
      },
      controller,
    })
    const componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar')
    assert.ok(typeof componentProps.signal === 'function')
    assert.ok(typeof componentProps.moduleSignals.moduleSignal === 'function')
  })
  it('should allow props tag', () => {
    const rootModule = Module({
      state: {
        foo: {
          baz: 'mip',
        },
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        a: props`foo`,
        b: props`bar.id`,
        c: state`foo.${props`propKey`}`,
      },
      controller,
      props: {
        foo: 'bar',
        bar: { id: '1' },
        propKey: 'baz',
      },
    })
    const componentProps = view.getProps({
      foo: 'bar',
      bar: { id: '1' },
      propKey: 'baz',
    })
    assert.equal(componentProps.a, 'bar')
    assert.equal(componentProps.b, '1')
    assert.equal(componentProps.c, 'mip')
  })
  it('should be able to dynamically define signals', () => {
    const rootModule = Module({
      state: {
        test: '',
      },
      signals: {
        foo: [({ state }) => state.set('test', 'fooSignal')],
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        signal: signal`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })

    let componentProps = view.getProps({
      path: 'foo',
    })
    componentProps.signal()
    assert.equal(controller.getModel().get(['test']), 'fooSignal')
  })
  it('should be able to adjust props with function (mergeProps)', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      signals: {
        foo: [],
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
        fooSignal: signal`foo`,
      },
      mergeProps: (depsProps, ownProps, resolve) => {
        assert.equal(depsProps.foo, 'bar')
        assert.equal(typeof depsProps.fooSignal, 'function')
        assert.deepEqual(ownProps, { mip: 'mop' })
        assert.equal(resolve.path(state`foo`), 'foo')
        assert.equal(resolve.value(state`foo`), 'bar')

        return { bar: depsProps.foo + ownProps.mip }
      },
      props: {
        mip: 'mop',
      },
      controller,
    })
    let componentProps = view.getProps({
      mip: 'mop',
    })
    assert.equal(componentProps.bar, 'barmop')
    assert.equal(componentProps.foo, undefined)
    assert.equal(componentProps.fooSignal, undefined)
  })
  it('should mount correctly', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
      displayName: 'Test',
      onUpdate: function() {},
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
    assert.equal(typeof view.onUpdate, 'function')
  })
  it('should update devtools components map and add entity to controller dependency store when mounting', () => {
    let devtoolsUpdateComponentsMapCalled = 0
    let dependencyStoreAddEntityCalled = 0
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateComponentsMap(component, nextDeps, prevDeps) {
          assert.deepEqual(nextDeps, { foo: true })
          assert.equal(prevDeps, undefined)
          assert.equal(component._displayName, 'Test')
          devtoolsUpdateComponentsMapCalled++
        },
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        path: props`path`,
      },
      props: { path: 'foo' },
      controller,
      displayName: 'Test',
    })
    view.controller.dependencyStore.addEntity = function(component, depsMap) {
      assert.deepEqual(depsMap, { foo: true })
      assert.equal(component._displayName, 'Test')
      dependencyStoreAddEntityCalled++
    }
    view.mount()
    assert.equal(devtoolsUpdateComponentsMapCalled, 1)
    assert.equal(dependencyStoreAddEntityCalled, 1)
  })
  it('should update devtools components map and remove entity from controller dependency store when unmounting', () => {
    let devtoolsUpdateComponentsMapCalled = 0
    let dependencyStoreRemoveEntityCalled = 0
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateComponentsMap(component, nextDeps, prevDeps) {
          assert.deepEqual(nextDeps, { foo: true })
          assert.equal(prevDeps, undefined)
          assert.equal(component._displayName, 'Test')
          devtoolsUpdateComponentsMapCalled++
        },
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        path: props`path`,
      },
      props: { path: 'foo' },
      controller,
      displayName: 'Test',
    })
    view.mount()
    view.controller.dependencyStore.removeEntity = function(
      component,
      depsMap
    ) {
      assert.deepEqual(depsMap, { foo: true })
      assert.equal(component._displayName, 'Test')
      dependencyStoreRemoveEntityCalled++
    }
    view.controller.devtools.updateComponentsMap = function(
      component,
      nextDeps,
      prevDeps
    ) {
      assert.deepEqual(prevDeps, { foo: true })
      assert.equal(nextDeps, null)
      assert.equal(component._displayName, 'Test')
      devtoolsUpdateComponentsMapCalled++
    }
    view.unMount()
    assert.equal(devtoolsUpdateComponentsMapCalled, 2)
    assert.equal(dependencyStoreRemoveEntityCalled, 1)
  })
  it('should update tags', () => {
    let renderCount = 0
    const rootModule = Module({
      state: {
        list: {
          0: 'foo',
          1: 'bar',
        },
        currentItem: '0',
      },
      signals: {
        test: [
          ({ state }) => {
            state.set('currentItem', '1')
          },
        ],
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`list.${state`currentItem`}`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['currentItem'])
        assert.equal(force, undefined)
        view.updateFromState(stateChanges, null, force)
        assert.deepEqual(view.tagsDependencyMap, {
          'list.1': true,
          currentItem: true,
        })
        renderCount++
      },
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, {
      'list.0': true,
      currentItem: true,
    })
    let componentProps = view.getProps()
    assert.equal(componentProps.foo, 'foo')
    view.controller.getSignal('test')()
    componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar')
    assert.equal(renderCount, 1)
  })
  it('should update on props change', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
    const hasUpdate = view.onPropsUpdate(
      {
        path: 'foo',
      },
      {
        path: 'bar',
      }
    )
    assert.equal(hasUpdate, true)
    assert.deepEqual(view.tagsDependencyMap, { bar: true })
  })
  it('should not update when there is no props change', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
    const hasUpdate = view.onPropsUpdate(
      {
        path: 'foo',
      },
      {
        path: 'foo',
      }
    )
    assert.equal(hasUpdate, false)
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
  })
  it('should rerender on state update', () => {
    let renderCount = 0
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      signals: {
        methodCalled: [({ state }) => state.set('foo', 'bar2')],
      },
    })
    const controller = Controller(rootModule)

    const view = new View({
      dependencies: {
        foo: state`foo`,
        methodCalled: signal`methodCalled`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['foo'])
        assert.equal(force, undefined)
        view.updateFromState(stateChanges, null, force)
        renderCount++
      },
    })
    view.mount()
    assert.equal(renderCount, 0)
    let componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar')
    componentProps.methodCalled()
    componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar2')
    assert.equal(renderCount, 1)
  })
  it('should render only ones where multiple state changes', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
        bar: 'foo',
      },
      signals: {
        test: [
          ({ state }) => {
            state.set('foo', 'bar2')
            state.set('bar', 'foo2')
          },
        ],
      },
    })
    const controller = Controller(rootModule)
    let renderCount = 0
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 2)
        assert.deepEqual(stateChanges[0].path, ['foo'])
        assert.deepEqual(stateChanges[1].path, ['bar'])
        assert.equal(force, undefined)
        renderCount++
      },
    })
    view.mount()
    assert.equal(renderCount, 0)
    controller.getSignal('test')()
    assert.equal(renderCount, 1)
  })
  it.only('should rerender when controller flush method called with force option', () => {
    let renderCount = 0
    const computedFoo = Compute({
      foo: state`foo`,
    })(({ foo }) => foo)
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        computedFoo,
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: computed`computedFoo`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 0)
        assert.equal(force, true)
        view.updateFromState(stateChanges, null, force)
        renderCount++
      },
    })
    view.mount()
    view.getProps()
    assert.equal(renderCount, 0)
    view.controller.flush(true)
    assert.equal(renderCount, 1)
  })
  it('should rerender on parent dep replacement', () => {
    let renderCount = 0
    const rootModule = Module({
      state: {
        foo: {
          bar: 'baz',
        },
      },
      signals: {
        methodCalled: [({ state }) => state.set('foo', { bar: 'baz2' })],
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo.bar`,
        methodCalled: signal`methodCalled`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['foo'])
        assert.equal(force, undefined)
        renderCount++
      },
    })
    view.mount()
    assert.equal(renderCount, 0)
    let componentProps = view.getProps()
    assert.equal(componentProps.foo, 'baz')
    componentProps.methodCalled()
    componentProps = view.getProps()
    assert.equal(componentProps.foo, 'baz2')
    assert.equal(renderCount, 1)
  })
  it('should only rerender affected components', () => {
    let renderCountView1 = 0
    let renderCountView2 = 0
    const rootModule = Module({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
      signals: {
        methodCalled: [({ state }) => state.set('foo', 'bar2')],
      },
    })
    const controller = Controller(rootModule)
    const view1 = new View({
      dependencies: {
        bar: state`bar`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        renderCountView1++
      },
    })
    view1.mount()
    const view2 = new View({
      dependencies: {
        foo: state`foo`,
        methodCalled: signal`methodCalled`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['foo'])
        assert.equal(force, undefined)
        renderCountView2++
      },
    })
    view2.mount()
    assert.equal(renderCountView1, 0)
    assert.equal(renderCountView2, 0)
    controller.getSignal('methodCalled')()
    assert.equal(renderCountView1, 0)
    assert.equal(renderCountView2, 1)
  })
  describe('STRICT render update', () => {
    it('should update when parent path changes', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {
          foo: {
            bar: 'baz',
          },
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo', 'bar2')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo.bar`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      let componentProps = view.getProps()
      assert.equal(componentProps.foo, 'baz')
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo, undefined)
      assert.equal(renderCount, 1)
    })

    it('should return array', () => {
      const rootModule = Module({
        state: {
          map: '',
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo.*`,
        },
        controller,
      })
      view.mount()
      let componentProps = view.getProps()
      assert.deepEqual(componentProps.foo, [])
      assert.deepEqual(view.tagsDependencyMap, { 'foo.*': true })
    })

    it('should be able to override immediate child interest', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {
          foo: [
            {
              bar: 'baz',
            },
          ],
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo.0.bar', 'baz2')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo.*`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      let componentProps = view.getProps()
      assert.equal(componentProps.foo[0], '0')
      assert.deepEqual(view.tagsDependencyMap, { 'foo.*': true })
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo[0], '0')
      assert.equal(renderCount, 0)
    })

    it('should by default update when nested children update', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {
          foo: {
            bar: {
              baz: 'value',
            },
          },
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo.bar.baz', 'value2')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo', 'bar', 'baz'])
          assert.equal(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, { 'foo.**': true })
      let componentProps = view.getProps()
      assert.equal(componentProps.foo.bar.baz, 'value')
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo.bar.baz, 'value2')
      assert.equal(renderCount, 1)
    })

    it('should update when undefined path becoming defined', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {},
        signals: {
          methodCalled: [({ state }) => state.set('foo.bar.baz', 'value2')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo.bar.baz`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo', 'bar', 'baz'])
          assert.equal(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, { 'foo.bar.baz': true })
      let componentProps = view.getProps()
      assert.equal(componentProps.foo, undefined)
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo, 'value2')
      assert.equal(renderCount, 1)
    })

    it('should update when undefined path becoming defined deeply', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {},
        signals: {
          methodCalled: [set(state`scope.scopeid.user.userid`, 'bong')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          user: state`scope.scopeid.user.**`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, [
            'scope',
            'scopeid',
            'user',
            'userid',
          ])
          assert.equal(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, {
        'scope.scopeid.user.**': true,
      })
      let componentProps = view.getProps()
      assert.deepEqual(componentProps.user, undefined)
      componentProps.methodCalled()
      assert.equal(renderCount, 1)
      componentProps = view.getProps()
      assert.deepEqual(componentProps.user, { userid: 'bong' })
    })

    it('should by default update when nested children update with array', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {
          foo: [
            {
              bar: 'value',
            },
          ],
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo.0.bar', 'value2')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo', '0', 'bar'])
          assert.equal(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, { 'foo.**': true })
      let componentProps = view.getProps()
      assert.equal(componentProps.foo[0].bar, 'value')
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo[0].bar, 'value2')
      assert.equal(renderCount, 1)
    })

    it('should by default update when nested children update using COMPUTE', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {
          foo: {
            bar: {
              baz: 'value',
            },
          },
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo.bar.baz', 'value2')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: Compute(state`foo`)((foo) => foo),
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo', 'bar', 'baz'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.deepEqual(view.tagsDependencyMap, {})
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.equal(componentProps.foo.bar.baz, 'value')
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo.bar.baz, 'value2')
      assert.equal(renderCount, 1)
    })
  })
  describe('Compute', () => {
    it('should allow use of Compute as state dependency and access props', () => {
      const rootModule = Module({})
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: Compute()((get) => {
            return get(props`foo`) + 'baz'
          }),
        },
        props: {
          foo: 'bar',
        },
        controller,
      })
      view.mount()
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.equal(componentProps.foo, 'barbaz')
    })
    it('should have access to state through state argument', () => {
      const rootModule = Module({
        state: {
          foo: 'bar',
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: Compute()((get) => {
            return get(state`foo`)
          }),
        },
        controller,
      })
      view.mount()
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.equal(componentProps.foo, 'bar')
    })
    it('should track state', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {
          foo: 'bar',
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo', 'bar2')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: Compute()((get) => {
            return get(state`foo`)
          }),
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.deepEqual(view.tagsDependencyMap, {})
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.equal(componentProps.foo, 'bar')
      view.controller.getSignal('methodCalled')()
      componentProps = view.getProps()
      assert.equal(componentProps.foo, 'bar2')
      assert.equal(renderCount, 1)
    })
    it('should update dependency map when Compute is rerun', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {
          map: {},
        },
        signals: {
          changeState: [({ state }) => state.set('map.1', { awesome: true })],
          changeState2: [({ state }) => state.set('map.1.awesome', false)],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          foo: Compute(state`map.*`)((map, get) => {
            return map.filter((key) => {
              return get(state`map.${key}.awesome`)
            })
          }),
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['map', '1'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.deepEqual(view.tagsDependencyMap, {})
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, {})

      let componentProps = view.getProps()
      assert.deepEqual(componentProps.foo, [])

      view.controller.getSignal('changeState')()
      componentProps = view.getProps()
      assert.equal(componentProps.foo, '1')
      assert.equal(renderCount, 1)

      view.onUpdate = (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['map', '1', 'awesome'])
        assert.equal(force, undefined)
        view.updateFromState(stateChanges, null, force)
        assert.deepEqual(view.tagsDependencyMap, {})
        renderCount++
      }

      view.controller.getSignal('changeState2')()
      componentProps = view.getProps()
      assert.deepEqual(componentProps.foo, [])
      assert.equal(renderCount, 2)
    })
    it('should handle complex state changes', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {
          user: {
            projects: ['0', '1'],
          },
          projects: {
            '0': 'foo',
            '1': 'bar',
            '2': 'baz',
          },
        },
        signals: {
          changeState: [({ state }) => state.push('user.projects', '2')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          projects: Compute()((get) => {
            const projects = get(state`user.projects`)

            return projects.map((projectKey) =>
              get(state`projects.${projectKey}`)
            )
          }),
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['user', 'projects'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.deepEqual(view.tagsDependencyMap, {})
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.deepEqual(componentProps.projects, ['foo', 'bar'])
      view.controller.getSignal('changeState')()
      componentProps = view.getProps()
      assert.deepEqual(componentProps.projects, ['foo', 'bar', 'baz'])
      assert.equal(renderCount, 1)
    })
    it('should handle strict deps', () => {
      let renderCount = 0
      const rootModule = Module({
        state: {
          user: {
            projects: ['0', '1'],
          },
          projects: {
            '0': { title: '0' },
            '1': { title: '1' },
          },
        },
        signals: {
          changeState: [({ state }) => state.set('projects.1.title', 'woop')],
        },
      })
      const controller = Controller(rootModule)
      const view = new View({
        dependencies: {
          projects: Compute()((get) => {
            const projects = get(state`user.projects`)

            return projects.map((projectKey) =>
              get(state`projects.${projectKey}`)
            )
          }),
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['projects', '1', 'title'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      let componentProps = view.getProps()
      assert.deepEqual(componentProps.projects, [
        { title: '0' },
        { title: '1' },
      ])
      view.controller.getSignal('changeState')()
      componentProps = view.getProps()
      assert.deepEqual(componentProps.projects, [
        { title: '0' },
        { title: 'woop' },
      ])
      assert.equal(renderCount, 1)
    })
  })
  it('should handle props updating state deps', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
      signals: {
        changeState: [({ state }) => state.set('bar', 'baz2')],
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
    let componentProps = view.getProps({
      path: 'foo',
    })
    assert.equal(componentProps.foo, 'bar')
    view.onPropsUpdate(
      {
        path: 'foo',
      },
      {
        path: 'bar',
      }
    )
    assert.deepEqual(view.tagsDependencyMap, { bar: true })

    componentProps = view.getProps({
      path: 'bar',
    })
    assert.equal(componentProps.foo, 'baz')

    view.controller.getSignal('changeState')()

    componentProps = view.getProps({
      path: 'bar',
    })
    assert.equal(componentProps.foo, 'baz2')
  })
  it('should handle props composition updating value', () => {
    const rootModule = Module({
      state: {
        field: {
          value: '',
        },
      },
      signals: {
        changeState: [
          ({ state }) => {
            state.set('field.value', 'foo')
            state.merge('field', { mip: 'mop' })
          },
        ],
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        field: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'field',
      },
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { 'field.**': true })
    let componentProps = view.getProps({
      path: 'field',
    })
    assert.deepEqual(componentProps.field, {
      value: '',
    })

    view.controller.getSignal('changeState')()

    componentProps = view.getProps({
      path: 'field',
    })
    assert.deepEqual(componentProps.field, {
      value: 'foo',
      mip: 'mop',
    })
  })
  it('should warn if prop is from the Cerebral state tree when initializing', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.equal(
        args[0],
        'You are passing an array to the component "Test" on prop "list" which is from the Cerebral state tree. You should not do this, but rather connect it directly to this component. This will optimize the component and avoid any rerender issues.'
      )
      originWarn.apply(this, args)
    }
    const rootModule = Module({
      state: {
        foo: 'bar',
        list: [],
      },
    })
    const controller = Controller(rootModule, {
      devtools: {
        warnStateProps: true,
        preventExternalMutations: true,
        init() {},
        send() {},
        updateComponentsMap() {},
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
      props: {
        list: controller.getState('list'),
      },
      displayName: 'Test',
    })
    assert.equal(view._verifyPropsWarned, true)
    assert.equal(warnCount, 1)
    console.warn = originWarn
  })
  it('should warn if prop is from the Cerebral state tree when updating props', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.equal(
        args[0],
        'You are passing an object to the component "Test" on prop "list" which is from the Cerebral state tree. You should not do this, but rather connect it directly to this component. This will optimize the component and avoid any rerender issues.'
      )
      originWarn.apply(this, args)
    }
    const rootModule = Module({
      state: {
        foo: 'bar',
        list: {},
      },
    })
    const controller = Controller(rootModule, {
      devtools: {
        warnStateProps: true,
        preventExternalMutations: true,
        init() {},
        send() {},
        updateComponentsMap() {},
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
      props: {
        list: '',
      },
      displayName: 'Test',
    })
    view.mount()
    assert.equal(view._verifyPropsWarned, false)
    view.onPropsUpdate(
      {
        list: '',
      },
      {
        list: controller.getState('list'),
      }
    )
    assert.equal(view._verifyPropsWarned, true)
    assert.equal(warnCount, 1)
    console.warn = originWarn
  })
  it('should handle computed from controller', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
      computed: {
        test: Compute(module`foo`)((foo) => {
          return foo.toUpperCase()
        }),
      },
    })
    const controller = Controller(rootModule)
    const view = new View({
      dependencies: {
        foo: computed`test`,
        bar: state`bar`,
      },
      controller,
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { bar: true })
  })
})
