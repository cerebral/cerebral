import { moduleState, props, state, sequences } from './tags'
import { set } from './factories'

/* eslint-env mocha */
import App from './'
import assert from 'assert'

describe('Compute', () => {
  it('should Compute a value', () => {
    const main = {
      state: {
        foo: () => 'foo',
      },
    }
    const controller = App(main)
    assert.equal(controller.get(state`foo`), 'foo')
  })
  it('should cache value', () => {
    let count = 0
    const main = {
      state: {
        foo: () => count++,
      },
    }
    const controller = App(main)
    assert.equal(controller.get(state`foo`), 0)
    assert.equal(controller.get(state`foo`), 0)
  })
  it('should Compute state', () => {
    const main = {
      state: {
        foo: 'bar',
        fooCopy: (get) => get(state`foo`),
      },
    }
    const controller = App(main)
    assert.equal(controller.get(state`fooCopy`), 'bar')
  })
  it('should update Compute when state changes', () => {
    const main = {
      state: {
        foo: 'bar',
        fooCopy: (get) => get(state`foo`),
      },
      sequences: {
        updateFoo: ({ store }) => {
          store.set(state`foo`, 'bar2')
        },
      },
    }
    const controller = App(main)
    assert.equal(controller.get(state`fooCopy`), 'bar')
    controller.getSequence('updateFoo')()
    assert.equal(controller.get(state`fooCopy`), 'bar2')
  })
  it('should Compute module state', () => {
    const main = {
      state: {
        foo: 'bar',
        fooCopy: (get) => get(moduleState`foo`),
      },
    }
    const controller = App(main)
    assert.equal(controller.get(state`fooCopy`), 'bar')
  })
  it('should update Compute when module changes', () => {
    const main = {
      state: {
        foo: 'bar',
        fooCopy: (get) => get(moduleState`foo`),
      },
      sequences: {
        updateFoo: ({ store }) => {
          store.set(state`foo`, 'bar2')
        },
      },
    }
    const controller = App(main)
    assert.equal(controller.get(state`fooCopy`), 'bar')
    controller.getSequence('updateFoo')()
    assert.equal(controller.get(state`fooCopy`), 'bar2')
  })
  it('should Compute props', () => {
    const main = {
      state: {
        foo: (get) => get(props`foo`),
      },
    }
    const app = App(main)
    assert.equal(app.get(state`foo`, { foo: 'bar' }), 'bar')
  })
  it('should Compute other computed state', () => {
    const main = {
      state: {
        foo: () => 'foo',
        bar: (get) => get(state`foo`),
      },
    }
    const controller = App(main)
    assert.equal(controller.get(state`bar`), 'foo')
  })
  it('should Compute when computed state updates', () => {
    const main = {
      state: {
        foo: 'bar',
        foo2: (get) => get(state`foo`),
        bar: (get) => get(state`foo2`),
      },
      sequences: {
        updateFoo: ({ store }) => {
          store.set(state`foo`, 'bar2')
        },
      },
    }
    const controller = App(main)
    assert.equal(controller.get(state`bar`), 'bar')
    controller.getSequence('updateFoo')()
    assert.equal(controller.get(state`bar`), 'bar2')
  })
  it('should allow getting path with get', () => {
    const main = {
      state: {
        foo: (get) => get.path(state`foo.bar`),
      },
    }
    const controller = App(main)
    assert.equal(controller.get(state`foo`), 'foo.bar')
  })
  it('should throw when trying to replace computed', () => {
    const main = {
      state: {
        foo: (get) => get.path(state`foo.bar`),
      },
      sequences: {
        test: set(state`foo`, 'bar'),
      },
    }
    const controller = App(main, {
      devtools: { init() {}, registerComputedState() {} },
    })
    const test = controller.get(sequences`test`)
    assert.throws(() => test())
  })
})
