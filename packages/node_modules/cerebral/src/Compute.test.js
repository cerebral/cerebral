/* eslint-env mocha */
import { Controller, Module, Compute } from './'
import { state, props, module } from './tags'
import assert from 'assert'

describe('Compute', () => {
  it('should Compute a value', () => {
    const computed = Compute()(() => {
      return 'foo'
    })
    assert.equal(computed.getValue(), 'foo')
  })
  it('should pass get into function', () => {
    const computed = Compute()((get) => {
      return get(state`foo`)
    })
    assert.equal(
      computed.getValue({
        state: {
          get() {
            return 'foo'
          },
        },
      }),
      'foo'
    )
  })
  it('should pass previous args into functions', () => {
    const computed = Compute('foo')((foo, get) => {
      return foo + get(props`foo`)
    })
    assert.equal(
      computed.getValue({
        props: {
          foo: 'foo',
        },
      }),
      'foofoo'
    )
  })
  it('should resolve tags', () => {
    const computed = Compute(state`foo`)((foo) => {
      return foo
    })
    assert.equal(
      computed.getValue({
        state: {
          get() {
            return 'foo'
          },
        },
      }),
      'foo'
    )
  })
  it('should allow computed as previous arg', () => {
    const computedA = Compute()(() => {
      return 'foo'
    })
    const computedB = Compute(computedA)((computedAValue) => {
      return computedAValue
    })
    assert.equal(computedB.getValue(), 'foo')
  })
  it('should be able to resolve in actions and override props', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      signals: {
        test: [
          ({ resolve }) => {
            assert.equal(
              resolve.value(computed, {
                props: {
                  path: 'foo',
                },
              }),
              'bar'
            )
          },
        ],
      },
    })
    const computed = Compute(props`path`)((path, get) => {
      return get(state`${path}`)
    })
    const controller = Controller(rootModule)
    controller.getSignal('test')({
      path: 'bar',
    })
  })
  it('should be able to attach computed to modules and resolve module tags', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        upperFoo: Compute(module`foo`)((foo) => foo.toUpperCase()),
      },
    })
    const controller = Controller(rootModule)
    const value = controller.getComputed('upperFoo').getValue({
      module: {
        get(path) {
          return controller.getState(path)
        },
      },
    })
    assert.equal(value, 'BAR')
  })
  it('should be able to resolve module computed in actions', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        upperFoo: Compute(module`foo`)((foo) => foo.toUpperCase()),
      },
      signals: {
        test: [
          ({ computed }) => {
            assert.equal(computed.get('upperFoo'), 'BAR')
          },
        ],
      },
    })
    const controller = Controller(rootModule)
    controller.getSignal('test')()
  })
})
