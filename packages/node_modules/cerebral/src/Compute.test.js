/* eslint-env mocha */
import { Controller, Module, Compute } from './'
import { state, props, moduleState, computed } from './tags'
import assert from 'assert'

describe('Compute', () => {
  it('should Compute a value', () => {
    const foo = Compute(() => {
      return 'foo'
    })
    const app = Module({
      computed: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'foo')
  })
  it('should Compute a clone', () => {
    const foo = Compute(() => {
      return 'foo'
    })
    const app = Module({
      computed: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(
      controller
        .getComputed('foo')
        .clone()
        .getValue(),
      'foo'
    )
  })
  it('should cache value', () => {
    let count = 0
    const foo = Compute(() => {
      return count++
    })
    const app = Module({
      computed: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 0)
    assert.equal(controller.getComputed('foo').getValue(), 0)
  })
  it('should Compute state', () => {
    const foo = Compute(
      {
        foo: state`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
  })
  it('should update Compute when state changes', () => {
    const foo = Compute(
      {
        foo: state`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        foo,
      },
      sequences: {
        updateFoo: ({ state }) => {
          state.set('foo', 'bar2')
        },
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
    controller.getSequence('updateFoo')()
    assert.equal(controller.getComputed('foo').getValue(), 'bar2')
  })
  it('should Compute module', () => {
    const foo = Compute(
      {
        foo: moduleState`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
  })
  it('should update Compute when module changes', () => {
    const foo = Compute(
      {
        foo: moduleState`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        foo,
      },
      sequences: {
        updateFoo: ({ state }) => {
          state.set('foo', 'bar2')
        },
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
    controller.getSequence('updateFoo')()
    assert.equal(controller.getComputed('foo').getValue(), 'bar2')
  })
  it('should Compute props', () => {
    const foo = Compute(
      {
        foo: props`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      computed: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(
      controller.getComputed('foo').getValue({
        foo: 'bar',
      }),
      'bar'
    )
  })
  it('should Compute computed tag', () => {
    const foo = Compute(() => {
      return 'foo'
    })
    const bar = Compute(
      {
        foo: computed`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      computed: {
        foo,
        bar,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('bar').getValue(), 'foo')
  })
  it('should Compute when computed updates', () => {
    const foo = Compute(
      {
        foo: state`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const bar = Compute(
      {
        foo: computed`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        foo,
        bar,
      },
      sequences: {
        updateFoo: ({ state }) => {
          state.set('foo', 'bar2')
        },
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('bar').getValue(), 'bar')
    controller.getSequence('updateFoo')()
    assert.equal(controller.getComputed('bar').getValue(), 'bar2')
  })
  it('should Compute dynamically', () => {
    const foo = Compute(({ get }) => {
      return get(state`foo`)
    })
    const app = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
  })
  it('should Compute dynamically when updated', () => {
    const foo = Compute(({ get }) => {
      return get(state`foo`)
    })
    const app = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        foo,
      },
      sequences: {
        updateFoo: ({ state }) => {
          state.set('foo', 'bar2')
        },
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
    controller.getSequence('updateFoo')()
    assert.equal(controller.getComputed('foo').getValue(), 'bar2')
  })
})
