import {
  isObject,
  isComplexObject,
  isSerializable,
  throwError,
  forceSerializable,
  addCerebralStateKey,
  extractModulesProp,
} from './utils'
import StateProvider from './providers/State'

class Model {
  constructor(controller) {
    const initialState = extractModulesProp('root', controller.module, 'state')

    this.controller = controller
    this.StateProvider = StateProvider
    this.devtools = controller.devtools
    this.state = this.devtools && this.devtools.warnStateProps
      ? addCerebralStateKey(initialState)
      : initialState
    this.changedPaths = []

    controller.on('moduleAdded', this.onModuleAdded.bind(this))
    controller.on('moduleRemoved', this.onModuleRemoved.bind(this))

    if (typeof window !== 'undefined' && window.CEREBRAL_STATE) {
      Object.keys(window.CEREBRAL_STATE).forEach(statePath => {
        this.set(statePath.split('.'), window.CEREBRAL_STATE[statePath])
      })
    }
  }
  onModuleAdded(path, module) {
    this.set(path, module.state)
  }
  onModuleRemoved(path) {
    this.unset(path)
  }
  /*
    Returns array of changes
  */
  flush() {
    const changes = this.changedPaths.slice()

    this.changedPaths = []

    return changes
  }
  /*
    A generic method for making a change to a path, used
    by multiple mutation methods. Only adds to flush when value
    actually changed. Complex objects always causes a flush due to
    for example array sorting
  */
  updateIn(path, cb, forceChildPathUpdates = false) {
    if (!path.length) {
      cb(this.state, this, 'state')

      return
    }

    path.reduce((currentState, key, index) => {
      if (index === path.length - 1) {
        if (!Array.isArray(currentState) && !isObject(currentState)) {
          throwError(
            `The path "${path.join('.')}" is invalid. Path: "${path
              .slice(0, path.length - 1)
              .join('.')}" is type of "${currentState === null
              ? 'null'
              : typeof currentState}"`
          )
        }

        const currentValue = currentState[key]

        cb(currentState[key], currentState, key)
        if (
          currentState[key] !== currentValue ||
          (isComplexObject(currentState[key]) && isComplexObject(currentValue))
        ) {
          this.changedPaths.push({
            path,
            forceChildPathUpdates,
          })
        }
      } else if (!currentState[key]) {
        currentState[key] = {}
      }

      return currentState[key]
    }, this.state)
  }
  /*
    Unfreezes on the way down. When done freezes state. It is optimized
    to not go down already frozen paths
  */
  updateInFrozen(path, cb, forceChildPathUpdates) {
    this.state = this.unfreezeObject(this.state)
    path.reduce((currentState, key, index) => {
      if (index === path.length - 1) {
        if (!Array.isArray(currentState) && !isObject(currentState)) {
          throwError(
            `The path "${path.join('.')}" is invalid. Path: "${path
              .slice(0, path.length - 1)
              .join('.')}" is type of "${currentState === null
              ? 'null'
              : typeof currentState}"`
          )
        }
        currentState[key] = this.unfreezeObject(currentState[key])

        const currentValue = currentState[key]
        cb(currentState[key], currentState, key)

        if (
          currentState[key] !== currentValue ||
          (isComplexObject(currentState[key]) && isComplexObject(currentValue))
        ) {
          this.changedPaths.push({
            path,
            forceChildPathUpdates,
          })
        }
      } else if (!currentState[key]) {
        currentState[key] = {}
      } else {
        currentState[key] = this.unfreezeObject(currentState[key])
      }

      return currentState[key]
    }, this.state)

    this.freezeObject(this.state)
  }
  /*
=======
>>>>>>> 77f95cf... feat(Controller): should copy and freeze state extracted in actions
    Checks if value is serializable, if turned on
  */
  verifyValue(value, path) {
    if (this.devtools && !isSerializable(value, this.devtools.allowedTypes)) {
      throwError(
        `You are passing a non serializable value into the state tree on path "${path.join(
          '.'
        )}"`
      )
    }
    if (this.devtools) {
      forceSerializable(value)
    }
    if (this.devtools && this.devtools.warnStateProps) {
      addCerebralStateKey(value)
    }
  }
  verifyValues(values, path) {
    if (this.devtools) {
      values.forEach(value => {
        this.verifyValue(value, path)
      })
    }
  }
  get(path = []) {
    return path.reduce((currentState, key) => {
      return currentState ? currentState[key] : undefined
    }, this.state)
  }
  set(path, value) {
    this.verifyValue(value, path)
    this.updateIn(
      path,
      (_, parent, key) => {
        parent[key] = value
      },
      true
    )
  }
  toggle(path) {
    this.updateIn(path, (value, parent, key) => {
      parent[key] = !value
    })
  }
  push(path, value) {
    this.verifyValue(value, path)
    this.updateIn(path, array => {
      array.push(value)
    })
  }
  merge(path, ...values) {
    const value = Object.assign(...values)

    // If we already have an object we make it behave
    // like multiple sets, indicating a change to very key.
    // If no value it should indicate that we are setting
    // a new object
    if (this.get(path)) {
      for (let prop in value) {
        this.set(path.concat(prop), value[prop])
      }
    } else {
      this.set(path, value)
    }
  }
  pop(path) {
    this.updateIn(path, array => {
      array.pop()
    })
  }
  shift(path) {
    this.updateIn(path, array => {
      array.shift()
    })
  }
  unshift(path, value) {
    this.verifyValue(value, path)
    this.updateIn(path, array => {
      array.unshift(value)
    })
  }
  splice(path, ...args) {
    this.verifyValues(args, path)
    this.updateIn(path, array => {
      array.splice(...args)
    })
  }
  unset(path) {
    this.updateIn(
      path,
      (_, parent, key) => {
        delete parent[key]
      },
      true
    )
  }
  concat(path, value) {
    this.verifyValue(value, path)
    this.updateIn(path, (array, parent, key) => {
      parent[key] = array.concat(value)
    })
  }
}

export default Model
