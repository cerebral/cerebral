/* eslint-env mocha */

import React from 'react'
import ReactDOM from 'react-dom'
import TestUtils from 'react-addons-test-utils'
import assert from 'assert'
import { state, signal, props } from '../../tags'
import { Controller, compute } from '../../'
import { Container, StateContainer, connect, decorator } from './'

describe('React', () => {
  describe('state container', () => {
    it('should be able to wrap app with container', () => {
      class TestComponent extends React.Component {
        render() {
          return <div />
        }
      }
      const tree = TestUtils.renderIntoDocument(
        <StateContainer>
          <TestComponent />
        </StateContainer>
      )

      assert.ok(TestUtils.findRenderedComponentWithType(tree, TestComponent))
    })
    it('should be able to expose state', () => {
      const model = {
        foo: 'bar',
      }
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        props => {
          return <div>{props.foo}</div>
        }
      )
      const tree = TestUtils.renderIntoDocument(
        <StateContainer state={model}>
          <TestComponent />
        </StateContainer>
      )

      assert.equal(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').innerHTML,
        'bar'
      )
    })
    it('should be able to expose signals', () => {
      const model = {
        foo: 'bar',
      }
      const signals = {
        test2: [() => {}],
      }
      const TestComponent = connect(
        {
          foo: state`foo`,
          test: signal`test`,
          test2: signal`test2`,
        },
        props => {
          assert.equal(typeof props.test === 'function', true)
          assert.equal(typeof props.test2 === 'object', true)
          return <div>{props.foo}</div>
        }
      )
      const tree = TestUtils.renderIntoDocument(
        <StateContainer state={model} signals={signals}>
          <TestComponent />
        </StateContainer>
      )

      assert.equal(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').innerHTML,
        'bar'
      )
    })
    it('should be able to expose state with connectDecorator', () => {
      const model = {
        foo: 'bar',
      }
      const TestComponent = decorator({
        foo: state`foo`,
      })(props => {
        return <div>{props.foo}</div>
      })
      const tree = TestUtils.renderIntoDocument(
        <StateContainer state={model}>
          <TestComponent />
        </StateContainer>
      )

      assert.equal(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').innerHTML,
        'bar'
      )
    })
  })
  describe('container', () => {
    it('should be able to expose controller', () => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
      })
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        props => {
          return <div>{props.foo}</div>
        }
      )
      const tree = TestUtils.renderIntoDocument(
        <Container controller={controller}>
          <TestComponent />
        </Container>
      )

      assert.equal(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').innerHTML,
        'bar'
      )
    })
    it('should throw when no controller provided', () => {
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        props => {
          return <div>{props.foo}</div>
        }
      )
      assert.throws(
        () => {
          TestUtils.renderIntoDocument(
            <Container>
              <TestComponent />
            </Container>
          )
        },
        err => {
          if (err instanceof Error) {
            return (
              err.message ===
              'Cerebral - You are not passing controller to Container'
            )
          }
        }
      )
    })
    it('should throw when container component is not provided', () => {
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        props => {
          return <div>{props.foo}</div>
        }
      )
      assert.throws(
        () => {
          TestUtils.renderIntoDocument(<TestComponent />)
        },
        err => {
          if (err instanceof Error) {
            return (
              err.message ===
              'Cerebral - Can not find controller, did you remember to use the Container component? Read more at: http://cerebraljs.com/docs/api/components.html#react'
            )
          }
        }
      )
    })
    it('should be able to unregister component from container after unmounting component', () => {
      const controller = Controller({
        devtools: { init() {}, send() {}, updateComponentsMap() {} },
        state: {
          foo: 'bar',
        },
      })
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        props => {
          return <div>{props.foo}</div>
        }
      )
      const tree = TestUtils.renderIntoDocument(
        <Container controller={controller}>
          <TestComponent />
        </Container>
      )
      const TestComponentRef = TestUtils.findRenderedComponentWithType(
        tree,
        TestComponent
      )
      assert.equal(TestComponentRef._isUnmounting, undefined)
      assert.equal(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').innerHTML,
        'bar'
      )
      ReactDOM.unmountComponentAtNode(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').parentNode
      )
      assert.equal(TestComponentRef.view.isUnmounted, true)
      assert.deepEqual(
        controller.componentDependencyStore.getAllUniqueEntities(),
        []
      )
    })
  })
  describe('connect', () => {
    it('should convert component to json', () => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
      })
      const MyComponent = props => {
        return <div>{props.foo}</div>
      }
      MyComponent.displayName = 'Test'
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        MyComponent
      )
      const tree = TestUtils.renderIntoDocument(
        <Container controller={controller}>
          <TestComponent />
        </Container>
      )
      assert.equal(
        TestUtils.findRenderedComponentWithType(tree, TestComponent).toJSON(),
        'Test'
      )
    })
    it('should render only ones where multiple state matches', () => {
      const controller = Controller({
        state: {
          foo: 'bar',
          bar: 'foo',
        },
        signals: {
          test: [
            ({ state }) => {
              state.set('foo', 'bar2')
              state.set('bar', 'foo2')
            },
          ],
        },
      })
      let renderCount = 0
      const TestComponent = connect(
        {
          foo: state`foo`,
          bar: state`bar`,
        },
        props => {
          renderCount++
          return <div>{props.foo}</div>
        }
      )
      const tree = TestUtils.renderIntoDocument(
        <Container controller={controller}>
          <TestComponent />
        </Container>
      )

      assert.equal(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').innerHTML,
        'bar'
      )
      assert.equal(renderCount, 1)
      controller.getSignal('test')()
      assert.equal(renderCount, 2)
    })
    it('should only rerender affected components', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          foo: 'bar',
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo', 'bar2')],
        },
      })
      class TestComponentClass2 extends React.Component {
        render() {
          renderCount++
          return <div />
        }
      }
      const TestComponent2 = connect({}, TestComponentClass2)
      class TestComponentClass extends React.Component {
        callSignal() {
          this.props.methodCalled()
        }
        render() {
          renderCount++
          return <div><TestComponent2 /></div>
        }
      }
      const TestComponent = connect(
        {
          foo: state`foo`,
          methodCalled: signal`methodCalled`,
        },
        TestComponentClass
      )
      const tree = TestUtils.renderIntoDocument(
        <Container controller={controller}>
          <TestComponent />
        </Container>
      )
      const component = TestUtils.findRenderedComponentWithType(
        tree,
        TestComponentClass
      )
      component.callSignal()
      assert.equal(renderCount, 3)
    })
    it('should allow props tag and computed', () => {
      const controller = Controller({
        state: {
          foo: {
            baz: 'mip',
          },
        },
      })
      const TestComponent = connect(
        {
          a: compute(props`foo`),
          b: props`bar.id`,
          c: state`foo.${props`propKey`}`,
        },
        ({ a, b, c }) => {
          return <div>{a + b + c}</div>
        }
      )
      const tree = TestUtils.renderIntoDocument(
        <Container controller={controller}>
          <TestComponent foo="bar" bar={{ id: '1' }} propKey="baz" />
        </Container>
      )
      assert.equal(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').innerHTML,
        'bar1mip'
      )
    })
    it('should update on props change', () => {
      const controller = Controller({})
      class TestComponentClass2 extends React.Component {
        render() {
          return <div>{this.props.foo}</div>
        }
      }
      const TestComponent2 = connect({}, TestComponentClass2)
      class TestComponentClass extends React.Component {
        constructor(props) {
          super(props)
          this.state = { foo: 'bar' }
        }
        changePath() {
          this.setState({
            foo: 'bar2',
          })
        }
        render() {
          return <span><TestComponent2 foo={this.state.foo} /></span>
        }
      }
      const TestComponent = connect({}, TestComponentClass)
      const tree = TestUtils.renderIntoDocument(
        <Container controller={controller}>
          <TestComponent />
        </Container>
      )
      assert.equal(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').innerHTML,
        'bar'
      )
      const component = TestUtils.findRenderedComponentWithType(
        tree,
        TestComponentClass
      )
      component.changePath()
      assert.equal(
        TestUtils.findRenderedDOMComponentWithTag(tree, 'div').innerHTML,
        'bar2'
      )
    })
  })
})
