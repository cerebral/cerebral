/* eslint-env mocha */
import Vue from 'vue/dist/vue'
import assert from 'assert'
import { state, signal, props } from '../../tags'
import { Controller, compute } from '../../'
import { Container, connect } from './'

describe('Vuejs', () => {
  describe('Container', () => {
    it('should be able to expose controller', () => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
      })
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          template: `<div>{{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.equal(myComponent.$el.innerHTML, 'bar')
      assert.equal(myComponent.foo, 'bar')
    })
    it('should throw when no controller provided', () => {
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          template: `<div>{{foo}}</div>`,
        }
      )
      assert.throws(
        () => {
          new Vue({
            template: `<container>
                  <my-component></my-component>
                </container>`,
            components: {
              container: Container(),
              'my-component': TestComponent,
            },
          }).$mount()
        },
        err => {
          if (err instanceof Error) {
            return (
              err.message ===
              'Cerebral - You are not passing controller to Container'
            )
          }
        }
      )
    })
  })
  describe('connect', () => {
    it('should be able to register component into componentDependencyStore before vm mounting', done => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
      })
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          name: 'Test',
          template: `<div>{{foo}}</div>`,
          beforeMount: function() {
            assert.equal(this._isMounted, false)
          },
          mounted: function() {
            const components = controller.componentDependencyStore.getAllUniqueEntities()
            assert.equal(components.length, 1)
            assert.equal(components[0]._displayName, 'Test')
            assert.equal(this._isMounted, true)
            done()
          },
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.equal(myComponent.$el.innerHTML, 'bar')
    })
    it('should be able to extract signals', () => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
        signals: {
          someSignal: [],
        },
      })
      const TestComponent = connect(
        {
          foo: state`foo`,
          signal: signal`someSignal`,
        },
        {
          template: `<div>{{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.equal(myComponent.$el.innerHTML, 'bar')
      assert.equal(myComponent.foo, 'bar')
      assert.ok(typeof myComponent.signal === 'function')
    })
    it('should rerender on state update', done => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo', 'bar2')],
        },
      })
      const TestComponent = connect(
        {
          foo: state`foo`,
          methodCalled: signal`methodCalled`,
        },
        {
          methods: {
            callSignal: function() {
              this.methodCalled()
            },
          },
          template: `<div>{{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.equal(myComponent.$el.innerHTML, 'bar')
      assert.equal(myComponent.foo, 'bar')
      myComponent.callSignal()
      Vue.nextTick(() => {
        assert.equal(myComponent.$el.innerHTML, 'bar2')
        assert.equal(myComponent.foo, 'bar2')
        done()
      })
    })
    it('should be able to work with vue props', () => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
      })
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          props: ['message'],
          template: `<div>{{message}} {{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component message='hello'></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.equal(myComponent.$el.innerHTML, 'hello bar')
      assert.equal(myComponent.foo, 'bar')
      assert.equal(myComponent.$props.message, 'hello')
      assert.equal(myComponent.message, 'hello')
    })
    it('should be able to work with props tag and computed', () => {
      const controller = Controller({
        state: {
          foo: {
            baz: 'mip',
          },
        },
      })
      const TestComponent = connect(
        {
          a: compute(props`foo`),
          b: props`bar.id`,
          c: state`foo.${props`propKey`}`,
        },
        {
          props: ['foo', 'bar', 'propKey'],
          template: `<div>{{a + b + c}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component foo="bar" :bar="{ id: '1' }" propKey="baz"></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.equal(myComponent.$el.innerHTML, 'bar1mip')
      assert.equal(myComponent.a, 'bar')
      assert.equal(myComponent.$props.foo, 'bar')
      assert.equal(myComponent.b, '1')
      assert.deepEqual(myComponent.$props.bar, { id: '1' })
      assert.equal(myComponent.c, 'mip')
      assert.equal(myComponent.$props.propKey, 'baz')
    })
    it('should be able to watch vue props', done => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo', 'bar2')],
        },
      })
      const TestComponentChild = connect(
        {
          foo: state`foo`,
        },
        {
          props: ['message'],
          template: `<div>{{message}}</div>`,
        }
      )
      const TestComponent = {
        data() {
          return { foo: 'bar' }
        },
        methods: {
          callSignal: function() {
            this.foo = 'bar2'
          },
        },
        template: `<child v-bind:message="foo"></child>`,
        components: {
          child: TestComponentChild,
        },
      }
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0]
      assert.equal(myComponent.$el.innerHTML, 'bar')
      assert.equal(myComponent.foo, 'bar')
      myComponent.callSignal()
      Vue.nextTick(() => {
        assert.equal(myComponent.$el.innerHTML, 'bar2')
        assert.equal(myComponent.foo, 'bar2')
        done()
      })
    })
    it('should be able to work with other provider', () => {
      const BarProvider = {
        provide: {
          bar: 'baz',
        },
        template: `<div><slot></slot></div>`,
      }
      const controller = Controller({
        state: {
          foo: 'bar',
        },
        signals: {
          someSignal: [],
        },
      })
      const TestComponent = connect(
        {
          foo: state`foo`,
          signal: signal`someSignal`,
        },
        {
          inject: ['bar'],
          template: `<div>{{foo}}</div>`,
        }
      )
      const vm = new Vue({
        template: `<bar-provider>
                    <container>
                      <my-component></my-component>
                    </container>
                  </bar-provider>`,
        components: {
          container: Container(controller),
          'bar-provider': BarProvider,
          'my-component': TestComponent,
        },
      }).$mount()
      const myComponent = vm.$children[0].$children[0].$children[0]
      assert.equal(myComponent.$el.innerHTML, 'bar')
      assert.equal(myComponent.foo, 'bar')
      assert.equal(myComponent.bar, 'baz')
      assert.ok(typeof myComponent.signal === 'function')
    })
    it('should be able to unregister component from componentDependencyStore before destroying vm', done => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
      })
      const TestComponent = connect(
        {
          foo: state`foo`,
        },
        {
          template: `<div>{{foo}}</div>`,
          beforeDestroy: function() {
            assert.equal(this._isBeingDestroyed, false)
            assert.equal(this._isDestroyed, false)
          },
          destroyed: function() {
            assert.deepEqual(
              controller.componentDependencyStore.getAllUniqueEntities(),
              []
            )
            assert.equal(this._isBeingDestroyed, true)
            assert.equal(this._isDestroyed, true)
            done()
          },
        }
      )
      const vm = new Vue({
        template: `<container>
            <my-component></my-component>
          </container>`,
        components: {
          container: Container(controller),
          'my-component': TestComponent,
        },
      }).$mount()

      vm.$destroy()
    })
  })
})
