/* eslint-env mocha */
/* eslint-disable no-global-assign */
/* eslint-disable no-new */
import View from './View'
import { Controller, compute } from '../'
import { state, props, signal } from '../tags'
import assert from 'assert'

describe('View', () => {
  it('should throw an error if no dependencies provided', () => {
    assert.throws(
      () => {
        new View({
          dependencies: undefined,
        })
      },
      err => {
        if (err instanceof Error) {
          return (
            err.message ===
            'Cerebral - There is no reason to connect a component that has no dependencies'
          )
        }
      }
    )
  })
  it('should throw an error if dependency is a function', () => {
    assert.throws(
      () => {
        new View({
          dependencies: () => {},
        })
      },
      err => {
        if (err instanceof Error) {
          return (
            err.message ===
            'Cerebral - You can not use a function to define dependencies. Use tags or a function on the specific property you want to dynamically create'
          )
        }
      }
    )
  })
  it('should throw an error if dependency item is not tags or compute', () => {
    const controller = new Controller({
      state: {
        foo: 'bar',
      },
    })
    assert.throws(
      () => {
        new View({
          dependencies: {
            foo: () => {},
          },
          controller,
        })
      },
      err => {
        if (err instanceof Error) {
          return (
            err.message ===
            'Cerebral - Prop foo should be tags or a function on the specific property you want to dynamically create'
          )
        }
      }
    )
  })
  it('should return undefined when signal is not defined', () => {
    const controller = Controller({
      state: {
        foo: 'bar',
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        fooCalled: signal`fooCalled`,
      },
      controller,
      displayName: 'Test',
    })
    const componentProps = view.getProps()
    assert.equal(componentProps.fooCalled, undefined)
  })
  it('should warn if component has more dependencies than devtools configuration', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.equal(
        args[0],
        'Component named Test has a lot of dependencies, consider refactoring or adjust this option in devtools'
      )
      originWarn.apply(this, args)
    }

    const controller = Controller({
      devtools: {
        bigComponentsWarning: 2,
        init() {},
        send() {},
        updateComponentsMap() {},
      },
      state: {
        foo: 'foo',
        bar: 'bar',
      },
      signals: {
        fooCalled: [],
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
        fooCalled: signal`fooCalled`,
      },
      controller,
      displayName: 'Test',
    })
    view.getProps()
    assert.equal(view._hasWarnedBigComponent, true)
    assert.equal(warnCount, 1)
    console.warn = originWarn
  })
  it('should be able to extract state', () => {
    const controller = Controller({
      state: {
        foo: 'bar',
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
    })
    assert.deepEqual(view.controller.getState(), { foo: 'bar' })
    const componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar')
  })
  it('should be able to extract signals', () => {
    const controller = Controller({
      state: {
        foo: 'bar',
      },
      signals: {
        someSignal: [],
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        signal: signal`someSignal`,
      },
      controller,
    })
    const componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar')
    assert.ok(typeof componentProps.signal === 'function')
  })
  it('should allow props tag', () => {
    const controller = Controller({
      state: {
        foo: {
          baz: 'mip',
        },
      },
    })
    const view = new View({
      dependencies: {
        a: props`foo`,
        b: props`bar.id`,
        c: state`foo.${props`propKey`}`,
      },
      controller,
      props: {
        foo: 'bar',
        bar: { id: '1' },
        propKey: 'baz',
      },
    })
    const componentProps = view.getProps({
      foo: 'bar',
      bar: { id: '1' },
      propKey: 'baz',
    })
    assert.equal(componentProps.a, 'bar')
    assert.equal(componentProps.b, '1')
    assert.equal(componentProps.c, 'mip')
  })
  it('should be able to dynamically define signals', () => {
    const controller = Controller({
      state: {
        test: '',
      },
      signals: {
        foo: [({ state }) => state.set('test', 'fooSignal')],
      },
    })
    const view = new View({
      dependencies: {
        signal: signal`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })

    let componentProps = view.getProps({
      path: 'foo',
    })
    componentProps.signal()
    assert.equal(controller.getModel().get(['test']), 'fooSignal')
  })
  it('should be able to adjust props with function (mergeProps)', () => {
    const controller = Controller({
      state: {
        foo: 'bar',
      },
      signals: {
        foo: [],
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        fooSignal: signal`foo`,
      },
      mergeProps: (depsProps, ownProps, resolve) => {
        assert.equal(depsProps.foo, 'bar')
        assert.equal(typeof depsProps.fooSignal, 'function')
        assert.deepEqual(ownProps, { mip: 'mop' })
        assert.equal(resolve.path(state`foo`), 'foo')
        assert.equal(resolve.value(state`foo`), 'bar')

        return { bar: depsProps.foo + ownProps.mip }
      },
      props: {
        mip: 'mop',
      },
      controller,
    })
    let componentProps = view.getProps({
      mip: 'mop',
    })
    assert.equal(componentProps.bar, 'barmop')
    assert.equal(componentProps.foo, undefined)
    assert.equal(componentProps.fooSignal, undefined)
  })
  it('should mount correctly', () => {
    const controller = new Controller({
      state: {
        foo: 'bar',
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
      displayName: 'Test',
      onUpdate: function() {},
    })
    view.mount()
    assert.deepEqual(view.dependencyTrackersDependencyMaps, {
      state: {},
      props: {},
    })
    assert.deepEqual(view.dependencyTrackers, {})
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
    assert.equal(typeof view.onUpdate, 'function')
  })
  it('should handle complex dependencies when mounting', () => {
    const computed = compute(props`path`, (path, get) => {
      return get(state`${path}`)
    })
    const controller = new Controller({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
    })
    const view = new View({
      dependencies: {
        foo: computed,
        bar: state`bar`,
      },
      props: { path: 'foo' },
      controller,
    })
    view.mount()
    assert.equal(view.dependencyTrackers.foo.value, 'bar')
    assert.deepEqual(view.dependencyTrackersDependencyMaps, {
      state: { foo: true },
      props: { path: true },
    })
    assert.deepEqual(view.tagsDependencyMap, { bar: true })
  })
  it('should update devtools components map and add entity to controller dependency store when mounting', () => {
    let devtoolsUpdateComponentsMapCalled = 0
    let dependencyStoreAddEntityCalled = 0
    const controller = new Controller({
      devtools: {
        init() {},
        send() {},
        updateComponentsMap(component, nextDeps, prevDeps) {
          assert.deepEqual(nextDeps, { foo: true })
          assert.equal(prevDeps, undefined)
          assert.equal(component._displayName, 'Test')
          devtoolsUpdateComponentsMapCalled++
        },
      },
      state: {
        foo: 'bar',
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        path: props`path`,
      },
      props: { path: 'foo' },
      controller,
      displayName: 'Test',
    })
    view.controller.componentDependencyStore.addEntity = function(
      component,
      depsMap
    ) {
      assert.deepEqual(depsMap, { foo: true })
      assert.equal(component._displayName, 'Test')
      dependencyStoreAddEntityCalled++
    }
    view.mount()
    assert.equal(devtoolsUpdateComponentsMapCalled, 1)
    assert.equal(dependencyStoreAddEntityCalled, 1)
  })
  it('should update devtools components map and remove entity from controller dependency store when unmounting', () => {
    let devtoolsUpdateComponentsMapCalled = 0
    let dependencyStoreRemoveEntityCalled = 0
    const controller = new Controller({
      devtools: {
        init() {},
        send() {},
        updateComponentsMap(component, nextDeps, prevDeps) {
          assert.deepEqual(nextDeps, { foo: true })
          assert.equal(prevDeps, undefined)
          assert.equal(component._displayName, 'Test')
          devtoolsUpdateComponentsMapCalled++
        },
      },
      state: {
        foo: 'bar',
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        path: props`path`,
      },
      props: { path: 'foo' },
      controller,
      displayName: 'Test',
    })
    view.mount()
    view.controller.componentDependencyStore.removeEntity = function(
      component,
      depsMap
    ) {
      assert.deepEqual(depsMap, { foo: true })
      assert.equal(component._displayName, 'Test')
      dependencyStoreRemoveEntityCalled++
    }
    view.controller.devtools.updateComponentsMap = function(
      component,
      nextDeps,
      prevDeps
    ) {
      assert.deepEqual(prevDeps, { foo: true })
      assert.equal(nextDeps, null)
      assert.equal(component._displayName, 'Test')
      devtoolsUpdateComponentsMapCalled++
    }
    view.unMount()
    assert.equal(devtoolsUpdateComponentsMapCalled, 2)
    assert.equal(dependencyStoreRemoveEntityCalled, 1)
  })
  it('should update tags', () => {
    let renderCount = 0
    const controller = Controller({
      state: {
        list: {
          0: 'foo',
          1: 'bar',
        },
        currentItem: '0',
      },
      signals: {
        test: [
          ({ state }) => {
            state.set('currentItem', '1')
          },
        ],
      },
    })
    const view = new View({
      dependencies: {
        foo: state`list.${state`currentItem`}`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['currentItem'])
        assert.equal(force, undefined)
        view.updateFromState(stateChanges, null, force)
        assert.deepEqual(view.dependencyTrackers, {})
        assert.deepEqual(view.dependencyTrackersDependencyMaps, {
          state: {},
          props: {},
        })
        assert.deepEqual(view.tagsDependencyMap, {
          'list.1': true,
          currentItem: true,
        })
        renderCount++
      },
    })
    view.mount()
    assert.deepEqual(view.dependencyTrackers, {})
    assert.deepEqual(view.dependencyTrackersDependencyMaps, {
      state: {},
      props: {},
    })
    assert.deepEqual(view.tagsDependencyMap, {
      'list.0': true,
      currentItem: true,
    })
    let componentProps = view.getProps()
    assert.equal(componentProps.foo, 'foo')
    view.controller.getSignal('test')()
    componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar')
    assert.equal(renderCount, 1)
  })
  it('should update on props change', () => {
    const controller = Controller({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
    })
    const view = new View({
      dependencies: {
        foo: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
    const hasUpdate = view.onPropsUpdate(
      {
        path: 'foo',
      },
      {
        path: 'bar',
      }
    )
    assert.equal(hasUpdate, true)
    assert.deepEqual(view.tagsDependencyMap, { bar: true })
  })
  it('should not update when there is no props change', () => {
    const controller = Controller({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
    })
    const view = new View({
      dependencies: {
        foo: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
    const hasUpdate = view.onPropsUpdate(
      {
        path: 'foo',
      },
      {
        path: 'foo',
      }
    )
    assert.equal(hasUpdate, false)
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
  })
  it('should rerender on state update', () => {
    let renderCount = 0
    const controller = Controller({
      state: {
        foo: 'bar',
      },
      signals: {
        methodCalled: [({ state }) => state.set('foo', 'bar2')],
      },
    })

    const view = new View({
      dependencies: {
        foo: state`foo`,
        methodCalled: signal`methodCalled`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['foo'])
        assert.equal(force, undefined)
        view.updateFromState(stateChanges, null, force)
        renderCount++
      },
    })
    view.mount()
    assert.equal(renderCount, 0)
    let componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar')
    componentProps.methodCalled()
    componentProps = view.getProps()
    assert.equal(componentProps.foo, 'bar2')
    assert.equal(renderCount, 1)
  })
  it('should render only ones where multiple state changes', () => {
    const controller = Controller({
      state: {
        foo: 'bar',
        bar: 'foo',
      },
      signals: {
        test: [
          ({ state }) => {
            state.set('foo', 'bar2')
            state.set('bar', 'foo2')
          },
        ],
      },
    })
    let renderCount = 0
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 2)
        assert.deepEqual(stateChanges[0].path, ['foo'])
        assert.deepEqual(stateChanges[1].path, ['bar'])
        assert.equal(force, undefined)
        renderCount++
      },
    })
    view.mount()
    assert.equal(renderCount, 0)
    controller.getSignal('test')()
    assert.equal(renderCount, 1)
  })
  it('should rerender when controller flush method called with force option', () => {
    let renderCount = 0
    const controller = Controller({
      state: {
        foo: 'bar',
      },
    })
    const view = new View({
      dependencies: {
        foo: compute(state`foo`),
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 0)
        assert.equal(force, true)
        view.updateFromState(stateChanges, null, force)
        renderCount++
      },
    })
    view.mount()
    assert.equal(renderCount, 0)
    view.controller.flush(true)
    assert.equal(renderCount, 1)
  })
  it('should rerender on parent dep replacement', () => {
    let renderCount = 0
    const controller = Controller({
      state: {
        foo: {
          bar: 'baz',
        },
      },
      signals: {
        methodCalled: [({ state }) => state.set('foo', { bar: 'baz2' })],
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo.bar`,
        methodCalled: signal`methodCalled`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['foo'])
        assert.equal(force, undefined)
        renderCount++
      },
    })
    view.mount()
    assert.equal(renderCount, 0)
    let componentProps = view.getProps()
    assert.equal(componentProps.foo, 'baz')
    componentProps.methodCalled()
    componentProps = view.getProps()
    assert.equal(componentProps.foo, 'baz2')
    assert.equal(renderCount, 1)
  })
  it('should only rerender affected components', () => {
    let renderCountView1 = 0
    let renderCountView2 = 0
    const controller = Controller({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
      signals: {
        methodCalled: [({ state }) => state.set('foo', 'bar2')],
      },
    })
    const view1 = new View({
      dependencies: {
        bar: state`bar`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        renderCountView1++
      },
    })
    view1.mount()
    const view2 = new View({
      dependencies: {
        foo: state`foo`,
        methodCalled: signal`methodCalled`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['foo'])
        assert.equal(force, undefined)
        renderCountView2++
      },
    })
    view2.mount()
    assert.equal(renderCountView1, 0)
    assert.equal(renderCountView2, 0)
    controller.getSignal('methodCalled')()
    assert.equal(renderCountView1, 0)
    assert.equal(renderCountView2, 1)
  })
  describe('STRICT render update', () => {
    it('should update when parent path changes', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          foo: {
            bar: 'baz',
          },
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo', 'bar2')],
        },
      })
      const view = new View({
        dependencies: {
          foo: state`foo.bar`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      let componentProps = view.getProps()
      assert.equal(componentProps.foo, 'baz')
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo, undefined)
      assert.equal(renderCount, 1)
    })
    it('should return array', () => {
      const controller = Controller({
        state: {
          map: '',
        },
      })
      const view = new View({
        dependencies: {
          foo: state`foo.*`,
        },
        controller,
      })
      view.mount()
      let componentProps = view.getProps()
      assert.deepEqual(componentProps.foo, [])
      assert.deepEqual(view.tagsDependencyMap, { 'foo.*': true })
    })
    it('should be able to override immediate child interest', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          foo: [
            {
              bar: 'baz',
            },
          ],
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo.0.bar', 'baz2')],
        },
      })
      const view = new View({
        dependencies: {
          foo: state`foo.*`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      let componentProps = view.getProps()
      assert.equal(componentProps.foo[0], '0')
      assert.deepEqual(view.tagsDependencyMap, { 'foo.*': true })
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo[0], '0')
      assert.equal(renderCount, 0)
    })
    it('should by default update when nested children update', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          foo: {
            bar: {
              baz: 'value',
            },
          },
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo.bar.baz', 'value2')],
        },
      })
      const view = new View({
        dependencies: {
          foo: state`foo`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo', 'bar', 'baz'])
          assert.equal(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, { 'foo.**': true })
      let componentProps = view.getProps()
      assert.equal(componentProps.foo.bar.baz, 'value')
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo.bar.baz, 'value2')
      assert.equal(renderCount, 1)
    })
    it('should by default update when nested children update with array', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          foo: [
            {
              bar: 'value',
            },
          ],
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo.0.bar', 'value2')],
        },
      })
      const view = new View({
        dependencies: {
          foo: state`foo`,
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo', '0', 'bar'])
          assert.equal(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.tagsDependencyMap, { 'foo.**': true })
      let componentProps = view.getProps()
      assert.equal(componentProps.foo[0].bar, 'value')
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo[0].bar, 'value2')
      assert.equal(renderCount, 1)
    })
    it('should by default update when nested children update using COMPUTE', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          foo: {
            bar: {
              baz: 'value',
            },
          },
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo.bar.baz', 'value2')],
        },
      })
      const view = new View({
        dependencies: {
          foo: compute(state`foo`),
          methodCalled: signal`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo', 'bar', 'baz'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.deepEqual(view.dependencyTrackersDependencyMaps, {
            state: { 'foo.**': true },
            props: {},
          })
          assert.deepEqual(view.dependencyTrackers.foo.value, {
            bar: {
              baz: 'value2',
            },
          })
          assert.deepEqual(view.tagsDependencyMap, {})
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.dependencyTrackersDependencyMaps, {
        state: { 'foo.**': true },
        props: {},
      })
      assert.deepEqual(view.dependencyTrackers.foo.value, {
        bar: {
          baz: 'value',
        },
      })
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.equal(componentProps.foo.bar.baz, 'value')
      componentProps.methodCalled()
      componentProps = view.getProps()
      assert.equal(componentProps.foo.bar.baz, 'value2')
      assert.equal(renderCount, 1)
    })
  })
  describe('Compute', () => {
    it('should allow use of compute as state dependency and access props', () => {
      const controller = Controller({})
      const view = new View({
        dependencies: {
          foo: compute(get => {
            return get(props`foo`) + 'baz'
          }),
        },
        props: {
          foo: 'bar',
        },
        controller,
      })
      view.mount()
      assert.deepEqual(view.dependencyTrackersDependencyMaps, {
        state: {},
        props: { foo: true },
      })
      assert.deepEqual(view.dependencyTrackers.foo.value, 'barbaz')
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.equal(componentProps.foo, 'barbaz')
    })
    it('should have access to state through state argument', () => {
      const controller = Controller({
        state: {
          foo: 'bar',
        },
      })
      const view = new View({
        dependencies: {
          foo: compute(get => {
            return get(state`foo`)
          }),
        },
        controller,
      })
      view.mount()
      assert.deepEqual(view.dependencyTrackersDependencyMaps, {
        state: { foo: true },
        props: {},
      })
      assert.deepEqual(view.dependencyTrackers.foo.value, 'bar')
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.equal(componentProps.foo, 'bar')
    })
    it('should track state', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          foo: 'bar',
        },
        signals: {
          methodCalled: [({ state }) => state.set('foo', 'bar2')],
        },
      })
      const view = new View({
        dependencies: {
          foo: compute(get => {
            return get(state`foo`)
          }),
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['foo'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.deepEqual(view.dependencyTrackersDependencyMaps, {
            state: { foo: true },
            props: {},
          })
          assert.deepEqual(view.dependencyTrackers.foo.value, 'bar2')
          assert.deepEqual(view.tagsDependencyMap, {})
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.dependencyTrackersDependencyMaps, {
        state: { foo: true },
        props: {},
      })
      assert.deepEqual(view.dependencyTrackers.foo.value, 'bar')
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.equal(componentProps.foo, 'bar')
      view.controller.getSignal('methodCalled')()
      componentProps = view.getProps()
      assert.equal(componentProps.foo, 'bar2')
      assert.equal(renderCount, 1)
    })
    it('should update dependency map when compute is rerun', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          map: {},
        },
        signals: {
          changeState: [({ state }) => state.set('map.1', { awesome: true })],
          changeState2: [({ state }) => state.set('map.1.awesome', false)],
        },
      })
      const view = new View({
        dependencies: {
          foo: compute(state`map.*`, (map, get) => {
            return map.filter(key => {
              return get(state`map.${key}.awesome`)
            })
          }),
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['map', '1'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.deepEqual(view.dependencyTrackersDependencyMaps, {
            state: { 'map.*': true, 'map.1.awesome': true },
            props: {},
          })
          assert.equal(view.dependencyTrackers.foo.value, '1')
          assert.deepEqual(view.tagsDependencyMap, {})
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.dependencyTrackersDependencyMaps, {
        state: { 'map.*': true },
        props: {},
      })
      assert.deepEqual(view.dependencyTrackers.foo.value, [])
      assert.deepEqual(view.tagsDependencyMap, {})

      let componentProps = view.getProps()
      assert.deepEqual(componentProps.foo, [])

      view.controller.getSignal('changeState')()
      componentProps = view.getProps()
      assert.equal(componentProps.foo, '1')
      assert.equal(renderCount, 1)

      view.onUpdate = (stateChanges, force) => {
        assert.equal(stateChanges.length, 1)
        assert.deepEqual(stateChanges[0].path, ['map', '1', 'awesome'])
        assert.equal(force, undefined)
        view.updateFromState(stateChanges, null, force)
        assert.deepEqual(view.dependencyTrackersDependencyMaps, {
          state: { 'map.*': true, 'map.1.awesome': true },
          props: {},
        })
        assert.deepEqual(view.dependencyTrackers.foo.value, [])
        assert.deepEqual(view.tagsDependencyMap, {})
        renderCount++
      }

      view.controller.getSignal('changeState2')()
      componentProps = view.getProps()
      assert.deepEqual(componentProps.foo, [])
      assert.equal(renderCount, 2)
    })
    it('should handle complex state changes', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          user: {
            projects: ['0', '1'],
          },
          projects: {
            '0': 'foo',
            '1': 'bar',
            '2': 'baz',
          },
        },
        signals: {
          changeState: [({ state }) => state.push('user.projects', '2')],
        },
      })
      const view = new View({
        dependencies: {
          projects: compute(get => {
            const projects = get(state`user.projects`)

            return projects.map(projectKey =>
              get(state`projects.${projectKey}`)
            )
          }),
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['user', 'projects'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.deepEqual(view.dependencyTrackersDependencyMaps, {
            state: {
              'user.projects.**': true,
              'projects.0': true,
              'projects.1': true,
              'projects.2': true,
            },
            props: {},
          })
          assert.deepEqual(view.dependencyTrackers.projects.value, [
            'foo',
            'bar',
            'baz',
          ])
          assert.deepEqual(view.tagsDependencyMap, {})
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      assert.deepEqual(view.dependencyTrackersDependencyMaps, {
        state: {
          'user.projects.**': true,
          'projects.0': true,
          'projects.1': true,
        },
        props: {},
      })
      assert.deepEqual(view.dependencyTrackers.projects.value, ['foo', 'bar'])
      assert.deepEqual(view.tagsDependencyMap, {})
      let componentProps = view.getProps()
      assert.deepEqual(componentProps.projects, ['foo', 'bar'])
      view.controller.getSignal('changeState')()
      componentProps = view.getProps()
      assert.deepEqual(componentProps.projects, ['foo', 'bar', 'baz'])
      assert.equal(renderCount, 1)
    })
    it('should handle strict deps', () => {
      let renderCount = 0
      const controller = Controller({
        state: {
          user: {
            projects: ['0', '1'],
          },
          projects: {
            '0': { title: '0' },
            '1': { title: '1' },
          },
        },
        signals: {
          changeState: [({ state }) => state.set('projects.1.title', 'woop')],
        },
      })
      const view = new View({
        dependencies: {
          projects: compute(get => {
            const projects = get(state`user.projects`)

            return projects.map(projectKey =>
              get(state`projects.${projectKey}`)
            )
          }),
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.equal(stateChanges.length, 1)
          assert.deepEqual(stateChanges[0].path, ['projects', '1', 'title'])
          assert.equal(force, undefined)
          view.updateFromState(stateChanges, null, force)
          renderCount++
        },
      })
      view.mount()
      assert.equal(renderCount, 0)
      let componentProps = view.getProps()
      assert.deepEqual(componentProps.projects, [
        { title: '0' },
        { title: '1' },
      ])
      view.controller.getSignal('changeState')()
      componentProps = view.getProps()
      assert.deepEqual(componentProps.projects, [
        { title: '0' },
        { title: 'woop' },
      ])
      assert.equal(renderCount, 1)
    })
  })
  it('should handle props updating state deps', () => {
    const controller = Controller({
      state: {
        foo: 'bar',
        bar: 'baz',
      },
      signals: {
        changeState: [({ state }) => state.set('bar', 'baz2')],
      },
    })
    const view = new View({
      dependencies: {
        foo: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { foo: true })
    let componentProps = view.getProps({
      path: 'foo',
    })
    assert.equal(componentProps.foo, 'bar')
    view.onPropsUpdate(
      {
        path: 'foo',
      },
      {
        path: 'bar',
      }
    )
    assert.deepEqual(view.tagsDependencyMap, { bar: true })

    componentProps = view.getProps({
      path: 'bar',
    })
    assert.equal(componentProps.foo, 'baz')

    view.controller.getSignal('changeState')()

    componentProps = view.getProps({
      path: 'bar',
    })
    assert.equal(componentProps.foo, 'baz2')
  })
  it('should handle props composition updating value', () => {
    const controller = Controller({
      state: {
        field: {
          value: '',
        },
      },
      signals: {
        changeState: [
          ({ state }) => {
            state.set('field.value', 'foo')
            state.merge('field', { mip: 'mop' })
          },
        ],
      },
    })
    const view = new View({
      dependencies: {
        field: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'field',
      },
    })
    view.mount()
    assert.deepEqual(view.tagsDependencyMap, { 'field.**': true })
    let componentProps = view.getProps({
      path: 'field',
    })
    assert.deepEqual(componentProps.field, {
      value: '',
    })

    view.controller.getSignal('changeState')()

    componentProps = view.getProps({
      path: 'field',
    })
    assert.deepEqual(componentProps.field, {
      value: 'foo',
      mip: 'mop',
    })
  })
  it('should warn if prop is from the Cerebral state tree when initializing', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.equal(
        args[0],
        'You are passing an array to the component "Test" on prop "list" which is from the Cerebral state tree. You should not do this, but rather connect it directly to this component. This will optimize the component and avoid any rerender issues.'
      )
      originWarn.apply(this, args)
    }
    const controller = Controller({
      devtools: {
        warnStateProps: true,
        preventExternalMutations: true,
        init() {},
        send() {},
        updateComponentsMap() {},
      },
      state: {
        foo: 'bar',
        list: [],
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
      props: {
        list: controller.getState('list'),
      },
      displayName: 'Test',
    })
    assert.equal(view._verifyPropsWarned, true)
    assert.equal(warnCount, 1)
    console.warn = originWarn
  })
  it('should warn if prop is from the Cerebral state tree when updating props', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.equal(
        args[0],
        'You are passing an object to the component "Test" on prop "list" which is from the Cerebral state tree. You should not do this, but rather connect it directly to this component. This will optimize the component and avoid any rerender issues.'
      )
      originWarn.apply(this, args)
    }
    const controller = Controller({
      devtools: {
        warnStateProps: true,
        preventExternalMutations: true,
        init() {},
        send() {},
        updateComponentsMap() {},
      },
      state: {
        foo: 'bar',
        list: {},
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
      props: {
        list: '',
      },
      displayName: 'Test',
    })
    view.mount()
    assert.equal(view._verifyPropsWarned, false)
    view.onPropsUpdate(
      {
        list: '',
      },
      {
        list: controller.getState('list'),
      }
    )
    assert.equal(view._verifyPropsWarned, true)
    assert.equal(warnCount, 1)
    console.warn = originWarn
  })
})
