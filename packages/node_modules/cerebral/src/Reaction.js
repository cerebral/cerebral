import Watch from './Watch'
import { Compute } from './Compute'

export class Reaction extends Watch {
  constructor(dependencies, cb) {
    super('Reaction')
    this.dependencies = dependencies
    this.cb = cb
    this.getter = null
    this.context = null
    this.computedSubscriptions = []
    this.onSubscriptionUpdate = this.onSubscriptionUpdate.bind(this)
  }
  initialize() {
    this.context = this.controller.createContext()
    this.getter = (tag) => tag.getValue(this.context)
    this.computedSubscriptions = Object.keys(this.dependencies).reduce(
      (currentSubscriptions, key) => {
        if (this.dependencies[key].type === 'computed') {
          return currentSubscriptions.concat(
            this.dependencies[key]
              .getValue(this.context)
              .subscribe(this, this.onSubscriptionUpdate)
          )
        }

        return currentSubscriptions
      },
      []
    )
    this.subscribe(this, this.onSubscriptionUpdate)

    return this
  }
  onSubscriptionUpdate() {
    this.executedCount++
    if (this.controller.devtools) {
      this.controller.devtools.sendWatchMap([], [], 0, 0)
    }
    this.cb(
      Object.keys(this.dependencies).reduce(
        (currentDeps, key) => {
          currentDeps[key] = this.dependencies[key].getValue(this.context)

          if (currentDeps[key] instanceof Compute) {
            currentDeps[key] = currentDeps[key].getValue()
          }

          return currentDeps
        },
        {
          get: this.getter,
        }
      )
    )
  }
  createDependencyMap() {
    return this.controller.createDependencyMap(
      Object.keys(this.dependencies).map((key) => this.dependencies[key]),
      null,
      this.modulePath
    )
  }
  destroy() {
    super.destroy()
    this.computedSubscriptions.forEach((unsubscribe) => unsubscribe())
  }
}

export default (dependencies, cb) => {
  if (!cb) {
    cb = dependencies
    dependencies = {}
  }

  return new Reaction(dependencies, cb)
}
