import { Compute } from './Compute'

class Watch {
  constructor(type) {
    this.id = 'Watch_' + Watch.nextWatchId++
    this.name = null
    this.type = type
    this.executedCount = 0
    this.controller = null
    this.modulePath = ''
    this.subscribers = []
    this.dependencyMap = null
  }
  create(controller, modulePath, name) {
    this.name = name
    this.controller = controller
    this.modulePath = modulePath

    return this
  }
  onUpdate(changes, force) {
    if (!this.subscribers) {
      // It has been deleted before in this batch: ignore.
      return
    }
    this.subscribers.forEach((subscription) => {
      subscription.cb(changes, force)
    })
    if (this.controller.devtools) {
      this.controller.devtools.updateComputedMap(this, this.subscribers)
    }
  }
  subscribe(watcher, cb) {
    if (!this.dependencyMap) {
      this.dependencyMap = this.createDependencyMap()
      this.controller.dependencyStore.addEntity(this, this.dependencyMap)
      if (this.controller.devtools) {
        this.controller.devtools.updateWatchMap(this, this.dependencyMap)
        this.controller.devtools.sendWatchMap([], [], 0, 0)
      }
    }

    for (var x = 0; x < this.subscribers.length; x++) {
      if (this.subscribers[x].watcher === watcher) {
        return this.subscribers[x].unsubscribe
      }
    }

    const subscription = {
      unsubscribe: () => {
        this.subscribers.splice(this.subscribers.indexOf(subscription), 1)
      },
      cb,
      watcher,
    }

    if (watcher instanceof Compute) {
      this.subscribers.unshift(subscription)
    } else {
      this.subscribers.push(subscription)
    }

    if (this.controller.devtools) {
      this.controller.devtools.updateComputedMap(this, this.subscribers)
    }

    return subscription.unsubscribe
  }
  destroy() {
    this.subscribers.forEach((subscription) => subscription.unsubscribe())
    this.subscribers = null
    if (this.dependencyMap) {
      this.controller.dependencyStore.removeEntity(this, this.dependencyMap)
      if (this.controller.devtools) {
        this.controller.devtools.updateWatchMap(this, null, this.dependencyMap)
        this.controller.devtools.sendWatchMap([], [], 0, 0)
      }
    }
  }
  toJSON() {
    return {
      id: this.id,
      executedCount: this.executedCount,
      type: this.type,
      name: this.name,
    }
  }
}

Watch.nextWatchId = 0

export default Watch
