import { throwError } from './utils'
import { Primitive } from 'function-tree'
import { Computed } from './Computed'
import { Reaction } from './Reaction'

class Module {
  constructor(moduleDescription) {
    this.moduleDescription = moduleDescription
  }
  create(controller, path) {
    const stringPath = path.join('.')
    const moduleStub = {
      controller,
      path: stringPath,
      name: path.slice().pop(),
    }

    const module =
      typeof this.moduleDescription === 'function'
        ? this.moduleDescription(moduleStub)
        : Object.assign({}, this.moduleDescription)

    /* Convert arrays to actually runable sequences */
    module.sequences = Object.keys(module.sequences || {}).reduce(
      (currentSequences, sequenceKey) => {
        const sequence = module.sequences[sequenceKey]
        if (
          !(
            sequence &&
            (Array.isArray(sequence) ||
              typeof sequence === 'function' ||
              sequence instanceof Primitive)
          )
        ) {
          throwError(
            `Sequence with name "${sequenceKey}" is not correctly defined. Please check that the sequence is either a sequence, an array or a function.`
          )
        }
        currentSequences[sequenceKey] = {
          sequence: sequence,
          run(payload) {
            controller.runSequence(
              path.concat(sequenceKey).join('.'),
              sequence,
              payload
            )
          },
        }

        return currentSequences
      },
      {}
    )

    /* Instantiate submodules */
    module.modules = Object.keys(module.modules || {}).reduce(
      (registered, moduleKey) => {
        if (!module.modules[moduleKey].create) {
          throw new Error(
            `You are not using the Module factory on module "${moduleKey}"`
          )
        }

        registered[moduleKey] = module.modules[moduleKey].create(
          controller,
          path.concat(moduleKey)
        )

        return registered
      },
      {}
    )

    /* Instantiate computed */
    module.computed = Object.keys(module.computed || {}).reduce(
      (registered, computedKey) => {
        if (!(module.computed[computedKey] instanceof Computed)) {
          throw new Error(
            `You are not using a Computed in module on key "${computedKey}"`
          )
        }

        registered[computedKey] = module.computed[computedKey].create(
          controller,
          path,
          path.concat(computedKey).join('.')
        )

        return registered
      },
      {}
    )

    /* Instantiate watcher */
    module.reactions = Object.keys(module.reactions || {}).reduce(
      (registered, reactionKey) => {
        if (!(module.reactions[reactionKey] instanceof Reaction)) {
          throw new Error(
            `You are not using a Reaction in module on key "${reactionKey}"`
          )
        }

        registered[reactionKey] = module.reactions[reactionKey].create(
          controller,
          path,
          path.concat(reactionKey).join('.')
        )

        return registered
      },
      {}
    )

    return module
  }
}

export default Module
