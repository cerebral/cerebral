import { throwError } from './utils'
import { Primitive } from 'function-tree'
import { Computed } from './Computed'
import { Reaction } from './Reaction'

class Module {
  constructor(moduleDescription) {
    this.moduleDescription = moduleDescription
  }
  create(controller, path) {
    const stringPath = path.join('.')
    const moduleStub = {
      controller,
      path: stringPath,
      name: path.slice().pop(),
    }

    const module =
      typeof this.moduleDescription === 'function'
        ? this.moduleDescription(moduleStub)
        : Object.assign({}, this.moduleDescription)

    /* Convert arrays to actually runable signals */
    module.signals = Object.keys(module.signals || {}).reduce(
      (currentSignals, signalKey) => {
        const signal = module.signals[signalKey]
        if (
          !(
            signal &&
            (Array.isArray(signal) ||
              typeof signal === 'function' ||
              signal instanceof Primitive)
          )
        ) {
          throwError(
            `Signal with name "${signalKey}" is not correctly defined. Please check that the signal is either a sequence, an array or a function.`
          )
        }
        currentSignals[signalKey] = {
          signal: signal,
          run(payload) {
            controller.runSignal(
              path.concat(signalKey).join('.'),
              signal,
              payload
            )
          },
        }

        return currentSignals
      },
      {}
    )

    /* Instantiate submodules */
    module.modules = Object.keys(module.modules || {}).reduce(
      (registered, moduleKey) => {
        if (!module.modules[moduleKey].create) {
          throw new Error(
            `You are not using the Module factory on module "${moduleKey}"`
          )
        }

        registered[moduleKey] = module.modules[moduleKey].create(
          controller,
          path.concat(moduleKey)
        )

        return registered
      },
      {}
    )

    /* Instantiate computed */
    module.computed = Object.keys(module.computed || {}).reduce(
      (registered, computedKey) => {
        if (!(module.computed[computedKey] instanceof Computed)) {
          throw new Error(
            `You are not using a Computed in module on key "${computedKey}"`
          )
        }

        registered[computedKey] = module.computed[computedKey].create(
          controller,
          path,
          path.concat(computedKey).join('.')
        )

        return registered
      },
      {}
    )

    /* Instantiate watcher */
    module.reactions = Object.keys(module.reactions || {}).reduce(
      (registered, reactionKey) => {
        if (!(module.reactions[reactionKey] instanceof Reaction)) {
          throw new Error(
            `You are not using a Reaction in module on key "${reactionKey}"`
          )
        }

        registered[reactionKey] = module.reactions[reactionKey].create(
          controller,
          path,
          path.concat(reactionKey).join('.')
        )

        return registered
      },
      {}
    )

    return module
  }
}

export default Module
