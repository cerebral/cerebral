import { Tag } from 'function-tree'
import Watch from './Watch'

export class Compute extends Watch {
  constructor(cb) {
    super('Compute')
    this.computedCallback = cb
    this.subscriptions = []
    this.isDirty = true
    this.value = null
    this.props = null
    this.getters = null
    this.stateTags = []
    this.propsTags = []
    this.computedTags = []

    this.onSubscription = this.onSubscription.bind(this)
    this.dynamicGetter = this.dynamicGetter.bind(this)

    this.watcherSubscription = null
  }
  createDependencyMap() {
    return this.controller.createDependencyMap(
      this.stateTags,
      this.props,
      this.modulePath
    )
  }
  clone() {
    return new Compute(this.computedCallback).create(
      this.controller,
      this.modulePath,
      this.name + ' (clone)'
    )
  }
  subscribe(watcher, cb) {
    if (!this.watcherSubscription) {
      this.watcherSubscription = super.subscribe(this, this.onSubscription)
    }

    return super.subscribe(watcher, cb)
  }
  onSubscription() {
    this.isDirty = true
  }
  compute() {
    this.executedCount++
    const value = this.computedCallback(this.getDynamicGetter())
    if (this.computedTags.length) {
      const getters = this.controller.createContext(this.props, this.modulePath)
      this.subscriptions = this.computedTags
        .map((computedTag) => computedTag.getValue(getters))
        .map((computed) => computed.subscribe(this, this.onSubscription))
    }
    return value
  }
  getDynamicGetter() {
    this.subscriptions.forEach((unsubscribe) => unsubscribe())
    this.stateTags = []
    this.computedTags = []
    this.propsTags = []

    return this.dynamicGetter
  }
  dynamicGetter(tag) {
    if (!(tag instanceof Tag)) {
      throw new Error(
        'Cerebral - Only tags are allowed in the dynamic "get" of Compute'
      )
    }
    const allTags = tag.getTags()

    allTags.forEach((tag) => {
      if (tag.type === 'props') {
        this.propsTags.push(tag)
      } else if (
        tag.type === 'state' &&
        tag.getValue(this.getters) instanceof Compute
      ) {
        this.computedTags.push(tag)
      } else {
        this.stateTags.push(tag)
      }
    })

    const value = tag.getValue(this.getters)

    if (value instanceof Compute) {
      return value.getValue(this.props)
    }

    return value
  }
  hasChangedProps(props) {
    const nextGetters = this.controller.createContext(props)

    return this.propsTags.reduce((hasChanged, tag) => {
      if (hasChanged) {
        return true
      }

      return tag.getValue(this.getters) !== tag.getValue(nextGetters)
    }, false)
  }
  getValue(props) {
    if (!this.controller) {
      throw new Error('This Cerebral Compute has not been added to a module')
    }

    if (!this.watcherSubscription) {
      this.watcherSubscription = this.subscribe(this, this.onSubscription)
    }

    if (!this.isDirty && this.propsTags.length && this.hasChangedProps(props)) {
      this.isDirty = true
    }

    if (this.isDirty) {
      this.getters = this.controller.createContext(props)
      this.props = props
      this.value = this.compute()
      const prevDependencyMap = this.dependencyMap
      this.dependencyMap = this.createDependencyMap()
      this.controller.dependencyStore.updateEntity(
        this,
        prevDependencyMap,
        this.dependencyMap
      )
      if (this.controller.devtools) {
        this.controller.devtools.updateWatchMap(
          this,
          this.dependencyMap,
          prevDependencyMap
        )
        this.controller.devtools.updateComputedState(this.name, this.value)
      }
      this.isDirty = false
    }

    return this.value
  }
}

export default (cb) => {
  return new Compute(cb)
}
