import { Tag } from 'function-tree'
import { throwError } from './utils'

export class Compute {
  constructor(dependencies, cb) {
    this.dependencies = dependencies
    this.dependencyMap = null
    this.dynamicDependencies = []
    this.computeCallback = cb
    this.controller = null
    this.modulePath = ''
    this.subscribers = []
    this.subscriptions = []
    this.isDirty = true
    this.value = null
    this.props = null
    this.getters = null
    this.tags = Object.keys(this.dependencies).reduce((currentTags, key) => {
      const maybeTag = this.dependencies[key]

      if (maybeTag instanceof Tag) {
        return currentTags.concat(maybeTag.getTags())
      } else {
        throwError('You are not passing in an object with tags to a Compute')
      }

      return currentTags
    }, [])
    this.propsTags = this.tags.filter((tag) => tag.type === 'props')
    this.computedTags = this.tags.filter((tag) => tag.type === 'computed')

    this.onSubscription = this.onSubscription.bind(this)
    this.dynamicGetter = this.dynamicGetter.bind(this)
  }
  create(controller, modulePath) {
    this.controller = controller
    this.modulePath = modulePath

    return this
  }
  destroy() {
    this.subscribers.forEach((subscription) => subscription.unsubscribe())
    this.subscriptions.forEach((unsubscribe) => unsubscribe())
    this.subscribers = null
    this.subscriptions = null
    if (this.dependencyMap) {
      this.controller.dependencyStore.removeEntity(this, this.dependencyMap)
    }
  }
  clone() {
    return new Compute(this.dependencies, this.computeCallback).create(
      this.controller,
      this.modulePath
    )
  }
  onUpdate(changes, force) {
    this.isDirty = true
    this.subscribers.forEach((subscription) => {
      subscription.cb(changes, force)
    })
  }
  onSubscription() {
    this.isDirty = true
  }
  subscribe(cb) {
    const index = this.subscribers.length
    const unsubscribe = () => {
      this.subscribers.splice(index, 1)
    }

    this.subscribers.push({
      unsubscribe,
      cb,
    })

    return unsubscribe
  }
  compute() {
    const getters = this.controller.createGetters(this.props, this.modulePath)

    if (this.computedTags.length) {
      this.subscriptions.forEach((unsubscribe) => unsubscribe())
      this.subscriptions = this.computedTags
        .map((computedTag) => computedTag.getValue(getters))
        .map((computed) => computed.subscribe(this.onSubscription))
    }

    return this.computeCallback(
      Object.keys(this.dependencies).reduce(
        (values, key) => {
          const dependency = this.dependencies[key]

          if (dependency instanceof Tag && dependency.type === 'computed') {
            values[key] = dependency.getValue(getters).getValue(this.props)
          } else if (dependency instanceof Tag) {
            values[key] = dependency.getValue(getters)
          }

          return values
        },
        {
          get: this.getDynamicGetter(),
        }
      )
    )
  }
  getDynamicGetter() {
    if (this.dynamicDependencies.length) {
      this.dynamicDependencies = []
    }

    return this.dynamicGetter
  }
  dynamicGetter(tag) {
    if (!(tag instanceof Tag)) {
      throw new Error(
        'Cerebral - Only tags are allowed in the dynamic "get" of Compute'
      )
    }
    const allTags = tag.getTags()

    allTags.forEach((tag) => {
      this.dynamicDependencies.push(tag)
    })

    return tag.getValue(this.getters)
  }
  hasChangedProps(props) {
    const nextGetters = this.controller.createGetters(props)

    return this.propsTags.reduce((hasChanged, tag) => {
      if (hasChanged) {
        return true
      }

      return tag.getValue(this.getters) !== tag.getValue(nextGetters)
    }, false)
  }
  createDependencyMap(props) {
    return this.controller.createDependencyMap(
      Object.keys(this.dependencies)
        .map((key) => this.dependencies[key])
        .concat(this.dynamicDependencies),
      props,
      this.modulePath
    )
  }
  getValue(props) {
    if (!this.controller) {
      throw new Error('This Cerebral Computed has not been added to a module')
    }

    if (!this.dependencyMap) {
      this.dependencyMap = this.createDependencyMap(props)
      this.controller.dependencyStore.addEntity(this, this.dependencyMap)
    }

    if (!this.isDirty && this.propsTags.length && this.hasChangedProps(props)) {
      this.isDirty = true
    }

    if (this.isDirty) {
      this.getters = this.controller.createGetters(props)
      this.props = props
      this.value = this.compute()
      if (this.dynamicDependencies.length) {
        const prevDependencyMap = this.dependencyMap
        this.dependencyMap = this.createDependencyMap(props)
        this.controller.dependencyStore.updateEntity(
          this,
          prevDependencyMap,
          this.dependencyMap
        )
      }
      this.isDirty = false
    }

    return this.value
  }
}

export default (dependencies = {}) => {
  return (cb) => {
    return new Compute(dependencies, cb)
  }
}
