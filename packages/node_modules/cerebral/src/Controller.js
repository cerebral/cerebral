import DependencyStore from './DependencyStore'
import FunctionTree from 'function-tree'
import Module from './Module'
import Model from './Model'
import {
  ensurePath,
  isDeveloping,
  throwError,
  isSerializable,
  forceSerializable,
  isObject,
  getProviders,
  cleanPath,
} from './utils'
import VerifyPropsProvider from './providers/VerifyProps'
import StateProvider from './providers/State'
import DebuggerProvider from './providers/Debugger'
import ControllerProvider from './providers/Controller'
import ResolveProvider from './providers/Resolve'

function getModule(path, modules) {
  const pathArray = Array.isArray(path) ? path : ensurePath(path)
  return pathArray.reduce((currentModule, key) => {
    if (!currentModule.modules[key]) {
      throwError(
        `The path "${pathArray.join(
          '.'
        )}" is invalid, can not find module. Does the path "${pathArray
          .splice(0, path.length - 1)
          .join('.')}" exist?`
      )
    }
    return currentModule.modules[key]
  }, modules)
}
/*
  The controller is where everything is attached. The devtools
  and router is attached directly. Also a top level module is created.
  The controller creates the function tree that will run all signals,
  based on top level providers and providers defined in modules
*/
class Controller extends FunctionTree {
  constructor(config) {
    super()
    const {
      state = {},
      signals = {},
      providers = [],
      modules = {},
      router,
      devtools = null,
      options = {},
    } = config
    const getSignal = this.getSignal

    this.getSignal = () => {
      throwError(
        'You are grabbing a signal before controller has initialized, please wait for "initialized" event'
      )
    }

    if (router) {
      console.warn(`DEPRECATION: the 'router' module should be in modules.`)
      modules.router = router
    }

    this.componentDependencyStore = new DependencyStore()
    this.options = options
    this.catch = config.catch || null
    this.flush = this.flush.bind(this)
    this.devtools = devtools
    this.model = new Model({}, this.devtools)
    this.module = new Module(this, [], {
      state,
      signals,
      modules,
    })

    if (options.strictRender) {
      console.warn(
        'DEPRECATION - No need to use strictRender option anymore, it is the only render mode now'
      )
    }

    this.contextProviders = [ControllerProvider(this)]
      .concat(this.devtools ? [DebuggerProvider()] : [])
      .concat(isDeveloping() ? [VerifyPropsProvider] : [])
      .concat(StateProvider(this.devtools), ResolveProvider())
      .concat(providers.concat(getProviders(this.module)))

    this.on('asyncFunction', (execution, funcDetails) => {
      if (!funcDetails.isParallel) {
        this.flush()
      }
    })
    this.on('parallelStart', () => this.flush())
    this.on(
      'parallelProgress',
      (execution, currentPayload, functionsResolving) => {
        if (functionsResolving === 1) {
          this.flush()
        }
      }
    )
    this.on('end', () => this.flush())

    if (typeof window !== 'undefined' && window.CEREBRAL_STATE) {
      Object.keys(window.CEREBRAL_STATE).forEach(statePath => {
        this.model.set(ensurePath(statePath), window.CEREBRAL_STATE[statePath])
      })
    }

    if (this.devtools) {
      this.devtools.init(this)
    }

    if (
      !this.devtools &&
      isDeveloping() &&
      typeof navigator !== 'undefined' &&
      /Chrome/.test(navigator.userAgent)
    ) {
      console.warn(
        'You are not using the Cerebral devtools. It is highly recommended to use it in combination with the debugger: http://cerebraljs.com/docs/get_started/debugger.html'
      )
    }

    this.getSignal = getSignal

    this.model.flush()

    this.emit('initialized')
  }
  /*
    Whenever components needs to be updated, this method
    can be called
  */
  flush(force) {
    const changes = this.model.flush()

    if (!force && !Object.keys(changes).length) {
      return
    }

    this.updateComponents(changes, force)
    this.emit('flush', changes, Boolean(force))
  }
  updateComponents(changes, force) {
    let componentsToRender = []

    if (force) {
      componentsToRender = this.componentDependencyStore.getAllUniqueEntities()
    } else {
      componentsToRender = this.componentDependencyStore.getUniqueEntities(
        changes
      )
    }

    const start = Date.now()
    componentsToRender.forEach(component => {
      if (this.devtools) {
        this.devtools.updateComponentsMap(component)
      }
      component.onUpdate(changes, force)
    })
    const end = Date.now()

    if (this.devtools && componentsToRender.length) {
      this.devtools.sendComponentsMap(componentsToRender, changes, start, end)
    }
  }
  /*
    Conveniance method for grabbing the model
  */
  getModel() {
    return this.model
  }
  /*
    Method called by view to grab state
  */
  getState(path) {
    return this.model.get(ensurePath(cleanPath(path)))
  }
  /*
    Uses function tree to run the array and optional
    payload passed in. The payload will be checkd
  */
  runSignal(name, signal, payload = {}) {
    if (this.devtools && (!isObject(payload) || !isSerializable(payload))) {
      console.warn(
        `You passed an invalid payload to signal "${name}". Only serializable payloads can be passed to a signal. The payload has been ignored. This is the object:`,
        payload
      )
      payload = {}
    }

    if (this.devtools) {
      payload = Object.keys(payload).reduce((currentPayload, key) => {
        if (!isSerializable(payload[key], this.devtools.allowedTypes)) {
          console.warn(
            `You passed an invalid payload to signal "${name}", on key "${key}". Only serializable values like Object, Array, String, Number and Boolean can be passed in. Also these special value types:`,
            this.devtools.allowedTypes
          )

          return currentPayload
        }

        currentPayload[key] = forceSerializable(payload[key])

        return currentPayload
      }, {})
    }

    this.run(name, signal, payload, error => {
      if (error) {
        const signalPath = ensurePath(error.execution.name)
        let signalCatch = signalPath.reduce((currentModule, key, index) => {
          if (index === signalPath.length - 1 && currentModule.signals[key]) {
            return currentModule.signals[key].catch
          }

          return currentModule ? currentModule.modules[key] : null
        }, this.module)

        // if signal doesn't have a catch method and we have a global catch, try using it
        if (!signalCatch) {
          if (this.catch instanceof Map) {
            signalCatch = this.catch
          } else {
            throw error
          }
        }

        if (signalCatch instanceof Map) {
          for (let [errorType, signalChain] of signalCatch) {
            if (error instanceof errorType) {
              this.runSignal('catch', signalChain, error.payload)

              return
            }
          }
        }

        throw error
      }
    })
  }
  /*
    Returns a function which binds the name/path of signal,
    and the array. This allows view layer to just call it with
    an optional payload and it will run
  */
  getSignal(path) {
    const pathArray = ensurePath(path)
    const signalKey = pathArray.pop()
    const module = pathArray.reduce((currentModule, key) => {
      return currentModule ? currentModule.modules[key] : undefined
    }, this.module)
    const signal = module && module.signals[signalKey]

    return signal && signal.run
  }
  addModule(path, module) {
    const pathArray = ensurePath(path)
    const moduleKey = pathArray.pop()
    const parentModule = getModule(pathArray, this.module)
    parentModule.modules[moduleKey] = new Module(this, ensurePath(path), module)

    if (module.provider) {
      this.contextProviders.push(module.provider)
    }

    this.flush()
  }
  removeModule(path) {
    if (!path) {
      console.warn('Controller.removeModule requires a Module Path')
      return null
    }

    const pathArray = ensurePath(path)
    const moduleKey = pathArray.pop()
    const parentModule = getModule(pathArray, this.module)

    const module = parentModule.modules[moduleKey]

    if (module.provider) {
      this.contextProviders.splice(
        this.contextProviders.indexOf(module.provider),
        1
      )
    }

    delete parentModule.modules[moduleKey]

    this.model.unset(ensurePath(path))

    this.flush()
  }
}

export default Controller
