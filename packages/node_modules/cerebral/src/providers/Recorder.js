import { Provider } from '../'

export default function RecorderProvider(options = {}) {
  const timeout = options.setTimeout || setTimeout

  // We will override the origin runSequence method to block
  // sequences from running while playing back recording
  let originalRunSequence = null
  let allowedSequences = []
  let currentRecording = null
  let currentSeek = 0
  let currentEventIndex = 0
  let lastEventTimestamp = 0
  let nextEventTimeout = null
  let started = null
  let ended = null
  let isPlaying = false
  let isRecording = false

  function onFlush() {
    if (isRecording) {
      currentRecording.events.push({
        type: 'flush',
        timestamp: Date.now(),
      })
    }
  }

  function onMutation({ method, path, args }) {
    currentRecording.events.push({
      type: 'mutation',
      method,
      args: JSON.stringify([path, ...args]),
      timestamp: Date.now(),
    })
  }

  function addExternalEvent(type, data) {
    currentRecording.events.push({
      type,
      timestamp: Date.now(),
      data,
    })
  }

  function updateDebugger(method, path, args, context) {
    if (
      context.debugger &&
      typeof window !== 'undefined' &&
      window.CustomEvent
    ) {
      const event = new window.CustomEvent('cerebral2.client.message', {
        detail: JSON.stringify({
          type: 'recorderMutation',
          data: {
            method,
            path,
            args,
          },
        }),
      })
      window.dispatchEvent(event)
    }
  }

  function mutate(mutation, context) {
    const args = JSON.parse(mutation.args)
    const path = args.shift()

    context.controller.model[mutation.method].apply(
      context.controller.model,
      [path].concat(args)
    )
    updateDebugger(mutation.method, path, args, context)
  }

  // During playback we run events as they were recorded, one after
  // the other
  function runNextEvent(context) {
    const event = currentRecording.events[currentEventIndex]

    nextEventTimeout = timeout(() => {
      if (event.type === 'mutation') {
        mutate(event, context)
      } else if (event.type === 'flush') {
        context.controller.flush()
      } else {
        context.controller.emit(event.type, event.data)
      }

      lastEventTimestamp = event.timestamp
      currentEventIndex++

      if (!currentRecording.events[currentEventIndex]) {
        context.controller.runSequence = originalRunSequence
        isPlaying = false
        currentEventIndex = 0

        return
      }

      runNextEvent(context)
    }, event.timestamp - lastEventTimestamp)
  }

  function resetState(context) {
    currentRecording.initialState.forEach((state) => {
      const value = JSON.parse(state.value)

      context.controller.model.set(state.path, value)
      updateDebugger('set', state.path, [value], context)
    })
    for (let x = 0; x < currentEventIndex; x++) {
      if (currentRecording.events[x].type === 'mutation') {
        mutate(currentRecording.events[x], context)
      }
    }
  }

  return Provider({
    seek(seek) {
      clearTimeout(nextEventTimeout)

      for (let x = 0; x < currentRecording.events.length; x++) {
        currentEventIndex = x

        const event = currentRecording.events[x]
        if (event.timestamp - currentRecording.start > seek) {
          break
        }
      }

      resetState(this.context)
      this.context.controller.emit('recorder:seek', seek)
    },
    play(options = {}) {
      if (isPlaying || isRecording) {
        throw new Error(
          'CEREBRAL Recorder - You can not play while already playing or recording'
        )
      }

      allowedSequences = options.allowedSequences || []
      resetState(this.context)
      isPlaying = true
      started = Date.now()
      lastEventTimestamp = currentRecording.start

      originalRunSequence = this.context.controller.runSequence
      this.context.controller.runSequence = (...args) => {
        if (allowedSequences.indexOf(args[0]) >= 0) {
          originalRunSequence.apply(this.context.controller, args)
        }
      }
      this.context.controller.flush(true)
      runNextEvent(this.context)
      this.context.controller.emit('recorder:play', currentSeek, options)
    },
    record(options = {}) {
      // If we are recording over the previous stuff, go back to start
      if (currentRecording) {
        currentSeek = 0
        ended = null
      }

      const paths = options.initialState || ['']
      const state = paths.map((path) => {
        const arrayPath = path ? path.split('.') : []

        return {
          path: arrayPath,
          value: JSON.stringify(this.context.controller.getState(arrayPath)),
        }
      })

      currentRecording = {
        initialState: state,
        start: Date.now(),
        events: [],
      }

      this.context.controller.on('recorder:event', addExternalEvent)

      isRecording = true
      this.context.controller.emit('recorder:record', options)

      // We need to record flush events to update the UI
      // at the same time as during the recording
      this.context.controller.on('flush', onFlush)
      this.context.controller.on('mutation', onMutation)

      originalRunSequence = this.context.controller.runSequence
    },
    stop() {
      const wasPlaying = isPlaying
      clearTimeout(nextEventTimeout)
      isPlaying = false
      isRecording = false
      this.context.controller.runSeqence = originalRunSequence
      this.context.controller.off('recorder:event', addExternalEvent)

      if (wasPlaying) {
        return
      }

      currentRecording.end = Date.now()
      currentEventIndex = 0
      currentRecording.events.push({
        type: 'flush',
        timestamp: Date.now(),
      })
      this.context.controller.emit('recorder:stop')
      this.context.controller.off('flush', onFlush)
      this.context.controller.off('mutation', onMutation)
    },
    pause() {
      ended = Date.now()
      currentSeek = ended - started
      clearTimeout(nextEventTimeout)
      isPlaying = false
      this.context.controller.emit('recorder:pause', currentSeek)
    },
    getRecording() {
      return currentRecording
    },
    getCurrentSeek() {
      return currentSeek
    },
    loadRecording(recording) {
      currentRecording = recording
    },
    isRecording() {
      return isRecording
    },
  })
}
