/* eslint-env mocha */
import BaseController from './BaseController'
import Model from './Model'
import assert from 'assert'

describe('Model', () => {
  it('should instantiate with initial state', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const model = new BaseController(rootModule, {
      Model,
    }).model
    assert.strictEqual(model.get(['foo']), 'bar')
  })
  it('should grab nested state', () => {
    const rootModule = {
      state: {
        foo: {
          bar: 'value',
        },
      },
    }
    const model = new BaseController(rootModule, {
      Model,
    }).model
    assert.strictEqual(model.get(['foo', 'bar']), 'value')
  })
  it('should be able to flush changed paths', () => {
    const rootModule = {
      state: {
        foo: {
          bar: 'value',
        },
      },
    }
    const model = new BaseController(rootModule, {
      Model,
    }).model
    model.set(['foo', 'bar'], 'value2')
    assert.deepStrictEqual(model.flush(), [
      {
        path: ['foo', 'bar'],
        forceChildPathUpdates: true,
      },
    ])
  })
  it('should flush same path changes correctly', () => {
    const rootModule = {
      state: {
        foo: {
          bar: 'value',
        },
      },
    }
    const model = new BaseController(rootModule, {
      Model,
    }).model
    model.set(['foo', 'bar'], 'value2')
    model.set(['foo', 'bar'], 'value3')
    assert.deepStrictEqual(model.flush(), [
      {
        path: ['foo', 'bar'],
        forceChildPathUpdates: true,
      },
      {
        path: ['foo', 'bar'],
        forceChildPathUpdates: true,
      },
    ])
  })
  it('should throw when updating invalid path', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const model = new BaseController(rootModule, {
      Model,
    }).model
    assert.throws(() => {
      model.set(['foo', 'bar'], 'baz2')
    })
  })
  it('should emit mutation events', () => {
    let hasEmitted = false
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = new BaseController(rootModule, {
      Model,
    })
    controller.on('mutation', () => {
      hasEmitted = true
    })
    controller.model.set(['foo'], 'baz2')
    assert.ok(hasEmitted)
  })
  it('should throw when updating invalid nested path', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const model = new BaseController(rootModule, {
      Model,
    }).model
    assert.throws(() => {
      model.set(['foo', 'bar', 'baz'], 'baz2')
    })
  })

  describe('SET', () => {
    it('should be able to set state', () => {
      const rootModule = {
        state: {},
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model

      model.set(['foo'], 'bar')
      assert.deepStrictEqual(model.get(), { foo: 'bar' })
    })
  })
  describe('TOGGLE', () => {
    it('should be able to toggle value', () => {
      const rootModule = {
        state: {
          foo: true,
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.toggle(['foo'])
      assert.deepStrictEqual(model.get(), { foo: false })
    })
  })
  describe('PUSH', () => {
    it('should be able to push to array', () => {
      const rootModule = {
        state: {
          list: [],
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.push(['list'], 'bar')
      assert.deepStrictEqual(model.get(), { list: ['bar'] })
    })
  })
  describe('MERGE', () => {
    it('should be able to merge objects', () => {
      const rootModule = {
        state: {
          foo: {
            valA: 'foo',
          },
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.merge(['foo'], { valB: 'bar' })
      assert.deepStrictEqual(model.get(), { foo: { valA: 'foo', valB: 'bar' } })
    })
    it('should flush changes to merged keys when object exists', () => {
      const rootModule = {
        state: {
          foo: {
            valA: 'foo',
          },
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.merge(['foo'], { valB: 'bar' })
      assert.deepStrictEqual(model.flush(), [
        {
          path: ['foo', 'valB'],
          forceChildPathUpdates: true,
        },
      ])
    })
    it('should flush change on object only if no existing object', () => {
      const rootModule = {
        state: {
          foo: null,
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.merge(['foo'], { valB: 'bar' })
      assert.deepStrictEqual(model.flush(), [
        {
          path: ['foo'],
          forceChildPathUpdates: true,
        },
      ])
    })
  })
  describe('POP', () => {
    it('should be able to pop arrays', () => {
      const rootModule = {
        state: {
          list: ['foo', 'bar'],
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.pop(['list'])
      assert.deepStrictEqual(model.get(), { list: ['foo'] })
    })
  })
  describe('SHIFT', () => {
    it('should be able to shift arrays', () => {
      const rootModule = {
        state: {
          list: ['foo', 'bar'],
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.shift(['list'])
      assert.deepStrictEqual(model.get(), { list: ['bar'] })
    })
  })
  describe('UNSHIFT', () => {
    it('should be able to unshift arrays', () => {
      const rootModule = {
        state: {
          list: ['foo'],
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.unshift(['list'], 'bar')
      assert.deepStrictEqual(model.get(), { list: ['bar', 'foo'] })
    })
  })
  describe('SPLICE', () => {
    it('should be able to splice arrays', () => {
      const rootModule = {
        state: {
          list: ['foo', 'bar'],
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.splice(['list'], 1, 1, 'bar2')
      assert.deepStrictEqual(model.get(), { list: ['foo', 'bar2'] })
    })
  })
  describe('UNSET', () => {
    it('should be able to unset keys', () => {
      const rootModule = {
        state: {
          foo: 'bar',
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.unset(['foo'])
      assert.deepStrictEqual(model.get(), {})
    })
    it('should flush unset paths', () => {
      const rootModule = {
        state: {
          foo: {
            bar: 'value',
          },
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.unset(['foo', 'bar'])
      assert.deepStrictEqual(model.flush(), [
        {
          path: ['foo', 'bar'],
          forceChildPathUpdates: true,
        },
      ])
    })
  })
  describe('CONCAT', () => {
    it('should be able to concat array', () => {
      const rootModule = {
        state: {
          foo: ['foo'],
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.concat(['foo'], ['bar'])
      assert.deepStrictEqual(model.get(), { foo: ['foo', 'bar'] })
    })
  })
  describe('INCREMENT', () => {
    it('should increment with default of 1', () => {
      const rootModule = {
        state: {
          foo: 3,
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.increment(['foo'])
      assert.deepStrictEqual(model.get(), { foo: 4 })
    })
    it('should increment with given value', () => {
      const rootModule = {
        state: {
          foo: 3,
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      model.increment(['foo'], 2)
      assert.deepStrictEqual(model.get(), { foo: 5 })
    })
    it('should raise on invalid target', () => {
      const rootModule = {
        state: {
          foo: 'hello',
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      assert.throws(() => model.increment(['foo'], 2), 'xxx')
    })
    it('should raise on invalid increment value', () => {
      const rootModule = {
        state: {
          foo: 4,
        },
      }
      const model = new BaseController(rootModule, {
        Model,
      }).model
      assert.throws(() => model.increment(['foo'], 'hop'), 'xxx')
    })
  })
  describe('Serializable', () => {
    it('should make value forceSerializable when devtools are attached', () => {
      const rootModule = {
        state: {
          foo: 'bar',
        },
      }
      const model = new BaseController(rootModule, {
        Model,
        devtools: {
          allowedTypes: [Date],
          init() {},
        },
      }).model
      model.set(['foo'], new Date())
      assert.strictEqual(model.state.foo.toJSON(), '[Date]')
    })
    it('should throw error if value inserted is not serializable', () => {
      const rootModule = {
        state: {
          foo: 'bar',
        },
      }
      const model = new BaseController(rootModule, {
        Model,
        devtools: { init() {} },
      }).model
      assert.throws(() => {
        model.set(['foo'], new Date())
      })
    })
    it('should NOT throw error if value inserted is serializable', () => {
      const rootModule = {
        state: {
          foo: 'bar',
        },
      }
      const model = new BaseController(rootModule, {
        Model,
        devtools: { init() {} },
      }).model
      assert.doesNotThrow(() => {
        model.set(['foo'], [])
      })
    })
    it('should NOT throw error if passing allowed type in devtools', () => {
      const rootModule = {
        state: {
          foo: 'bar',
        },
      }
      const model = new BaseController(rootModule, {
        Model,
        devtools: { allowedTypes: [Date], init() {} },
      }).model
      assert.doesNotThrow(() => {
        model.set(['foo'], new Date())
      })
    })
    it('should NOT throw error if setting a value to a path not in state while devtools are open', () => {
      const rootModule = {
        state: {},
      }
      const model = new BaseController(rootModule, {
        Model,
        devtools: { init() {} },
      }).model
      assert.doesNotThrow(() => {
        model.set(['bar', 'baz'], 1)
      })
    })
  })
})
