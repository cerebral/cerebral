import { Tag } from './tags'
import { Compute, NestedComputedValue } from './Compute'
import { Provider } from 'function-tree'

export function getChangedProps(propsA = {}, propsB = {}) {
  const propsAKeys = Object.keys(propsA)
  const propsBKeys = Object.keys(propsB)
  const changedProps = []

  for (let i = 0; i < propsAKeys.length; i++) {
    if (propsA[propsAKeys[i]] !== propsB[propsAKeys[i]]) {
      changedProps.push({ path: [propsAKeys[i]] })
    }
  }

  for (let i = 0; i < propsBKeys.length; i++) {
    if (propsA[propsBKeys[i]] !== propsB[propsBKeys[i]]) {
      changedProps.push({ path: [propsBKeys[i]] })
    }
  }

  return changedProps
}

export function cleanPath(path) {
  return typeof path === 'string' ? path.replace(/\.\*\*|\.\*/, '') : path
}

export function isObject(obj) {
  return typeof obj === 'object' && obj !== null && !Array.isArray(obj)
}

export function isComplexObject(obj) {
  return typeof obj === 'object' && obj !== null
}

export function isSerializable(value, additionalTypes = []) {
  const validType = additionalTypes.reduce((currentValid, type) => {
    if (currentValid || value instanceof type) {
      return true
    }

    return currentValid
  }, false)

  if (
    value !== undefined &&
    (validType ||
      (isObject(value) &&
        Object.prototype.toString.call(value) === '[object Object]' &&
        (value.constructor === Object ||
          Object.getPrototypeOf(value) === null)) ||
      typeof value === 'number' ||
      typeof value === 'string' ||
      typeof value === 'boolean' ||
      value === null ||
      Array.isArray(value))
  ) {
    return true
  }
  return false
}

export function ensurePath(path = []) {
  if (Array.isArray(path)) {
    return path
  } else if (typeof path === 'string') {
    return path.split('.')
  }

  return []
}

export function throwError(message) {
  throw new Error(`Cerebral - ${message}`)
}

export function isDeveloping() {
  return process.env.NODE_ENV !== 'production'
}

export function debounce(func, wait, immediate) {
  let timeout
  return function() {
    const context = this
    const args = arguments
    const later = function() {
      timeout = null
      if (!immediate) func.apply(context, args)
    }
    const callNow = immediate && !timeout
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
    if (callNow) func.apply(context, args)
  }
}

export function forceSerializable(value) {
  if (value && !isSerializable(value)) {
    const name = value.constructor.name

    try {
      Object.defineProperty(value, 'toJSON', {
        value() {
          return `[${name}]`
        },
      })
    } catch (e) {}
  }

  return value
}

export function getProviders(module) {
  return Object.assign(
    Object.keys(module.providers || {}).reduce(
      (currentProviders, providerKey) => {
        currentProviders[providerKey] =
          module.providers[providerKey] instanceof Provider
            ? module.providers[providerKey]
            : new Provider(module.providers[providerKey])

        return currentProviders
      },
      {}
    ),
    Object.keys(module.modules || {}).reduce((nestedProviders, moduleKey) => {
      return Object.assign(
        nestedProviders,
        getProviders(module.modules[moduleKey])
      )
    }, {})
  )
}

function extractAllChildMatches(children) {
  return Object.keys(children).reduce((matches, key) => {
    if (children[key].children) {
      return matches
        .concat(children[key])
        .concat(extractAllChildMatches(children[key].children))
    }

    return matches.concat(children[key])
  }, [])
}

export function dependencyMatch(changes, dependencyMap) {
  let currentMatches = []

  for (let changeIndex = 0; changeIndex < changes.length; changeIndex++) {
    let currentDependencyMapLevel = dependencyMap
    for (
      let pathKeyIndex = 0;
      pathKeyIndex < changes[changeIndex].path.length;
      pathKeyIndex++
    ) {
      if (!currentDependencyMapLevel) {
        break
      }

      if (currentDependencyMapLevel['**']) {
        currentMatches.push(currentDependencyMapLevel['**'])
      }

      if (pathKeyIndex === changes[changeIndex].path.length - 1) {
        const dependency =
          currentDependencyMapLevel[changes[changeIndex].path[pathKeyIndex]]
        if (dependency) {
          currentMatches.push(dependency)

          if (dependency.children) {
            if (changes[changeIndex].forceChildPathUpdates) {
              currentMatches = currentMatches.concat(
                extractAllChildMatches(dependency.children)
              )
            } else {
              if (dependency.children['**']) {
                currentMatches.push(dependency.children['**'])
              }

              if (dependency.children['*']) {
                currentMatches.push(dependency.children['*'])
              }
            }
          }
        }

        if (currentDependencyMapLevel['*']) {
          currentMatches.push(currentDependencyMapLevel['*'])
        }
      }

      if (!currentDependencyMapLevel[changes[changeIndex].path[pathKeyIndex]]) {
        currentDependencyMapLevel = null
        break
      }

      currentDependencyMapLevel =
        currentDependencyMapLevel[changes[changeIndex].path[pathKeyIndex]]
          .children
    }
  }

  return currentMatches
}

export function getWithPath(obj) {
  return (path) => {
    return path.split('.').reduce((currentValue, key, index) => {
      if (index > 0 && currentValue === undefined) {
        throwError(
          `You are extracting with path "${path}", but it is not valid for this object`
        )
      }

      return currentValue[key]
    }, obj)
  }
}

export function ensureStrictPath(path, value) {
  if (isComplexObject(value) && path.indexOf('*') === -1) {
    return `${path}.**`
  }

  return path
}

export function createResolver(getters) {
  return {
    isTag(arg, ...types) {
      if (!(arg instanceof Tag)) {
        return false
      }

      if (types.length) {
        return types.reduce((isType, type) => {
          return isType || type === arg.type
        }, false)
      }

      return true
    },
    isCompute(arg) {
      return isComputedValue(arg)
    },
    value(arg, overrideProps) {
      if (arg instanceof Tag || isComputedValue(arg)) {
        return arg.getValue(
          overrideProps
            ? Object.assign({}, getters, { props: overrideProps })
            : getters
        )
      }

      return arg
    },
    path(arg) {
      if (arg instanceof Tag) {
        return arg.getPath(getters)
      }

      throwError('You are extracting a path from an argument that is not a Tag')
    },
  }
}

export const noop = () => {}

/*
  When testing and running on the server there is no need to
  initialize all of Cerebral. So by not passing a controller
  to this Container it will create a dummy version which inserts
  state and mocks any sequences when connecting the component.
*/
export function createDummyController(state = {}, sequences = {}) {
  const getState = (path) => {
    return ensurePath(path).reduce((currentState, pathKey) => {
      return currentState ? currentState[pathKey] : undefined
    }, state)
  }
  return {
    options: {},
    on() {},
    getState,
    model: {
      get: getState,
    },
    getSequence(sequence) {
      return sequences[sequence] || (() => {})
    },
    dependencyStore: {
      addEntity: noop,
      removeEntity: noop,
    },
  }
}

export function addCerebralStateKey(object) {
  if (isComplexObject(object) && !(object instanceof Compute)) {
    for (const key in object) {
      addCerebralStateKey(object[key])
    }

    !object.__CerebralState &&
      Object.defineProperty(object, '__CerebralState', {
        value: true,
      })
  }

  return object
}

export function getStateTreeProp(props = {}) {
  return Object.keys(props).reduce((hit, key) => {
    if (
      !hit &&
      isComplexObject(props[key]) &&
      '__CerebralState' in props[key]
    ) {
      return key
    }

    return hit
  }, null)
}

export function getModule(path, modules) {
  const pathArray = Array.isArray(path) ? path : ensurePath(path)
  return pathArray.reduce((currentModule, key) => {
    if (!currentModule.modules[key]) {
      throwError(
        `The path "${pathArray.join(
          '.'
        )}" is invalid, can not find module. Does the path "${pathArray
          .splice(0, path.length - 1)
          .join('.')}" exist?`
      )
    }
    return currentModule.modules[key]
  }, modules)
}

export function extractModuleProp(module, prop, transform) {
  const extracted = Object.keys(module.modules || {}).reduce(
    (additionalExtracted, subModuleKey) => {
      additionalExtracted[subModuleKey] = extractModuleProp(
        module.modules[subModuleKey],
        prop,
        transform
      )

      return additionalExtracted
    },
    {}
  )

  if (module[prop]) {
    const extractedWithGetters = Object.keys(module[prop]).reduce(
      (currentExtracted, key) => {
        const propertyDescriptor = Object.getOwnPropertyDescriptor(
          module[prop],
          key
        )
        if (propertyDescriptor && 'get' in propertyDescriptor) {
          Object.defineProperty(currentExtracted, key, propertyDescriptor)
        } else {
          currentExtracted[key] = module[prop][key]
        }

        return currentExtracted
      },
      extracted
    )

    return transform
      ? transform(extractedWithGetters, module)
      : extractedWithGetters
  }

  return extracted
}

const deprecationWarnings = []
export function DEPRECATE(type, message) {
  if (deprecationWarnings.indexOf(type) === -1) {
    deprecationWarnings.push(type)
    console.warn(type + ' is DEPRECATED - ' + message)
  }
}

export function getRootPath(path, context) {
  const executionPath = context.execution.name.split('.')
  const modulePath = executionPath.splice(0, executionPath.length - 1)

  return modulePath.concat(path).join('.')
}

export function isComputedValue(value) {
  return value instanceof Compute || value instanceof NestedComputedValue
}

export function getStateChanges(originState, oldState, nextState) {
  const changes = []

  function getChanges(origin, old, next, path = []) {
    if (isComputedValue(old) || isComputedValue(next)) {
      return next
    }

    if (isObject(old) && isObject(next)) {
      const keys = Object.keys(old)
        .concat(Object.keys(next))
        .reduce((aggr, key) => {
          return aggr.indexOf(key) === -1 ? aggr.concat(key) : aggr
        }, [])

      for (const key of keys) {
        getChanges(origin[key], old[key], next[key], path.concat(key))
      }

      return
    }

    if (typeof next === 'function') {
      return
    }

    // We return the existing array, as arrays are typically
    // mutated, not set with new values as initial state
    if (Array.isArray(old) && Array.isArray(next)) {
      changes.push({
        path: path.slice(),
        value: old,
      })
      return
    }

    // If we have changed a state from origin, keep that
    // changed state
    if (next === origin && old !== origin) {
      changes.push({
        path: path.slice(),
        value: old,
      })
    }
  }

  getChanges(originState, oldState, nextState)

  return changes
}
