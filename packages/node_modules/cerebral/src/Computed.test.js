/* eslint-env mocha */
import { Controller, Module, Computed } from './'
import { state, props, module, computed } from './tags'
import assert from 'assert'

describe('Computed', () => {
  it('should Computed a value', () => {
    const foo = Computed(() => {
      return 'foo'
    })
    const app = Module({
      computeds: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'foo')
  })
  it('should Computed a clone', () => {
    const foo = Computed(() => {
      return 'foo'
    })
    const app = Module({
      computeds: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(
      controller
        .getComputed('foo')
        .clone()
        .getValue(),
      'foo'
    )
  })
  it('should cache value', () => {
    let count = 0
    const foo = Computed(() => {
      return count++
    })
    const app = Module({
      computeds: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 0)
    assert.equal(controller.getComputed('foo').getValue(), 0)
  })
  it('should Computed state', () => {
    const foo = Computed(
      {
        foo: state`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computeds: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
  })
  it('should update Computed when state changes', () => {
    const foo = Computed(
      {
        foo: state`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computeds: {
        foo,
      },
      signals: {
        updateFoo: ({ state }) => {
          state.set('foo', 'bar2')
        },
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
    controller.getSignal('updateFoo')()
    assert.equal(controller.getComputed('foo').getValue(), 'bar2')
  })
  it('should Computed module', () => {
    const foo = Computed(
      {
        foo: module`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computeds: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
  })
  it('should update Computed when module changes', () => {
    const foo = Computed(
      {
        foo: module`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computeds: {
        foo,
      },
      signals: {
        updateFoo: ({ state }) => {
          state.set('foo', 'bar2')
        },
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
    controller.getSignal('updateFoo')()
    assert.equal(controller.getComputed('foo').getValue(), 'bar2')
  })
  it('should Computed props', () => {
    const foo = Computed(
      {
        foo: props`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      computeds: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(
      controller.getComputed('foo').getValue({
        foo: 'bar',
      }),
      'bar'
    )
  })
  it('should Computed computed tag', () => {
    const foo = Computed(() => {
      return 'foo'
    })
    const bar = Computed(
      {
        foo: computed`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      computeds: {
        foo,
        bar,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('bar').getValue(), 'foo')
  })
  it('should Computed when computed updates', () => {
    const foo = Computed(
      {
        foo: state`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const bar = Computed(
      {
        foo: computed`foo`,
      },
      ({ foo }) => {
        return foo
      }
    )
    const app = Module({
      state: {
        foo: 'bar',
      },
      computeds: {
        foo,
        bar,
      },
      signals: {
        updateFoo: ({ state }) => {
          state.set('foo', 'bar2')
        },
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('bar').getValue(), 'bar')
    controller.getSignal('updateFoo')()
    assert.equal(controller.getComputed('bar').getValue(), 'bar2')
  })
  it('should Computed dynamically', () => {
    const foo = Computed(({ get }) => {
      return get(state`foo`)
    })
    const app = Module({
      state: {
        foo: 'bar',
      },
      computeds: {
        foo,
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
  })
  it('should Computed dynamically when updated', () => {
    const foo = Computed(({ get }) => {
      return get(state`foo`)
    })
    const app = Module({
      state: {
        foo: 'bar',
      },
      computeds: {
        foo,
      },
      signals: {
        updateFoo: ({ state }) => {
          state.set('foo', 'bar2')
        },
      },
    })
    const controller = Controller(app)
    assert.equal(controller.getComputed('foo').getValue(), 'bar')
    controller.getSignal('updateFoo')()
    assert.equal(controller.getComputed('foo').getValue(), 'bar2')
  })
})
