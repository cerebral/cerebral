import { Path, Primitive } from 'function-tree'

import Controller from '../Controller'
import Module from '../Module'
import { cleanPath, ensurePath } from '../utils'
import { state } from '..'

export { default as Snapshot } from './snapshot'

export function runCompute(compute, fixtures = {}) {
  let response
  const rootModule = new Module({
    state: Object.assign(fixtures.state || {}, { compute }),
    sequences: {
      test: [
        ({ get }) => {
          response = get(state`compute`, fixtures.props)
        },
      ],
    },
  })
  const controller = new Controller(rootModule)
  controller.getSequence('test')(fixtures.props)

  return response
}

export function runSequence(sequence, fixtures = {}, options = {}) {
  return new Promise((resolve, reject) => {
    const recordActions =
      options.recordActions && options.recordActions === 'byName'
        ? 'name'
        : 'functionIndex'
    const isSequence = Array.isArray(sequence) || sequence instanceof Primitive
    const controller =
      options.controller ||
      new Controller(
        new Module(
          Object.assign({}, fixtures, isSequence && { sequences: { sequence } })
        ),
        { noRethrow: true, returnSequencePromise: true }
      )
    const response = { controller }

    const actionStart = function(execution, funcDetails, payload) {
      if (options.singleAction) {
        response.props = payload
      } else {
        if (
          !options.noDuplicateWarnings &&
          response[funcDetails[recordActions]]
        ) {
          console.warn(
            `Cerebral[runSequence]: sequence contains actions with duplicate names ('${
              funcDetails[recordActions]
            }')`
          )
        }
        response[funcDetails[recordActions]] = { props: payload }
      }
    }

    const actionEnd = function(execution, funcDetails, payload, result) {
      if (!result || (result instanceof Path && !result.payload)) {
        return
      }
      if (options.singleAction || response[funcDetails[recordActions]]) {
        const output = result instanceof Path ? result.payload : result
        if (options.singleAction) {
          response.output = output
        } else {
          response[funcDetails[recordActions]].output = output
        }
      }
    }

    const error = function(err) {
      off()
      reject(err)
    }

    const sequenceEnd = () => {
      off()
      response.state = controller.getState()
      resolve(response)
    }

    const off = function() {
      controller.off('functionStart', actionStart)
      controller.off('functionEnd', actionEnd)
      controller.off('error', error)
    }

    controller.on('functionStart', actionStart)
    controller.on('functionEnd', actionEnd)
    controller.on('error', error)
    const seq = controller.getSequence(isSequence ? 'sequence' : sequence)
    if (typeof seq === 'function') {
      seq(fixtures.props).then(sequenceEnd).catch(error)
    } else {
      throw new Error(
        `'${isSequence ? 'sequence' : sequence}' is not a function.`
      )
    }
  })
}

export function CerebralTest(rootModule, options = { throwToConsole: false }) {
  const controller = new Controller(
    rootModule,
    Object.assign({}, { noRethrow: true, returnSequencePromise: true }, options)
  )
  const model = controller.getModel()
  return {
    controller,
    runSequence(sequence, props = {}) {
      return runSequence(
        sequence,
        { props },
        Object.assign({}, options, { controller, noDuplicateWarnings: true })
      )
    },
    setState(path, value) {
      model.set(ensurePath(cleanPath(path)), value)
      model.flush()
    },
    getState(path) {
      return model.get(ensurePath(cleanPath(path)))
    },
  }
}

export function runAction(action, fixtures = {}) {
  return runSequence([action], fixtures, {
    recordActions: true,
    singleAction: true,
  })
}
