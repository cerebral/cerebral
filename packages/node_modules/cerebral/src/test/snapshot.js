import { Controller } from '../'
import { Provider as FTProvider } from 'function-tree'
import { DevtoolsBase } from 'function-tree/devtools'
import { ensurePath } from '../utils'

class Action {
  constructor(name) {
    this.name = name
  }
}

class Mutation {
  constructor(mutation) {
    this.method = mutation.method
    this.path = mutation.args.shift().join('.')
    this.args = mutation.args
  }
}

class Provider {
  constructor(provider) {
    this.method = provider.method
    this.args = provider.args
  }
}

class Path {
  constructor(name) {
    this.name = name
  }
}

class SnapshotDevtool extends DevtoolsBase {
  createSocket() {
    this.isConnected = true
    this.ws = {
      onopen() {},
      onerror() {},
      onclose() {},
      send(...args) {},
    }
  }
  createExecutionMessage(data, execution, functionDetails) {
    return {
      type: data.type || 'provider',
      functionIndex: functionDetails.functionIndex,
      method: data.method,
      args: data.args,
    }
  }
  updateWatchMap() {}
  updateComputedMap() {}
  sendWatchMap() {}
}

class MockedProvider extends FTProvider {
  constructor(name, provider, mocks) {
    super({})
    this.name = name
    this.provider = provider
    this.mocks = mocks
  }
  getWrapped(providerName, context) {
    const definition = this.provider.WrappedProviderConstructor.prototype
    return Object.keys(definition).reduce((mockedProvider, key) => {
      mockedProvider[key] = (...args) => {
        context.debugger.send({
          method: `${providerName}.${key}`,
          args: args,
        })

        const nextMock = this.mocks.shift()

        if (!nextMock) {
          throw new Error(
            `"${this.name}.${key}" was called, but there is no mock for it`
          )
        }

        if (nextMock.path !== `${this.name}.${key}`) {
          throw new Error(
            `The expected mock "${nextMock.path}" does not match "${
              this.name
            }.${key}"`
          )
        }

        if (nextMock.isAsync) {
          return nextMock.isResolved
            ? Promise.resolve(nextMock.value)
            : Promise.reject(nextMock.value)
        }

        return nextMock.value
      }

      return mockedProvider
    }, {})
  }
}

const notWrappedProviders = [
  'state',
  'resolve',
  'moduleState',
  'debugger',
  'get',
  'store',
]

class Snapshot {
  constructor(rootModule) {
    this.controller = Controller(rootModule, {
      devtools: new SnapshotDevtool({
        host: 'local',
      }),
      preventInitialize: true,
    })
    this.controller.flush = () => {}
    this.app = this.controller
    this.mocks = []
    this.execution = []

    this.createMockedProviders()
  }
  createMockedProviders() {
    const providers = this.controller.contextProviders

    this.controller.contextProviders = Object.keys(providers).reduce(
      (wrappedProviders, provider) => {
        if (
          providers[provider] instanceof FTProvider &&
          notWrappedProviders.indexOf(provider) === -1
        ) {
          wrappedProviders[provider] = new MockedProvider(
            provider,
            providers[provider],
            this.mocks
          )
        } else {
          wrappedProviders[provider] = providers[provider]
        }

        return wrappedProviders
      },
      {}
    )
  }
  mutate(method, path, ...args) {
    this.controller.model[method].apply(
      this.controller.model,
      [ensurePath(path)].concat(args)
    )

    return this
  }
  mock(path, value) {
    this.mocks.push({ path, value })

    return this
  }
  mockResolvedPromise(path, value) {
    this.mocks.push({ path, value, isAsync: true, isResolved: true })

    return this
  }
  mockRejectedPromise(path, value) {
    this.mocks.push({ path, value, isAsync: true, isResolved: false })

    return this
  }
  run(sequencePath, payload) {
    if (this.staticTree) {
      throw new Error('You have already run this snapshot')
    }

    return new Promise((resolve, reject) => {
      const pathArray = ensurePath(sequencePath)
      const sequenceKey = pathArray.pop()
      const module = pathArray.reduce((currentModule, key) => {
        return currentModule ? currentModule.modules[key] : undefined
      }, this.controller.module)
      const sequence = module && module.sequences[sequenceKey]

      if (!sequence) {
        throw new Error(
          `The sequence on path "${sequencePath}" does not exist, please check path`
        )
      }

      this.controller.devtools.ws.send = (update) => {
        if (update.type === 'mutation') {
          this.execution.push(new Mutation(update))
        } else if (update.type === 'provider') {
          this.execution.push(new Provider(update))
        }
      }

      this.controller.on('functionStart', (execution, functionDetails) => {
        this.execution.push(new Action(functionDetails.name))
      })

      this.controller.on('pathStart', (name) => {
        this.execution.push(new Path(name))
      })

      this.controller.run(sequencePath, sequence.sequence, payload, (error) => {
        if (error) {
          reject(error)
        } else {
          resolve(this)
        }
      })
    })
  }
  get() {
    return this.execution
  }
}

export default (rootModule) => {
  return new Snapshot(rootModule)
}
