import assert from 'assert'

import { sequence } from '../factories'
import { props, state } from '../tags'
/* eslint-env mocha */
import { CerebralTest, runAction, runCompute, runSequence } from '.'

describe('test helpers', () => {
  describe('runCompute', () => {
    it('should test a Compute that gets state', () => {
      const testCompute = (get) => get(state`foo`)

      assert.strictEqual(runCompute(testCompute, { state: { foo: 'bar' } }), 'bar')
    })
    it('should test a Compute that gets props', () => {
      const testCompute = (get) => get(props`foo`)
      assert.strictEqual(runCompute(testCompute, { props: { foo: 'bar' } }), 'bar')
    })
  })

  describe('runAction', () => {
    it('should test an action that gets state', () => {
      const testAction = function testAction({ get }) {
        return { foo: get(state`foo`) }
      }
      return runAction(testAction, {
        state: { foo: 'bar' },
      }).then(({ output }) => assert.strictEqual(output.foo, 'bar'))
    })
    it('should test an action that gets props', () => {
      const testAction = function testAction({ props }) {
        return { foo: props.foo }
      }
      return runAction(testAction, {
        props: { foo: 'bar' },
      }).then(({ output }) => assert.strictEqual(output.foo, 'bar'))
    })
    it('should test an action that sets state', () => {
      const testAction = function testAction({ store }) {
        store.set(state`foo`, 'baz')
      }
      return runAction(testAction, {
        state: { foo: 'bar' },
      }).then(({ state }) => assert.strictEqual(state.foo, 'baz'))
    })
    it('should test async actions', () => {
      const testAction = function testAction() {
        return new Promise((resolve) => {
          setTimeout(() => resolve({ foo: 'bar' }), 1)
        })
      }
      return runAction(testAction).then(({ output }) =>
        assert.strictEqual(output.foo, 'bar')
      )
    })
    it('should throw errors if an async action throws an error', (done) => {
      const testAction = async function testAction() {
        throw new Error('this is an error');
      }
      runAction(testAction).catch(error => {
        assert.strictEqual(error.message, 'this is an error')
        done()
      })
    })
  })

  describe('runSequence', () => {
    it('should test a sequence with named actions', () => {
      const testSequence = [
        function action1({ props }) {
          return { bar: 'bar' }
        },
        function action2({ props }) {
          return { baz: 'baz' }
        },
      ]
      return runSequence(
        testSequence,
        { props: { foo: 'foo' } },
        { recordActions: 'byName' }
      ).then(({ action1, action2 }) => {
        assert.strictEqual(action1.props.foo, 'foo')
        assert.strictEqual(action1.output.bar, 'bar')
        assert.strictEqual(action2.props.bar, 'bar')
        assert.strictEqual(action2.output.baz, 'baz')
      })
    })
    it('should test a sequence with indexed actions', () => {
      const testSequence = [
        function action1({ props }) {
          return { bar: 'bar' }
        },
        function action2({ props }) {
          return { baz: 'baz' }
        },
      ]
      return runSequence(
        testSequence,
        { props: { foo: 'foo' } },
        { recordActions: true }
      ).then((response) => {
        assert.strictEqual(response[0].props.foo, 'foo')
        assert.strictEqual(response[0].output.bar, 'bar')
        assert.strictEqual(response[1].props.bar, 'bar')
        assert.strictEqual(response[1].output.baz, 'baz')
      })
    })
    it('should warn if sequence contains actions with duplicate names', () => {
      let warnCount = 0
      const originWarn = console.warn
      console.warn = function(...args) {
        warnCount++
      }
      const testSequence = [
        function action1({ props }) {
          return { bar: 'bar' }
        },
        function action1({ props }) {
          return { baz: 'baz' }
        },
      ]
      return runSequence(
        testSequence,
        { props: { foo: 'foo' } },
        { recordActions: 'byName' }
      ).then(({ action1 }) => {
        assert.strictEqual(warnCount, 1)
        console.warn = originWarn
      })
    })
    it('should test a sequence with sequence', () => {
      const testSequence = sequence([
        function action1({ props }) {
          return { bar: 'bar' }
        },
        function action2({ props }) {
          return { baz: 'baz' }
        },
      ])
      return runSequence(
        testSequence,
        { props: { foo: 'foo' } },
        { recordActions: 'byName' }
      ).then(({ action1, action2 }) => {
        assert.strictEqual(action1.props.foo, 'foo')
        assert.strictEqual(action1.output.bar, 'bar')
        assert.strictEqual(action2.props.bar, 'bar')
        assert.strictEqual(action2.output.baz, 'baz')
      })
    })
  })

  describe('CerebralTest factory', () => {
    let cerebral

    beforeEach(() => {
      const test = {
        state: { foo: 0 },
        sequences: {
          baz: [
            ({ get, store }) =>
              store.set(state`test.foo`, get(state`test.foo`) + 1),
          ],
        },
      }
      const rootModule = {
        modules: {
          test,
        },
      }
      cerebral = CerebralTest(rootModule)
    })

    it('should create a cerebral helper', () => {
      return cerebral.runSequence('test.baz').then(({ state }) => {
        assert.strictEqual(state.test.foo, 1)
        return cerebral.runSequence('test.baz').then(({ state }) => {
          assert.strictEqual(state.test.foo, 2)
        })
      })
    })

    it('can set state', () => {
      cerebral.setState('test.foo', 10)
      return cerebral.runSequence('test.baz').then(({ state }) => {
        assert.strictEqual(state.test.foo, 11)
      })
    })

    it('can get state', () => {
      return cerebral.runSequence('test.baz').then(() => {
        assert.strictEqual(cerebral.getState('test.foo'), 1)
      })
    })
  })
})
