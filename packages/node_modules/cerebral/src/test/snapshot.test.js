/* eslint-env mocha */
import { Module, ControllerClass, Provider, parallel, sequence } from '..'
import { Snapshot } from '.'
import assert from 'assert'

describe('snapshot test', () => {
  it('should instantiate a snapshot controller', () => {
    const app = Module({})
    const snapshot = Snapshot(app)

    assert(snapshot.controller instanceof ControllerClass)
  })
  it('should allow changing the initial state', () => {
    const app = Module({
      state: {
        foo: 'bar',
      },
    })
    const snapshot = Snapshot(app).mutate('set', 'foo', 'bar2')

    assert.equal(snapshot.controller.getState('foo'), 'bar2')
  })
  it('should mock out all providers', () => {
    let providerRun = false
    const provider = Provider({
      foo() {
        providerRun = true
      },
    })
    const app = Module({
      providers: {
        provider,
      },
      signals: {
        test: ({ provider }) => {
          provider.foo()
        },
      },
    })
    const snapshot = Snapshot(app)
      .mutate('set', 'foo', 'bar2')
      .mock('provider.foo', null)

    snapshot.controller.getSignal('test')()
    assert.equal(providerRun, false)
  })
  it('should return mocked data on providers', () => {
    let providerResult = null
    const provider = Provider({
      foo() {},
    })
    const app = Module({
      providers: {
        provider,
      },
      signals: {
        test: ({ provider }) => {
          providerResult = provider.foo()
        },
      },
    })
    const snapshot = Snapshot(app).mock('provider.foo', 'bar')

    snapshot.controller.getSignal('test')()
    assert.equal(providerResult, 'bar')
  })
  it('should return mocked data on async providers', done => {
    let hasRunAsyncAction = false
    const provider = Provider({
      foo() {
        return Promise.resolve()
      },
    })
    const app = Module({
      providers: {
        provider,
      },
      signals: {
        test: [
          ({ provider }) => {
            return provider.foo().then(result => ({ result }))
          },
          ({ props }) => {
            assert.equal(props.result, 'bar')
            hasRunAsyncAction = true
          },
        ],
      },
    })
    const snapshot = Snapshot(app).mockResolvedPromise('provider.foo', 'bar')

    snapshot.controller.getSignal('test')()
    assert.equal(hasRunAsyncAction, false)
    setTimeout(() => {
      assert.equal(hasRunAsyncAction, true)
      done()
    })
  })
  it('should throw when missing mock', () => {
    const provider = Provider({
      foo() {},
    })
    const app = Module({
      providers: {
        provider,
      },
      signals: {
        test: ({ provider }) => {
          provider.foo()
        },
      },
    })
    const snapshot = Snapshot(app)

    assert.throws(() => {
      snapshot.controller.getSignal('test')()
    }, 'missing mock')
  })
  it('should throw when wrong', () => {
    const provider = Provider({
      foo() {},
    })
    const app = Module({
      providers: {
        provider,
      },
      signals: {
        test: ({ provider }) => {
          provider.foo()
        },
      },
    })
    const snapshot = Snapshot(app).mock('provider.fo', 'bar')

    assert.throws(() => {
      snapshot.controller.getSignal('test')()
    }, 'wrong mock')
  })
  it('should produce a snapshot', () => {
    const provider = Provider({
      foo() {},
    })
    const app = Module({
      providers: {
        provider,
      },
      state: {
        foo: 'bar',
      },
      signals: {
        test: sequence('test', [
          function runProvider({ provider }) {
            return {
              bah: provider.foo(),
            }
          },
          function runStateChange({ props, state, path }) {
            state.set('foo', props.bah)

            return path.foo()
          },
          {
            foo: [],
          },
          parallel([function par1() {}, function par2() {}]),
        ]),
      },
    })

    return Snapshot(app)
      .mock('provider.foo', 'bar2')
      .run('test', {})
      .then(snapshot => {
        assert.deepEqual(snapshot.get(), [
          {
            name: 'runProvider',
          },
          {
            method: 'provider.foo',
            args: [],
          },
          {
            name: 'runStateChange',
          },
          {
            method: 'set',
            path: 'foo',
            args: ['bar2'],
          },
          {
            name: 'foo',
          },
          {
            name: 'par1',
          },
          {
            name: 'par2',
          },
        ])
      })
  })
})
