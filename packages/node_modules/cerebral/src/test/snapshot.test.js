/* eslint-env mocha */
import { ControllerClass, Provider, state } from '..'
import { parallel, sequence } from '../factories'

import { Snapshot } from '.'
import assert from 'assert'

describe('snapshot test', () => {
  it('should instantiate a snapshot controller', () => {
    const app = {}
    const snapshot = Snapshot(app)

    assert(snapshot.controller instanceof ControllerClass)
  })
  it('should allow changing the initial state', () => {
    const app = {
      state: {
        foo: 'bar',
      },
    }
    const snapshot = Snapshot(app).mutate('set', 'foo', 'bar2')

    assert.equal(snapshot.controller.getState('foo'), 'bar2')
  })
  it('should mock out all providers', () => {
    let providerRun = false
    const provider = Provider({
      foo() {
        providerRun = true
      },
    })
    const app = {
      providers: {
        provider,
      },
      sequences: {
        test: ({ provider }) => {
          provider.foo()
        },
      },
    }
    const snapshot = Snapshot(app)
      .mutate('set', 'foo', 'bar2')
      .mock('provider.foo', null)

    snapshot.controller.getSequence('test')()
    assert.equal(providerRun, false)
  })
  it('should return mocked data on providers', () => {
    let providerResult = null
    const provider = Provider({
      foo() {},
    })
    const app = {
      providers: {
        provider,
      },
      sequences: {
        test: ({ provider }) => {
          providerResult = provider.foo()
        },
      },
    }
    const snapshot = Snapshot(app).mock('provider.foo', 'bar')

    snapshot.controller.getSequence('test')()
    assert.equal(providerResult, 'bar')
  })
  it('should call mocked function on providers', () => {
    let providerResult = null
    let fooCalled = false
    const provider = Provider({
      foo() {},
    })
    const app = {
      providers: {
        provider,
      },
      sequences: {
        test: ({ provider }) => {
          providerResult = provider.foo()
        },
      },
    }
    const snapshot = Snapshot(app).mock('provider.foo', () => {
      fooCalled = true
      return 'bar'
    })

    snapshot.controller.getSequence('test')()
    assert.equal(providerResult, 'bar')
    assert.equal(fooCalled, true)
  })
  it('should return mocked data on async providers', (done) => {
    let hasRunAsyncAction = false
    const provider = Provider({
      foo() {
        return Promise.resolve()
      },
    })
    const app = {
      providers: {
        provider,
      },
      sequences: {
        test: [
          ({ provider }) => {
            return provider.foo().then((result) => ({ result }))
          },
          ({ props }) => {
            assert.equal(props.result, 'bar')
            hasRunAsyncAction = true
          },
        ],
      },
    }
    const snapshot = Snapshot(app).mockResolvedPromise('provider.foo', 'bar')

    snapshot.controller.getSequence('test')()
    assert.equal(hasRunAsyncAction, false)
    setTimeout(() => {
      assert.equal(hasRunAsyncAction, true)
      done()
    })
  })
  it('should throw when missing mock', () => {
    const provider = Provider({
      foo() {},
    })
    const app = {
      providers: {
        provider,
      },
      sequences: {
        test: ({ provider }) => {
          provider.foo()
        },
      },
    }
    const snapshot = Snapshot(app)

    assert.throws(() => {
      snapshot.controller.getSequence('test')()
    }, 'missing mock')
  })
  it('should throw when wrong', () => {
    const provider = Provider({
      foo() {},
    })
    const app = {
      providers: {
        provider,
      },
      sequences: {
        test: ({ provider }) => {
          provider.foo()
        },
      },
    }
    const snapshot = Snapshot(app).mock('provider.fo', 'bar')

    assert.throws(() => {
      snapshot.controller.getSequence('test')()
    }, 'wrong mock')
  })
  it('should produce a snapshot', () => {
    const provider = Provider({
      foo() {},
    })
    const app = {
      providers: {
        provider,
      },
      state: {
        foo: 'bar',
      },
      sequences: {
        test: sequence('test', [
          function runProvider({ provider }) {
            return {
              bah: provider.foo(),
            }
          },
          function runStateChange({ props, store, path }) {
            store.set(state`foo`, props.bah)

            return path.foo()
          },
          {
            foo: [],
          },
          parallel([function par1() {}, function par2() {}]),
        ]),
      },
    }

    return Snapshot(app)
      .mock('provider.foo', 'bar2')
      .run('test', {})
      .then((snapshot) => {
        assert.deepEqual(snapshot.get(), [
          {
            name: 'runProvider',
          },
          {
            method: 'provider.foo',
            args: [],
          },
          {
            name: 'runStateChange',
          },
          {
            method: 'set',
            path: 'foo',
            args: ['bar2'],
          },
          {
            name: 'foo',
          },
          {
            name: 'par1',
          },
          {
            name: 'par2',
          },
        ])
      })
  })
})
