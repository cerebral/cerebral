/* eslint-env mocha */
/* eslint-disable no-global-assign */
import App, { state, props } from './'
import { set } from './factories'

import assert from 'assert'

describe('App', () => {
  it('should instantiate with initial state', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = App(rootModule)
    assert.deepStrictEqual(controller.getState(), { foo: 'bar' })
  })
  it('should be able to get directly from app', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = App(rootModule)
    assert.deepStrictEqual(controller.get(state`foo`), 'bar')
  })
  it('should instantiate with universal state', () => {
    window = { CEREBRAL_STATE: { foo: 'bar2' } }
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = App(rootModule)
    assert.deepStrictEqual(controller.getState(), { foo: 'bar2' })
    delete window.CEREBRAL_STATE
  })
  it('should warn devtools recommendation', () => {
    let warnCount = 0
    const rootModule = {
      state: {},
    }
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
    }
    navigator = { userAgent: 'Chrome' }
    App(rootModule)
    assert.strictEqual(warnCount, 1)
    console.warn = originWarn
    navigator = { userAgent: 'node.js' }
  })
  it('should throw error when sequences are grabbed before initialized', () => {
    assert.throws(() => {
      const testModule = ({ app }) => {
        app.getSequence('foo')

        return {}
      }
      const rootModule = {
        sequences: {
          foo: [],
        },
        modules: {
          test: testModule,
        },
      }

      App(rootModule)
    }, /initialized/)
  })
  it('should instantiate with sequences defined', () => {
    const rootModule = {
      sequences: {
        foo: [],
      },
    }
    const controller = App(rootModule)
    assert.ok(controller.getSequence('foo'))
  })
  it('should instantiate providers defined', () => {
    const rootModule = {
      sequences: {
        foo: [
          function testAction(context) {
            assert.strictEqual(context.foo.getBar(), 'bar')
          },
        ],
      },
      providers: {
        foo: {
          getBar() {
            return 'bar'
          },
        },
      },
    }
    const controller = App(rootModule)
    controller.getSequence('foo')()
  })
  it('should instantiate modules defined as objects', () => {
    const fooModule = {
      state: {
        foo: 'bar',
      },
    }
    const rootModule = {
      modules: {
        foo: fooModule,
      },
    }
    const controller = App(rootModule)
    assert.deepStrictEqual(controller.getState(), { foo: { foo: 'bar' } })
  })
  it('should instantiate modules defined as functions', () => {
    const fooModule = () => ({
      state: {
        foo: 'bar',
      },
    })
    const rootModule = {
      modules: {
        foo: fooModule,
      },
    }
    const controller = App(rootModule)
    assert.deepStrictEqual(controller.getState(), { foo: { foo: 'bar' } })
  })
  it('should pass instance of app and path info on functions module instantiation', () => {
    const barModule = ({ app, path, name }) => {
      assert.ok(app)
      assert.strictEqual(name, 'bar')
      assert.strictEqual(path, 'foo.bar')
      return {
        state: {
          foo: 'bar',
        },
      }
    }
    const fooModule = {
      modules: {
        bar: barModule,
      },
    }
    const rootModule = {
      modules: {
        foo: fooModule,
      },
    }
    const controller = App(rootModule)
    assert.deepStrictEqual(controller.getState(), {
      foo: { bar: { foo: 'bar' } },
    })
  })
  it('should expose method to get sequences', () => {
    const moduleA = {
      sequences: {
        foo: [],
      },
    }
    const rootModule = {
      sequences: {
        foo: [],
      },
      modules: {
        moduleA,
      },
    }
    const controller = App(rootModule)
    assert.ok(controller.getSequence('foo'))
    assert.ok(controller.getSequence('moduleA.foo'))
    assert.ok(controller.getSequences('moduleA'))
  })
  it('should expose method to get model', () => {
    const moduleA = {
      sequences: {
        foo: [],
      },
    }
    const rootModule = {
      sequences: {
        foo: [],
      },
      modules: {
        moduleA,
      },
    }
    const controller = App(rootModule)
    assert.strictEqual(controller.getModel(), controller.model)
  })
  it('should create JSON stringify friendly value of unserializable payload property to sequence', () => {
    const rootModule = {
      sequences: {
        foo: [
          ({ props }) =>
            assert.strictEqual(JSON.stringify(props), '{"date":"[Date]"}'),
        ],
      },
    }
    const controller = App(rootModule, {
      devtools: { init() {}, allowedTypes: [Date] },
    })
    controller.getSequence('foo')({
      date: new Date(),
    })
  })
  it('should warn unserializable payload', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
    }

    const rootModule = {
      sequences: {
        foo: [() => {}],
      },
    }
    const controller = App(rootModule, {
      devtools: { init() {} },
    })
    class Test {}
    controller.getSequence('foo')({
      test: new Test(),
    })
    assert.strictEqual(warnCount, 1)
    console.warn = originWarn
  })
  it('should ignore and warn when passing in unserializable payload to sequence', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
    }

    const rootModule = {
      sequences: {
        foo: [({ props }) => assert.deepStrictEqual(props, {})],
      },
    }
    const controller = App(rootModule, {
      devtools: { init() {} },
    })
    controller.getSequence('foo')(new Date())
    assert.strictEqual(warnCount, 1)
    console.warn = originWarn
  })
  it('should return undefined when grabbing non existing state', () => {
    const rootModule = {}
    const controller = App(rootModule)
    assert.strictEqual(controller.getState('foo.bar'), undefined)
  })
  it('should flush at async action, resolved parallel and end of sequence', (done) => {
    let flushCount = 0
    const rootModule = {
      sequences: {
        test: [
          () => Promise.resolve(),
          [() => Promise.resolve(), () => Promise.resolve()],
        ],
      },
    }
    const controller = App(rootModule)
    const originFlush = controller.flush
    controller.flush = function(...args) {
      flushCount++
      originFlush.apply(this, args)
    }
    controller.once('end', () => {
      assert.strictEqual(flushCount, 4)
      done()
    })
    controller.getSequence('test')()
  })
  it('should flush model after module initialization', () => {
    const editor = {
      state: {
        this: 'that',
      },
    }
    const rootModule = {
      modules: {
        editor,
      },
    }
    const controller = App(rootModule)
    assert.deepStrictEqual(controller.model.changedPaths, [])
  })
  it('should flush async mutations', (done) => {
    const rootModule = {
      sequences: {
        test: [({ store }) => setTimeout(() => store.set(state`foo`, 'bar'))],
      },
    }
    const controller = App(rootModule)
    controller.on('flush', (changes) => {
      assert.deepStrictEqual(changes, [
        {
          path: ['foo'],
          forceChildPathUpdates: true,
        },
      ])
      done()
    })
    controller.getSequence('test')()
  })
  it('should flush optimally in complex sequences', (done) => {
    let flushCount = 0
    const rootModule = {
      sequences: {
        test: [
          () => {},
          () => Promise.resolve(),
          () => {},
          [
            ({ path }) => Promise.resolve(path.a()),
            {
              a: [() => {}],
            },
            () => Promise.resolve(),
          ],
        ],
      },
    }
    const controller = App(rootModule)
    const originFlush = controller.flush
    controller.flush = function(...args) {
      flushCount++
      originFlush.apply(this, args)
    }
    controller.once('end', () => {
      assert.strictEqual(flushCount, 4)
      done()
    })
    controller.getSequence('test')()
  })
  it('should remove default error listener when overriden', (done) => {
    const rootModule = {
      sequences: {
        test: [
          () => {
            foo.bar = 'baz' // eslint-disable-line no-undef
          },
        ],
      },
    }
    const controller = App(rootModule)
    controller.on('error', () => {
      assert(true)
      done()
    })
    controller.getSequence('test')()
  })
  it('should remove default error listener when overriden using devtools', (done) => {
    const rootModule = {
      sequences: {
        test: [
          () => {
            foo.bar = 'baz' // eslint-disable-line no-undef
          },
        ],
      },
    }
    const controller = App(rootModule, {
      devtools: {
        init(ctrl) {
          ctrl.on('error', () => {})
        },
      },
    })
    controller.on('error', () => {
      assert(true)
      done()
    })
    controller.getSequence('test')()
  })
  it('should expose method to removeModule using path', () => {
    const foo = {
      modules: {},
      sequences: {},
      state: {
        bar: 'baz',
      },
    }
    const rootModule = {
      modules: {
        foo,
      },
    }
    const controller = App(rootModule)
    assert.ok(controller.module.modules.foo)
    controller.removeModule('foo')
    assert.strictEqual(controller.getState('foo'), undefined)
  })
  it('should expose method to addModule using path', () => {
    const rootModule = {
      state: {
        test: true,
      },
    }
    const controller = App(rootModule)
    const module = {
      modules: {},
      sequences: {},
      state: { bar: 'baz' },
    }
    controller.addModule('foo', module)
    assert.ok(controller.module.modules.foo)
    assert.deepStrictEqual(controller.module.modules, {
      foo: {
        modules: {},
        sequences: {},
        reactions: {},
        state: {
          bar: 'baz',
        },
      },
    })

    assert.strictEqual(controller.getState('foo.bar'), 'baz')
  })
  it('should add sequences correctly when module added', () => {
    const rootModule = {}
    const controller = App(rootModule)
    const module = {
      sequences: {
        bar: [],
      },
    }
    controller.addModule('foo', module)
    assert.ok(controller.getSequence('foo.bar'))
  })
  it('should add correct state when adding module', () => {
    const rootModule = {}
    const controller = App(rootModule)
    const module = {
      modules: {},
      sequences: {},
      state: { bar: 'baz' },
    }
    controller.addModule('foo', module)
    assert.deepStrictEqual(controller.getState('foo.bar'), 'baz')
  })
  it('should add provider to contextProviders when adding module', () => {
    const rootModule = {}
    const controller = App(rootModule)
    const module = {
      state: { bar: 'baz' },
      providers: { foo: 'bar' },
    }
    const before = Object.keys(controller.contextProviders).length
    controller.addModule('foo', module)
    const after = Object.keys(controller.contextProviders).length
    assert.strictEqual(after, before + 1)
  })
  it('should add provider to contextProviders when adding module as function', () => {
    const rootModule = {}
    const controller = App(rootModule)
    const module = () => ({
      state: { bar: 'baz' },
      providers: { foo: 'bar' },
    })
    const before = Object.keys(controller.contextProviders).length
    controller.addModule('foo', module)
    const after = Object.keys(controller.contextProviders).length
    assert.strictEqual(after, before + 1)
  })
  it('should add subModule using path', () => {
    const foo = {
      state: {
        test: true,
      },
    }
    const rootModule = {
      modules: { foo },
    }
    const controller = App(rootModule)
    const module = {
      modules: {},
      sequences: {},
      state: { bar: 'baz' },
    }
    controller.addModule('foo.bar', module)
    assert.ok(controller.module.modules.foo.modules.bar)
    assert.deepStrictEqual(controller.module.modules.foo.modules, {
      bar: {
        modules: {},
        sequences: {},
        reactions: {},
        state: {
          bar: 'baz',
        },
      },
    })

    assert.strictEqual(controller.getState('foo.bar.bar'), 'baz')
  })
  it('should throw when module path is invalid', () => {
    const controller = App({})
    const module = {}
    assert.throws(() => {
      controller.addModule('foo.bar', module)
    })
    assert.throws(() => {
      controller.addModule('foo.bar.baz', module)
    })
  })
  it('should remove module using path', () => {
    const foo = {}
    const rootModule = {
      state: {},
      modules: {
        foo,
      },
    }
    const controller = App(rootModule)
    controller.removeModule('foo')
    assert.strictEqual(controller.module.modules.foo, undefined)
  })
  it('should remove providers when removing module', () => {
    const foo = {
      providers: {
        foo: {
          getBar() {
            return 'bar'
          },
        },
      },
    }
    const rootModule = {
      state: {},
      modules: {
        foo,
      },
    }
    const controller = App(rootModule)
    const before = Object.keys(controller.contextProviders).length
    controller.removeModule('foo')
    const after = Object.keys(controller.contextProviders).length
    assert.strictEqual(after, before - 1)
  })
  it('should remove subModule using path', () => {
    const bar = {}
    const foo = {
      modules: {
        bar,
      },
    }
    const rootModule = {
      state: {
        test: true,
      },
      modules: {
        foo,
      },
    }
    const controller = App(rootModule)
    controller.removeModule('foo.bar')
    assert.ok(controller.module.modules.foo)
    assert.strictEqual(controller.module.modules.foo.modules.bar, undefined)
  })
  it('should warn on remove module when module path is not provided', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
    }
    const rootModule = {}
    const controller = App(rootModule)
    controller.removeModule()
    assert.strictEqual(warnCount, 1)
    console.warn = originWarn
  })
  it('should throw on remove module when module path is invalid', () => {
    const rootModule = {}
    const controller = App(rootModule)
    assert.throws(() => {
      controller.removeModule('foo.bar')
    })
    assert.throws(() => {
      controller.removeModule('foo.bar.baz')
    })
  })
  it('should use error catchers in modules', (done) => {
    const rootModule = {
      state: {},
      sequences: {
        test: [
          () => {
            throw new Error('foo')
          },
        ],
      },
      catch: [
        [
          Error,
          [
            ({ props }) => {
              assert.ok(props.error)
              done()
            },
          ],
        ],
      ],
    }
    const controller = App(rootModule, { throwToConsole: false })
    controller.getSequence('test')()
  })
  it('should propagate errors up modules', (done) => {
    const foo = {
      sequences: {
        test: [
          () => {
            throw new Error('foo')
          },
        ],
      },
    }
    const rootModule = {
      modules: {
        foo,
      },
      catch: [
        [
          Error,
          [
            ({ props }) => {
              assert.ok(props.error)
              done()
            },
          ],
        ],
      ],
    }
    const controller = App(rootModule, {
      throwToConsole: false,
    })
    controller.getSequence('foo.test')()
  })
  it('should return promise when running sequences if option set', (done) => {
    const main = {
      sequences: {
        test: [],
      },
    }
    const app = App(main, {
      returnSequencePromise: true,
    })

    app
      .getSequence('test')()
      .then(() => {
        assert(true)
        done()
      })
  })
  it('should be able to reconfigure the instance', () => {
    const main = {
      state: {
        foo: 'bar',
      },
      sequences: {
        changeFoo: [({ store }) => store.set(state`foo`, 'bar2')],
      },
    }
    const newMain = {
      state: {
        foo: 'bar',
        bar: 'baz',
      },
      sequences: {
        changeFoo: [({ store }) => store.set(state`foo`, 'bar2')],
      },
    }
    const app = App(main, {
      devtools: {
        init() {},
        sendExecutionData() {},
        sendReInit() {},
        initialModelString: JSON.stringify(main.state),
      },
    })

    app.getSequence('changeFoo')()
    app.reconfigure(newMain)

    assert.deepStrictEqual(app.getState(), {
      foo: 'bar2',
      bar: 'baz',
    })
  })
  it('should be able to use computed as part of state path', () => {
    const main = {
      state: {
        foo: 'foo',
        foobarPath: (get) => get(state`foo`) + 'bar',
        foobar: 'baz',
      },
    }

    const app = App(main)

    assert.strictEqual(app.get(state`${state`foobarPath`}`), 'baz')
  })
  it('should be able to set computed on prop', () => {
    const main = {
      state: {
        foo: () => 'FOO',
        bar: null,
      },
      sequences: {
        test: [
          set(props`foo`, state`foo`),
          ({ props }) => {
            assert.strictEqual(props.foo, 'FOO')
          },
          set(state`bar`, props`foo`),
        ],
      },
    }

    const app = App(main)

    app.getSequence('test')()

    assert.strictEqual(app.get(state`bar`), 'FOO')
  })
})
