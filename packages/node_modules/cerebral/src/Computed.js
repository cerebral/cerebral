import { Tag } from 'function-tree'
import { throwError } from './utils'
import Watch from './Watch'

export class Computed extends Watch {
  constructor(dependencies, cb) {
    super('Computed')
    this.dependencies = dependencies
    this.computedCallback = cb
    this.dynamicDependencies = []
    this.subscriptions = []
    this.isDirty = true
    this.value = null
    this.props = null
    this.getters = null
    this.tags = Object.keys(this.dependencies).reduce((currentTags, key) => {
      const maybeTag = this.dependencies[key]

      if (maybeTag instanceof Tag) {
        return currentTags.concat(maybeTag.getTags())
      } else {
        throwError('You are not passing in an object with tags to a Computed')
      }

      return currentTags
    }, [])
    this.propsTags = this.tags.filter((tag) => tag.type === 'props')
    this.computedTags = this.tags.filter((tag) => tag.type === 'computed')

    this.onSubscription = this.onSubscription.bind(this)
    this.dynamicGetter = this.dynamicGetter.bind(this)

    this.watcherSubscription = null
  }
  createDependencyMap() {
    return this.controller.createDependencyMap(
      Object.keys(this.dependencies)
        .map((key) => this.dependencies[key])
        .concat(this.dynamicDependencies),
      this.props,
      this.modulePath
    )
  }
  clone() {
    return new Computed(this.dependencies, this.computedCallback).create(
      this.controller,
      this.modulePath,
      this.name + ' (clone)'
    )
  }
  subscribe(watcher, cb) {
    if (!this.watcherSubscription) {
      this.watcherSubscription = super.subscribe(this, this.onSubscription)
    }

    return super.subscribe(watcher, cb)
  }
  onSubscription() {
    this.isDirty = true
  }
  compute() {
    const getters = this.controller.createContext(this.props, this.modulePath)

    if (this.computedTags.length) {
      this.subscriptions.forEach((unsubscribe) => unsubscribe())
      this.subscriptions = this.computedTags
        .map((computedTag) => computedTag.getValue(getters))
        .map((computed) => computed.subscribe(this, this.onSubscription))
    }
    this.executedCount++
    return this.computedCallback(
      Object.keys(this.dependencies).reduce(
        (values, key) => {
          const dependency = this.dependencies[key]

          if (dependency instanceof Tag && dependency.type === 'computed') {
            values[key] = dependency.getValue(getters).getValue(this.props)
          } else if (dependency instanceof Tag) {
            values[key] = dependency.getValue(getters)
          }

          return values
        },
        {
          get: this.getDynamicGetter(),
        }
      )
    )
  }
  getDynamicGetter() {
    if (this.dynamicDependencies.length) {
      this.dynamicDependencies = []
    }

    return this.dynamicGetter
  }
  dynamicGetter(tag) {
    if (!(tag instanceof Tag)) {
      throw new Error(
        'Cerebral - Only tags are allowed in the dynamic "get" of Computed'
      )
    }
    const allTags = tag.getTags()

    allTags.forEach((tag) => {
      this.dynamicDependencies.push(tag)
    })

    return tag.getValue(this.getters)
  }
  hasChangedProps(props) {
    const nextGetters = this.controller.createContext(props)

    return this.propsTags.reduce((hasChanged, tag) => {
      if (hasChanged) {
        return true
      }

      return tag.getValue(this.getters) !== tag.getValue(nextGetters)
    }, false)
  }
  getValue(props) {
    if (!this.controller) {
      throw new Error('This Cerebral Computed has not been added to a module')
    }

    if (!this.watcherSubscription) {
      this.watcherSubscription = this.subscribe(this, this.onSubscription)
    }

    if (!this.isDirty && this.propsTags.length && this.hasChangedProps(props)) {
      this.isDirty = true
    }

    if (this.isDirty) {
      this.getters = this.controller.createContext(props)
      this.props = props
      this.value = this.compute()
      if (this.dynamicDependencies.length) {
        const prevDependencyMap = this.dependencyMap
        this.dependencyMap = this.createDependencyMap()
        this.controller.dependencyStore.updateEntity(
          this,
          prevDependencyMap,
          this.dependencyMap
        )
        if (this.controller.devtools) {
          this.controller.devtools.updateWatchMap(
            this,
            this.dependencyMap,
            prevDependencyMap
          )
        }
      }
      this.isDirty = false
    }

    return this.value
  }
}

export default (dependencies, cb) => {
  if (!cb) {
    cb = dependencies
    dependencies = {}
  }

  return new Computed(dependencies, cb)
}
