import { sequence, Action, ActionChain, ActionFactory, Chain, Computed } from '../..'
import { debounce, set, when } from './../../operators'
import { props, state, Tag } from './../../tags'

import { someComputed } from './computed'

export const actionFactory: ActionFactory = (foo: boolean) => () => ({ foo })

export const simpleAction: Action = ({ state, props }) => {
  state.concat('some.path', ['someValueA', 'someValueB'])
  state.increment('some.value')
  state.increment('some.value', 4)
  const value = state.get('foo.bar')
  state.merge('some.path', {
    some: 'value'
  })
  state.pop('some.path')
  state.push('some.path', 'someValue')
  state.set('app.ready', props.ready)
  state.shift('some.path')
  state.splice('some.path', 2, 1)
  state.toggle('some.path')
  state.unset('some.path')
  state.unshift('some.path', 'someValue')
}

export function someFactory(value1: Tag<string> | string, value2: Computed<number>): Action {
  return function someAction({ resolve, state }) {
    const test1 = resolve.isTag(value1) || resolve.isCompute(value1)
    const test2 = resolve.isTag(value2) || resolve.isCompute(value2)
    const resolvedValue1 = resolve.value(value1)
    const resolvedValue2 = resolve.value(value2)
    const resolvedNumber = resolve.value(123) + 1234
    const resolvedString = resolve.value('abc').substr(1,2)

    const overrideProps = resolve.value(value1, { this: 'that' })
  }
}


export const actionArray: ActionChain = [
  actionFactory(false),
  simpleAction,
  debounce(200), {
    continue: [simpleAction],
    discard: []
  },
  when(props`name`), {
    true: [set(state`app.name`, props`name`)],
    false: [] as ActionChain
  },
  sequence([simpleAction])
]