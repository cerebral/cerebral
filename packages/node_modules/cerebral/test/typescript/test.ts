import { compute, Computed, Action } from 'cerebral'
import { runAction, runCompute, runSignal } from 'cerebral/test'

interface Props {
  foo: string
  bar: number
}

interface Output {
  baz: string
}

const computed = compute('hello', (s: string) => s)

const someAction: Action<Props, Output> = ({ props: { foo, bar } }) => {
  const x = foo.length + bar
  return { baz: 'hop' }
}

const asyncAction: Action<Props, Promise<Output>> = ({ props: { foo, bar } }) => {
  const x = foo.length + bar
  return Promise.resolve({ baz: 'hop' })
}

const asyncAction2: Action<Props, Promise<{ foo2: string }>> = ({ props: { foo, bar } }) => {
  const x = foo.length + bar
  return Promise.resolve({ foo2: 'hop' })
}

runAction(someAction, { props: { foo: 'f', bar: 1 } }).then( result => {
  const a = result.props.foo.length
  const b = result.props.bar + 5
  const c = result.output.baz
})

runAction(asyncAction, { props: { foo: 'f', bar: 1 } }).then( result => {
  const a = result.props.foo.length
  const b = result.props.bar + 5
  const c = result.output.baz
})

runSignal([asyncAction, asyncAction2], { props: { foo: 'f', bar: 1 } }).then( result => {
  const a = result['0'].props.foo.length
  const b = result['0'].props.bar + 5
  const c = result['0'].output.baz
  const d = result['1'].output.foo2
})

const test = runCompute(computed).substr(0,5)
