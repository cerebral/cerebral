import { DevTools } from "./devtools"
import { FunctionTree, Payload, Provider, FunctionTreeExecutable} from 'function-tree'
import { Tag } from './tags'

export interface StateModel {
  get(path?: string): any
  set(path: string, value: any): void
  toggle(path: string): void
  unset(path: string): void
  merge(path: string, {}): void
  push(path: string, value: any): void
  unshift(path: string, value: any): void
  pop(path: string): void
  shift(path: string): void
  concat(path: string, arr: any[]): void
  splice(path: string, ...args: number[]): void
}

export interface Resolve {
  isTag(arg: any): boolean
  isCompute(arg: any): boolean

  path(tag: Tag): string
  value(tag: Tag): any
}

export interface ActionContext {
  [providerName: string]: any  
  state: StateModel
  props: any
  resolve: Resolve
  path: any
  controller: ControllerClass
  execution: any
  debugger: any
}

export interface Action extends FunctionTreeExecutable {
  (context?: ActionContext): void
}

export type ActionFactory = (...args: any[]) => Action

interface Paths extends FunctionTreeExecutable {
  [path: string]: Chain
}

export type Chain = FunctionTreeExecutable[]
export type SignalChain = Chain
export type ActionChain = Chain

type SignalsMap = { 
  [signalName: string]: SignalChain
}

interface ModuleObject {
  state?: any,
  signals?: SignalsMap,
  modules?: any,
  provider?(context: any, functionDetails: any, payload: any): void
}

type ModuleFunction = (module: {name: string, path: string, controller: ControllerClass}) => ModuleObject

export type Module = ModuleObject|ModuleFunction

type ModulesMap = { 
  [moduleName: string]: Module
}

export type Signal = (props?: any) => any

interface ControllerOptions {
  state?: any
  signals?: SignalsMap
  providers?: Provider[]
  modules?: ModulesMap
  devtools?: DevTools
  catch?: Map<ErrorConstructor, any[]>
}

export interface ControllerClass extends FunctionTree {
  constructor(config?: ControllerOptions): void
  flush(force: boolean): void
  updateComponents(changes: any[], force: boolean): void
  getModel(): StateModel
  getState(path?: string): any
  runSignal(name: string, signal: SignalChain, payload: any): void
  getSignal(path: string): Signal
  addModule(path: string, module: Module): void
  removeModule(path: string): void
}

export function Controller(config?: ControllerOptions): ControllerClass

export type ValueResolver = (tag: Tag) => any

export class Computed implements FunctionTreeExecutable {
  constructor(...args: (any|ValueResolver)[])
  getValue(getters: any): any
}

export function compute(...args: any[]): Computed
export function provide(name: string, provider: any): Function

export { sequence, parallel } from 'function-tree'
