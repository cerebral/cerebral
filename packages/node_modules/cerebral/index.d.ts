import { DevTools } from "./devtools"
import { Context, FunctionTree, Payload, Provider, Resolve, FunctionTreeExecutable} from 'function-tree'
import { Tag } from 'function-tree'

export interface StateModel {
  concat(path: string, arr: any[]): void
  increment(path: string, amount?: number): void
  get<T=any>(path?: string): T | undefined
  merge(path: string, {}): void
  pop(path: string): void
  push(path: string, value: any): void
  set(path: string, value: any): void
  shift(path: string): void
  splice(path: string, ...args: number[]): void
  toggle(path: string): void
  unset(path: string): void
  unshift(path: string, value: any): void
}

export interface ActionContextBase {
  controller: ControllerClass
  debugger: any
  state: StateModel
}

export type ActionContext<C = { props: any }> = Context<C> & ActionContextBase

export interface Action<C=any,T=void> extends FunctionTreeExecutable {
  (context: ActionContext<C>): T
}

export type ActionFactory<T={}> = (...args: any[]) => Action<T>

interface Paths extends FunctionTreeExecutable {
  [path: string]: Chain
}

export type Chain = FunctionTreeExecutable | FunctionTreeExecutable
export type SignalChain = Chain
export type ActionChain = Chain

type SignalsMap = { 
  [signalName: string]: SignalChain
}

interface ModuleObject {
  state?: any,
  signals?: SignalsMap,
  modules?: any,
  provider?(context: any, functionDetails: any, payload: any): void
}

type ModuleFunction = (module: {name: string, path: string, controller: ControllerClass}) => ModuleObject

export type Module = ModuleObject | ModuleFunction

type ModulesMap = { 
  [moduleName: string]: Module
}

export type Signal<T=any> = (props?: T) => void

interface ControllerOptions {
  state?: any
  signals?: SignalsMap
  providers?: Provider[]
  modules?: ModulesMap
  devtools?: DevTools
  catch?: Map<ErrorConstructor, SignalChain>
}

export interface ControllerClass extends FunctionTree {
  constructor(config?: ControllerOptions): void
  flush(force: boolean): void
  updateComponents(changes: any[], force: boolean): void
  getModel(): StateModel
  getState(path?: string): any
  runSignal(name: string, signal: SignalChain, payload: any): void
  getSignal(path: string): Signal
  addModule(path: string, module: Module): void
  removeModule(path: string): void
}

export function Controller(config?: ControllerOptions): ControllerClass

export type ValueResolver = <T=any>(tag: Tag<T>) => T

export class Computed<T=any> implements FunctionTreeExecutable {
  constructor(...args: (any|ValueResolver)[])
  getValue(getters: any): T
}

type TagOrComputed<T> = Tag<T> | Computed<T> | T

export function compute<A,T>(
  arg1: TagOrComputed<A>,
  fn: (arg1: A, get: ValueResolver) => T
): Computed<T>
export function compute<A,B,T>(
  arg1: TagOrComputed<A>,
  arg2: TagOrComputed<B>,
  fn: (arg1: A, arg2: B, get: ValueResolver) => T
): Computed<T>
export function compute<A,B,C,T>(
  arg1: TagOrComputed<A>,
  arg2: TagOrComputed<B>,
  arg3: TagOrComputed<C>,
  fn: (arg1: A, arg2: B, arg3: C, get: ValueResolver) => T
): Computed<T>

export function compute<A,B,T>(value1: Tag<A> | A, value2: Tag<B> | B, fn: ( value1: A, value2: B ) => T ): Computed<T>
export function compute<A,T>(value1: Tag<A> | A, fn: ( value1: A ) => T ): Computed<T>
export function compute<T=any>(...args: any[]): Computed<T>
export function provide(name: string, provider: any): Provider

export { sequence, parallel } from 'function-tree'

export class View {
    constructor(config:any)
}
