import {
  FunctionTree,
  Provider as FunctionTreeProvider,
  IContext as IFunctionTreeContext,
  Primitive,
  ResolveValue,
  TFunctionTreeExecutable,
} from 'function-tree'

import { DevTools } from './devtools'

export { sequence, parallel } from 'function-tree'
export type Sequence = Function
export {
  IBranchContext,
  SequenceFactory as ChainSequenceFactory,
  SequenceWithPropsFactory as ChainSequenceWithPropsFactory,
} from 'function-tree/fluent'

/*
  Tags
*/
type TaggedTemplate = (strings: TemplateStringsArray, ...values: any[]) => any
export const props: TaggedTemplate
export const string: TaggedTemplate
export const path: any // ??
export const state: TaggedTemplate
export const sequences: TaggedTemplate
export const moduleState: TaggedTemplate
export const moduleSequences: TaggedTemplate
export {
  createTemplateTag,
  extractValueWithPath,
  resolveObject,
  ResolveValue,
  Tag,
} from 'function-tree'

/*
  State
*/
export interface StateModel {
  concat(path: any, arr: any[]): void
  increment(path: any, amount?: number): void
  get<T = any>(any?: any): T | undefined
  merge(path: any, {}): void
  pop(path: any): void
  push(path: any, value: any): void
  set(path: any, value: any): void
  shift(path: any): void
  splice(path: any, ...args: number[]): void
  toggle(path: any): void
  unset(path: any): void
  unshift(path: any, value: any): void
}

export interface Store {
  concat<T>(path: T, arr: T): void
  increment(path: number, amount?: number): void
  merge<T>(path: T, obj: Partial<T>): void
  pop(path: any[]): void
  push<T>(path: Array<T>, value: T): void
  set<T>(path: T, value: T): void
  shift(path: any[]): void
  splice(path: any[], ...args: number[]): void
  toggle(path: boolean): void
  unset(path: any): void
  unshift<T>(path: Array<T>, value: T): void
}

export interface Get {
  <T>(tag: T): T
  path<T>(tag: T): string
}

export interface IContext<TProps={}> extends IFunctionTreeContext<TProps> {
  app: ControllerClass
  store: Store
  get: Get
}

/*
  Module
*/
interface ErrorClass {
  new (...args: any[]): any
}

export type SequencesMap = {
  [sequenceName: string]: Sequence
}

export interface ModuleObjectDefinition<State, Sequences, Compute> {
  state?: State
  sequences?: Sequences
  computed?: Compute
  reactions?: {
    [submodule: string]: void
  }
  modules?: {
    [submodule: string]: ModuleDefinition | ModuleClass
  }
  catch?: Function[][]
  providers?: {
    [providerName: string]: any
  }
}

export interface InstantiatedModuleObjectDefinition {
  state?: any
  sequences?: any
  reactions?: {
    [submodule: string]: void
  }
  modules?: {
    [submodule: string]: InstantiatedModuleObjectDefinition
  }
  computed?: {
    [computed: string]: any
  }
  catch?: Function[][]
  providers?: {
    [providerName: string]: any
  }
}

export type ModuleFunction<State = {}, Sequences = {}, Compute = {}> = (
  module: { name: string; path: string; app: ControllerClass }
) => ModuleObjectDefinition<State, Sequences, Compute>

export type ModuleDefinition<State = {}, Sequences = {}, Compute = {}> =
  | ModuleObjectDefinition<State, Sequences, Compute>
  | ModuleFunction<State, Sequences, Compute>

export class ModuleClass {
  // not public API
  create(
    controller: BaseControllerClass,
    path: string[]
  ): InstantiatedModuleObjectDefinition
}

export function Module<State = {}, Sequences = {}, Compute = {}>(
  moduleDefinition: ModuleDefinition<State, Sequences, Compute>
): ModuleClass

/*
  Connect
*/
export type RunableSequence<T = any> = (props?: T) => void

/*
  Controller
*/
export interface ControllerOptions {
  devtools?: DevTools
  throwToConsole?: boolean
  noRethrow?: boolean
  stateChanges?: any
  returnSequencePromise?: boolean
  Model?: any
}

export interface BaseControllerClass extends FunctionTree {
  getModel(): StateModel
  getState(path?: string): any
  get<T>(value: T): T
  runSequence(name: string, signal: Sequence, payload?: any): void
  getSequence<T = any>(path: string): RunableSequence<T>
  addModule(path: string, module: ModuleClass | ModuleDefinition): void
  removeModule(path: string): void
}

export class BaseControllerClass {
  model: any
  module: InstantiatedModuleObjectDefinition
  constructor(
    rootModule: ModuleClass | ModuleDefinition,
    options: ControllerOptions,
    functionTreeOptions: any
  )
}

interface ControllerClass extends BaseControllerClass {
  constructor(config?: ControllerOptions): void
  flush(force?: boolean): void
  updateComponents(changes: any[], force: boolean): void
}

export function Controller(
  rootModule: ModuleClass | ModuleDefinition,
  config?: ControllerOptions
): ControllerClass

export default function App(
  rootModule: ModuleClass | ModuleDefinition,
  config?: ControllerOptions
): ControllerClass

type ControllerSequence = string | Primitive | Array<Function | Primitive>
export interface UniversalControllerClass extends ControllerClass {
  setState(path: string, value: any): void
  getChanges(): { [path: string]: any }
  getScript(): string
  runSequence(sequence: ControllerSequence, payload: any): Promise<any>
}

export function UniversalController(
  rootModule: ModuleClass | ModuleDefinition,
  config?: ControllerOptions
): UniversalControllerClass

export function UniversalApp(
  rootModule: ModuleClass | ModuleDefinition,
  config?: ControllerOptions
): UniversalControllerClass

/*
  Compute
*/
export type ValueResolver = <T = any>(tag: ResolveValue<T>) => T

export class ComputedInstance<T = any> {
  constructor(...args: (any | ValueResolver)[])
  getValue(getters: any): T
}

export type ComputedGetter = Get

export function Compute<K>(cb: (get: ComputedGetter) => K): K

export function Reaction<T, K>(
  dependencies: T,
  cb: (dependencies: T & { get: ComputedGetter }) => void
): void

export function Provider(provider: any, options?: any): FunctionTreeProvider

export class View {
  constructor(config: any)
}

export class CerebralError {
  constructor(message: string, details?: any)
  name: string
  details: any
  toJSON: () => any
}
