import { DevTools } from './devtools'
import { IContext as IFunctionTreeContext, FunctionTree, IPayload, Provider as FunctionTreeProvider, IResolve, ResolveValue, TFunctionTreeExecutable, Primitive } from 'function-tree'

export { sequence, parallel } from 'function-tree'
export type Sequence = TFunctionTreeExecutable

/*
  Actions
*/
export interface StateModel {
  concat(path: string, arr: any[]): void
  increment(path: string, amount?: number): void
  get<T=any>(path?: string): T | undefined
  merge(path: string, {}): void
  pop(path: string): void
  push(path: string, value: any): void
  set(path: string, value: any): void
  shift(path: string): void
  splice(path: string, ...args: number[]): void
  toggle(path: string): void
  unset(path: string): void
  unshift(path: string, value: any): void
}


export interface IContext<TProps> extends IFunctionTreeContext<TProps> {
  controller: ControllerClass
  state: StateModel
}

/*
  Module
*/
interface ErrorClass {
  new(...args: any[]): any 
}

export type SignalsMap = { 
  [signalName: string]: Sequence
}

export interface ModuleObjectDefinition<State, Signals> {
  state?: State
  signals?: Signals
  modules?: {
    [submodule: string]: ModuleClass
  }
  catch?: [ ErrorClass, Sequence ][]
  providers?: {
    [providerName: string]: any
  }
}

export interface InstantiatedModuleObjectDefinition {
  state?: any
  signals?: any
  modules?: {
    [submodule: string]: InstantiatedModuleObjectDefinition
  }
  catch?: [ ErrorClass, Sequence ][]
  providers?: {
    [providerName: string]: any
  }
}

type ModuleFunction<State, Signals> = (module: {name: string, path: string, controller: ControllerClass}) => ModuleObjectDefinition<State, Signals>

export type ModuleDefinition<State, Signals> = ModuleObjectDefinition<State, Signals> | ModuleFunction<State, Signals>

export class ModuleClass {
  // not public API
  create(controller: BaseControllerClass, path: string[]): InstantiatedModuleObjectDefinition
}

export function Module<State = {}, Signals = {}>(moduleDefinition: ModuleDefinition<State, Signals>): ModuleClass

/*
  Connect
*/
export type Signal<T=any> = (props?: T) => void

/*
  Controller
*/ 
export interface ControllerOptions {
  devtools?: DevTools
  throwToConsole?: boolean
  Model?: any
}

export interface BaseControllerClass extends FunctionTree {
  getModel(): StateModel
  getState(path?: string): any
  runSignal(name: string, signal: Sequence, payload: any): void
  getSignal<T=any>(path: string): Signal<T>
  // Not sure this is used anymore
  addModule(path: string, module: ModuleClass): void
  // Not sure this is used anymore
  removeModule(path: string): void
}

export class BaseControllerClass {
  model: any
  module: InstantiatedModuleObjectDefinition
  constructor (rootModule: ModuleClass, options: ControllerOptions, functionTreeOptions: any)
}

interface ControllerClass extends BaseControllerClass {
  constructor(config?: ControllerOptions): void
  flush(force: boolean): void
  updateComponents(changes: any[], force: boolean): void
}

export function Controller(rootModule: ModuleClass, config?: ControllerOptions): ControllerClass

type ControllerSequence = string | Primitive | Array<Function | Primitive>
export interface UniversalControllerClass extends ControllerClass {
  setState(path: string, value: any): void
  getChanges(): {[path: string]: any}
  getScript(): string
  runSequence(sequence: ControllerSequence, payload: any): Promise<any>
}

export function UniversalController(rootModule: ModuleClass, config?: ControllerOptions): UniversalControllerClass

/*
  Computed
*/
export type ValueResolver = <T=any>(tag: ResolveValue<T>) => T

export class Computed<T=any> {
  constructor(...args: (any|ValueResolver)[])
  getValue(getters: any): T
}

export function Compute<A,T>(
  arg1: ResolveValue<A>,
  fn: (arg1: A, get: ValueResolver) => T
): Computed<T>
export function Compute<A,B,T>(
  arg1: ResolveValue<A>,
  arg2: ResolveValue<B>,
  fn: (arg1: A, arg2: B, get: ValueResolver) => T
): Computed<T>
export function Compute<A,B,C,T>(
  arg1: ResolveValue<A>,
  arg2: ResolveValue<B>,
  arg3: ResolveValue<C>,
  fn: (arg1: A, arg2: B, arg3: C, get: ValueResolver) => T
): Computed<T>

export function Compute<A,B,T>(value1: ResolveValue<A> | A, value2: ResolveValue<B> | B, fn: ( value1: A, value2: B ) => T ): Computed<T>
export function Compute<A,T>(value1: ResolveValue<A> | A, fn: ( value1: A ) => T ): Computed<T>
export function Compute<T=any>(...args: any[]): Computed<T>
export function Provider(provider: any, options?: any): FunctionTreeProvider

export class View {
    constructor(config:any)
}
