import { Action, Computed, ControllerClass, SignalChain } from './'

export interface RunSignalResult<P, T> {
  controller: ControllerClass
  props: P
  state: any
  output: T
}

export function runAction<P=any, T=any>(
  action: Action<P,Promise<T>>,
  fixtures?: { props: P & any } & any
): Promise<RunSignalResult<P, T>>

export function runAction<P=any, T=any>(
  action: Action<P,T>,
  fixtures?: { props: P & any } & any
): Promise<RunSignalResult<P, T>>

export function runCompute<T>(computed: Computed<T>, fixtures?: any): T

export function runSignal<P=any, T=any>(
  signal: SignalChain,
  fixtures?: { props: P & any } & any,
  options?: any
): Promise<RunSignalResult<P, T>>

interface CerebralTestType {
  runSignal<T=any>(signal: SignalChain, props: any): Promise<T>
  setState(path: string, value: any): void
  getState(path: string): any
}

export function CerebralTest(fixtures: any, options: any): CerebralTestType
