/* globals describe it expect */
import { transform } from 'babel-core'
import plugin from '../index'

const pluginOptions = {
  babelrc: false,
  plugins: [plugin],
}

describe('Transform dot syntax to template tags', () => {
  it('should transforms simple state dot syntax', () => {
    const code = `
      import {state} from 'cerebral';
      state.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow nested usage', () => {
    const code = `
      import {state} from 'cerebral';
      state.hello[state.world];
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should ignore variable when shadowed', () => {
    const code = `
      import {state} from 'cerebral';
      (state) => state.hello[state.world];
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow imported variable to be renamed', () => {
    const code = `
      import {state as anotherName} from 'cerebral';
      (state) => anotherName.hello[anotherName.world];
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should support expression in property accessor', () => {
    const code = `
      import {state} from 'cerebral';
      state.a[1+1]
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should not do anything when cerebral is not imported', () => {
    const code = `
      import {state} from 'other-module';
      state.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow for string accessors', () => {
    const code = `
      import {state} from 'cerebral';
      state.a['b']
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow access to variables', () => {
    const code = `
      import {state} from 'cerebral';
      const a = 'a';
      const b = 'b'
      state.a[a+b]
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should support immediate variable accessors', () => {
    const code = `
      import {state} from 'cerebral';
      const a = 'hello';
      const b = state.world;
      state[a][b].c
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should track variable assigment', () => {
    const code = `
      import {state} from 'cerebral';
      const a = state;
      const b = a;
      b.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should ignore unbound variable', () => {
    const code = `
      import {state} from 'cerebral';
      notState.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should do nothing when import is not a tag name', () => {
    const code = `
      import {wrongImport} from 'cerebral';
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should do nothing on default import', () => {
    const code = `
      import state from 'cerebral';
      state.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })
})

describe('Transform imports containing ".proxy"', () => {
  it('should rewrite tags but not import', () => {
    const code = `
      import {state} from 'app.cerebral.proxy.ts';
      state.world
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow renaming of imports', () => {
    const code = `
      import {state as fooBar} from 'app.cerebral.proxy.ts';
      fooBar.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })
  it('should not complain about other imports', () => {
    const code = `
      import {state, foo, bar} from 'app.cerebral.proxy.ts';
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })
})

describe('Transform namespaced imports', () => {
  it('should transform simple state dot syntax', () => {
    const code = `
      import * as proxies from 'cerebral';
      proxies.state.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should do nothing on wrong tag name', () => {
    const code = `
      import * as proxies from 'cerebral';
      proxies.foo.bar;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should keep track of bound variables', () => {
    const code = `
      import * as proxies from 'cerebral';
      const bar = proxies;
      (proxies) => proxies.state.hello.world;
      (proxies) => bar.state.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow assigning tags to variables', () => {
    const code = `
      import * as proxies from 'cerebral';
      const bar = proxies.state;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should keept track of assigned tags', () => {
    const code = `
      import * as proxies from 'cerebral';
      const bar = proxies.state;
      bar.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow for default import', () => {
    const code = `
      import App, * as proxies from 'cerebral';
      proxies.state.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })
})
