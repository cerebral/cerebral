/* globals describe it expect */
import { transform } from 'babel-core'
import plugin from '../index'

const pluginOptions = {
  babelrc: false,
  plugins: [plugin],
}

describe('Transform dot syntax to template tags', () => {
  it('should transforms simple state dot syntax', () => {
    const code = `
      import {state} from 'cerebral/proxy';
      state.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow nested usage', () => {
    const code = `
      import {state} from 'cerebral/proxy';
      state.hello[state.world];
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should ignore variable when shadowed', () => {
    const code = `
      import {state} from 'cerebral/proxy';
      (state) => state.hello[state.world];
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow imported variable to be renamed', () => {
    const code = `
      import {state as anotherName} from 'cerebral/proxy';
      (state) => anotherName.hello[anotherName.world];
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should support expression in property accessor', () => {
    const code = `
      import {state} from 'cerebral/proxy';
      state.a[1+1]
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should not do anything when cerebral/proxy is not imported', () => {
    const code = `
      import {state} from 'other-module';
      state.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow for string accessors', () => {
    const code = `
      import {state} from 'cerebral/proxy';
      state.a['b']
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should allow access to variables', () => {
    const code = `
      import {state} from 'cerebral/proxy';
      const a = 'a';
      const b = 'b'
      state.a[a+b]
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should track variable assigment', () => {
    const code = `
      import {state} from 'cerebral/proxy';
      const a = state;
      const b = a;
      b.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should ignore unbound variable', () => {
    const code = `
      import {state} from 'cerebral/proxy';
      notState.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should throw when import is not allowed', () => {
    const code = `
      import {wrongImport} from 'cerebral/proxy';
    `
    expect(() => {
      transform(code, pluginOptions)
    }).toThrowErrorMatchingSnapshot()
  })

  it('should throw on default import', () => {
    const code = `
      import state from 'cerebral/proxy';
      state.hello.world;
    `
    expect(() => {
      transform(code, pluginOptions)
    }).toThrowErrorMatchingSnapshot()
  })
})

describe('Transform dot syntax from `path` to string', () => {
  it('should work for simple dot usage', () => {
    const code = `
      import {path} from 'cerebral/proxy';
      path.hello.world;
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should work with nested usage', () => {
    const code = `
      import {path} from 'cerebral/proxy';
      path.hello[path.world];
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })

  it('should work with other tags', () => {
    const code = `
      import {path, state} from 'cerebral/proxy';
      path.hello[state.world];
    `
    const { code: result } = transform(code, pluginOptions)
    expect(result).toMatchSnapshot()
  })
})
