const allowedImportPath = ['cerebral/proxy']
const allowedImportVariables = ['state', 'props', 'signal', 'path']

function isDirectImport(location) {
  return allowedImportPath.indexOf(location.toLowerCase()) >= 0
}

function isIndirectImport(location) {
  return location.includes('cerebral.proxy')
}

function isAllowedImport(importName) {
  return allowedImportVariables.indexOf(importName.toLowerCase()) >= 0
}

function isPlainPropertyAccess(t, property, computed) {
  return (
    (t.isIdentifier(property) && computed === false) ||
    (t.isLiteral(property) && property.value)
  )
}

export default function({ types: t }) {
  // Tests if the `name` is a valid import variable
  // or if it's a binding to a valid one.
  // Will return the name of the used variabel or null
  // if nothing was found
  function getUsedVariable(scope, name, importedVariable) {
    const binding = scope.getBinding(name)
    if (!binding) return null
    if (t.isVariableDeclarator(binding.path.node)) {
      return getUsedVariable(
        binding.path.scope,
        binding.path.node.init.name,
        importedVariable
      )
    }
    return importedVariable.has(name) && binding.kind === 'module' ? name : null
  }

  return {
    pre() {
      // Used to track renaming imports in local file
      // eg. import { state as s } from 'cerebral/proxies';
      this.importedVariable = new Set()
    },
    visitor: {
      ImportDeclaration(path) {
        const { node: { source: { value: importLocation } } } = path

        // The plan:
        //
        // 1) When import of cerebral/proxy found (directImport)
        //    a. Trigger conversion to tags
        //    b. Rewrite import to cerebral/tags

        // 2) When import containing cerebral.proxy in the name (indirectImport)
        //    a. Trigger conversion to tags

        const directImport = isDirectImport(importLocation) // 1)
        const indirectImport = isIndirectImport(importLocation) // 2)

        if (directImport || indirectImport) {
          // 1,2) a. Trigger conversion to tags

          // Complain about default import
          if (
            path.node.specifiers.some((item) =>
              t.isImportDefaultSpecifier(item)
            )
          ) {
            throw path.buildCodeFrameError(`Default import is not allowed`)
          }

          // Verify that all imports are allowed and track the localName
          for (const {
            imported: { name: importName },
            local: { name: localName },
          } of path.node.specifiers) {
            if (isAllowedImport(importName)) {
              this.importedVariable.add(localName)
            } else if (directImport) {
              // Only complain about unkown imports
              // if it is a directImport
              throw path.buildCodeFrameError(
                `"${importName}" is not a valid import`
              )
            }
          }

          // 1) b. Rewrite import to cerebral/tags
          if (directImport) {
            // Change import to the 'cerebral/tags'
            path.node.source.value = 'cerebral/tags'

            // Remove "path" from imports
            path.node.specifiers = path.node.specifiers.filter(
              (item) => item.imported.name !== 'path'
            )

            // remove if there aren't any specifiers left
            // This could happen if only `path` was used.
            if (path.node.specifiers.length === 0) {
              path.remove()
            }
          }
        }
      },
      MemberExpression(path) {
        // Always use the innermost MemberExpression
        if (!t.isIdentifier(path.node.object)) {
          return
        }

        const tagName = getUsedVariable(
          path.scope,
          path.node.object.name,
          this.importedVariable
        )

        if (!tagName) {
          return
        }

        let quasi = []
        let quasis = [quasi]
        let expressions = []
        let prevWasExpression = false

        let rootMemberExpression
        let currentMember = path

        // Iterate trough all parents
        while (t.isMemberExpression(currentMember)) {
          const { node: { property, computed } } = currentMember

          // Plain id like state.a[1].b['test']
          if (isPlainPropertyAccess(t, property, computed)) {
            const value = t.isLiteral(property) ? property.value : property.name
            quasi.push(
              (quasi.length !== 0 || prevWasExpression ? '.' : '') + value
            )
            prevWasExpression = false
            // Nested expressions like state.a[state.b]
          } else {
            quasi.push('.')
            expressions.push(property)
            quasi = []
            quasis.push(quasi)
            prevWasExpression = true
          }

          // Save the rootMember
          rootMemberExpression = currentMember

          // Advance to next parent
          currentMember = currentMember.parentPath
        }

        if (tagName === 'path') {
          // Rewrite to a templateLiteral like
          // `foo.bar`
          rootMemberExpression.replaceWith(
            t.templateLiteral(
              quasis.map((v) => {
                const str = v.join('')
                return t.templateElement({ raw: str, cooked: str })
              }),
              expressions
            )
          )
        } else {
          // Rewrite with a tagged template like
          // state`foo.bar`
          rootMemberExpression.replaceWith(
            t.taggedTemplateExpression(
              t.identifier(tagName),
              t.templateLiteral(
                quasis.map((v) => {
                  const str = v.join('')
                  return t.templateElement({ raw: str, cooked: str })
                }),
                expressions
              )
            )
          )
        }
      },
    },
  }
}
