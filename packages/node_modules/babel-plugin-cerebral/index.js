const allowedImportPath = ['cerebral/proxy']
const allowedImportVariables = ['state', 'props', 'signal', 'path']

function isValidImportLocation(location) {
  return allowedImportPath.indexOf(location.toLowerCase()) >= 0
}

function isAllowedImport(importName) {
  return allowedImportVariables.indexOf(importName.toLowerCase()) >= 0
}

function isPlainPropertyAccess(t, property, computed) {
  return (
    (t.isIdentifier(property) && computed === false) ||
    (t.isLiteral(property) && property.value)
  )
}

export default function({ types: t }) {
  // Tests if the `name` is a valid import variable
  // or if it's a binding to a valid one.
  // Will return the name of the used variabel or null
  // if nothing was found
  function getUsedVariable(scope, name, importedVariable) {
    const binding = scope.getBinding(name)
    if (!binding) return null
    if (t.isVariableDeclarator(binding.path.node)) {
      return getUsedVariable(
        binding.path.scope,
        binding.path.node.init.name,
        importedVariable
      )
    }
    return importedVariable.has(name) && binding.kind === 'module' ? name : null
  }

  return {
    pre() {
      // Used to track renaming imports in local file
      // eg. import { state as s } from 'cerebral/proxies';
      this.importedVariable = new Set()
    },
    visitor: {
      ImportDeclaration(path) {
        const { node: { source: { value }, source } } = path
        if (t.isStringLiteral(source) && isValidImportLocation(value)) {
          // Complain about default import
          if (
            path.node.specifiers.some((item) =>
              t.isImportDefaultSpecifier(item)
            )
          ) {
            throw path.buildCodeFrameError(`Default import is not allowed`)
          }

          // Verify that all imports are allowed and track the localName
          for (const {
            imported: { name: importName },
            local: { name: localName },
          } of path.node.specifiers) {
            if (isAllowedImport(importName)) {
              this.importedVariable.add(localName)
            } else {
              throw path.buildCodeFrameError(
                `"${importName}" is not a valid import`
              )
            }
          }

          // Remove "path" from imports
          path.node.specifiers = path.node.specifiers.filter(
            (item) => item.imported.name !== 'path'
          )

          // Change import to the real 'cerebral/tags'
          path.node.source.value = 'cerebral/tags'

          // remove if there aren't any specifiers left
          if (path.node.specifiers.length === 0) {
            path.remove()
          }
        }
      },
      MemberExpression(path) {
        // Always use the innermost MemberExpression
        if (!t.isIdentifier(path.node.object)) {
          return
        }

        const tagName = getUsedVariable(
          path.scope,
          path.node.object.name,
          this.importedVariable
        )

        if (!tagName) {
          return
        }

        let quasi = []
        let quasis = [quasi]
        let expressions = []
        let prevWasExpression = false

        let rootMemberExpression
        let currentMember = path

        // Iterate trough all parents
        while (t.isMemberExpression(currentMember)) {
          const { node: { property, computed } } = currentMember

          // Plain id like state.a[1].b['test']
          if (isPlainPropertyAccess(t, property, computed)) {
            const value = t.isLiteral(property) ? property.value : property.name
            quasi.push(
              (quasi.length !== 0 || prevWasExpression ? '.' : '') + value
            )
            prevWasExpression = false
            // Nested expressions like state.a[state.b]
          } else {
            quasi.push('.')
            expressions.push(property)
            quasi = []
            quasis.push(quasi)
            prevWasExpression = true
          }

          // Save the rootMember
          rootMemberExpression = currentMember

          // Advance to next parent
          currentMember = currentMember.parentPath
        }

        if (tagName === 'path') {
          // Rewrite to a templateLiteral like
          // `foo.bar`
          rootMemberExpression.replaceWith(
            t.templateLiteral(
              quasis.map((v) => {
                const str = v.join('')
                return t.templateElement({ raw: str, cooked: str })
              }),
              expressions
            )
          )
        } else {
          // Rewrite with a tagged template like
          // state`foo.bar`
          rootMemberExpression.replaceWith(
            t.taggedTemplateExpression(
              t.identifier(tagName),
              t.templateLiteral(
                quasis.map((v) => {
                  const str = v.join('')
                  return t.templateElement({ raw: str, cooked: str })
                }),
                expressions
              )
            )
          )
        }
      },
    },
  }
}
