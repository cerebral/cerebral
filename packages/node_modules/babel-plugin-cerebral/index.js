const directImportName = ['cerebral']
const validTagNames = [
  'path',
  'props',
  'state',
  'sequences',
  'computed',
  'moduleState',
  'moduleComputed',
  'moduleSequences',
]

function isDirectImport(location) {
  return directImportName.indexOf(location.toLowerCase()) >= 0
}

function isIndirectImport(location) {
  return location.includes('.proxy')
}

function isTagName(tagName) {
  return validTagNames.indexOf(tagName) >= 0
}

function isPlainPropertyAccess(t, property, computed) {
  return (
    (t.isIdentifier(property) && computed === false) ||
    (t.isLiteral(property) && property.value)
  )
}

export default function({ types: t }) {
  // Tests if the `name` is a valid import variable
  // or if it's a binding to a valid one.
  // Will return the name of the used variabel or null
  // if nothing was found
  function getUsedVariable(scope, name) {
    const binding = scope.getBinding(name)
    if (!binding) return {}
    if (binding.path.getData('cerebral_proxy_tagged')) {
      return {
        tagged: true,
        name,
      }
    } else if (
      t.isVariableDeclarator(binding.path.node) &&
      binding.path.node.init
    ) {
      return getUsedVariable(binding.path.scope, binding.path.node.init.name)
    }

    return {
      tagged: false,
      name: binding.kind === 'module' ? name : null,
    }
  }

  return {
    pre() {
      // Used to track renaming imports in local file
      // eg. import { state as s } from 'cerebral';
      this.importedVariable = new Set()
      this.namespace = null
    },
    visitor: {
      ImportDeclaration(path) {
        const {
          node: {
            source: { value: importLocation },
          },
        } = path
        // Two possible ways of triggering this plugin:
        //
        // 1) When import from 'cerebral' found (directImport)
        // 2) When import containing the string '.proxy' (indirectImport)

        const directImport = isDirectImport(importLocation) // 1)
        const indirectImport = isIndirectImport(importLocation) // 2)

        if (directImport || indirectImport) {
          const { specifiers } = path.node
          // Two possible ways of importing these proxy tags

          // 1) import * as proxies from 'cerebral';
          const namespaceImport = specifiers.find((specifier) =>
            t.isImportNamespaceSpecifier(specifier)
          )
          if (namespaceImport !== undefined) {
            this.namespace = namespaceImport.local.name
          }

          // 2) import { state } from 'cerebral';
          const importSpecifiers = specifiers.filter((specifer) =>
            t.isImportSpecifier(specifer)
          )

          // Add all valid tags by there imported localName
          // e.g. import { state as s } from 'cerebral';
          for (const {
            imported: { name: importName },
            local: { name: localName },
          } of importSpecifiers) {
            if (isTagName(importName)) {
              this.importedVariable.add(localName)
            }
          }
        }
      },
      MemberExpression(path) {
        // Always use the innermost MemberExpression
        // and don't process taggedTemplateExpressions
        if (
          !t.isIdentifier(path.node.object) ||
          t.isTaggedTemplateExpression(path.parent)
        ) {
          return
        }

        const objectName = path.node.object.name
        const { tagged, name: tagRoot } = getUsedVariable(
          path.scope,
          objectName
        )

        // Contains the target of the taggedTemplate
        // either e.g. `state` or proxies.state
        let targetExpression
        let tagName = tagRoot

        // Is tagRoot a reference to the namespace e.g. proxies.state
        if (this.namespace && tagRoot === this.namespace) {
          tagName = path.node.property.name

          targetExpression = t.memberExpression(
            t.identifier(objectName),
            t.identifier(tagName)
          )
          path = path.parentPath
        } else {
          // if this variable was tagged before
          // we don't want to bail here
          if (!tagged && !this.importedVariable.has(tagRoot)) {
            return
          }
          targetExpression = t.identifier(tagRoot)
        }

        let quasi = []
        let quasis = [quasi]
        let expressions = []
        let prevWasExpression = false

        let rootMemberExpression
        let currentMember = path

        // Iterate trough all parents
        while (t.isMemberExpression(currentMember)) {
          const {
            node: { property, computed },
          } = currentMember

          // Plain id like state.a[1].b['test']
          if (isPlainPropertyAccess(t, property, computed)) {
            const value = t.isLiteral(property) ? property.value : property.name
            quasi.push(
              (quasi.length !== 0 || prevWasExpression ? '.' : '') + value
            )
            prevWasExpression = false
            // Nested expressions like state.a[state.b]
          } else {
            quasi.push('.')
            expressions.push(property)
            quasi = []
            quasis.push(quasi)
            prevWasExpression = true
          }

          // Save the rootMember
          rootMemberExpression = currentMember

          // Advance to next parent
          currentMember = currentMember.parentPath
        }

        // Bail on proxies.state usage
        if (quasis.length === 1 && quasis[0].length === 0) {
          // but tag the path to detect it in getUsedVariable
          path.setData('cerebral_proxy_tagged', true)
          return
        }
        // Rewrite with a tagged template like
        // state`foo.bar` or proxies.state`foo.bar`
        rootMemberExpression.replaceWith(
          t.taggedTemplateExpression(
            targetExpression,
            t.templateLiteral(
              quasis.map((v) => {
                const str = v.join('')
                return t.templateElement({ raw: str, cooked: str })
              }),
              expressions
            )
          )
        )
      },
    },
  }
}
